{% extends "base.html" %}

{% block title %}Tree Artifacts{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
    .clustering-controls {
        background-color: #f8f9fa;
        padding: 15px;
        border-radius: 6px;
        margin-bottom: 20px;
    }
    
    /* Tree Structure Styling - updated for new layout */
    .tree-container {
        font-family: 'Monaco', 'Consolas', monospace;
        background-color: #f8f9fa;
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
    }
    
    .tree-node {
        margin: 2px 0;
        border-left: 2px solid transparent;
        transition: all 0.2s ease;
    }
    
    .tree-node:hover {
        background-color: rgba(0, 123, 255, 0.05);
        border-left-color: #007bff;
    }
    
    /* Smart indentation - consistent small increments */
    .tree-level-0 { margin-left: 0px; }
    .tree-level-1,
    .tree-level-2,
    .tree-level-3,
    .tree-level-4,
    .tree-level-5,
    .tree-level-6,
    .tree-level-7,
    .tree-level-8,
    .tree-level-9,
    .tree-level-10,
    .tree-level-deep { /* All non-root levels get the same single-step indent */
        margin-left: 12px;
    }
    
    /* Beyond level 10, use a different visual cue */
    .tree-level-deep {
        /* margin-left: 12px; is handled above */
        border-left: 3px dotted #6c757d; /* This border is part of the node itself */
        padding-left: 10px; /* This will indent the *content* of tree-level-deep nodes further */
    }
    
    .cluster-header {
        display: flex;
        align-items: center;
        padding: 8px 12px;
        cursor: pointer;
        background-color: white;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        margin-bottom: 3px;
        transition: all 0.2s ease;
    }
    
    .cluster-header:hover {
        background-color: #e3f2fd;
        border-color: #007bff;
        transform: translateX(2px);
    }
    
    .cluster-header.expanded {
        background-color: #e8f5e9;
        border-color: #28a745;
    }
    
    /* Style for nodes that don't subdivide (single child) */
    .cluster-header.no-subdivision {
        background-color: #f8f9fa;
        border-style: dashed;
        opacity: 0.8;
    }
    
    .cluster-header.no-subdivision:hover {
        background-color: #e9ecef;
        opacity: 1;
    }
    
    /* NEW: Representative text styling - now the main editable element */
    .cluster-representative {
        font-size: 1em;
        font-weight: bold;
        color: #212529;
        background-color: transparent;
        border: 1px solid transparent;
        border-radius: 4px;
        padding: 4px 8px;
        margin-right: 8px;
        flex: 1;
        min-height: 24px;
        cursor: text;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 6px;
    }
    
    .cluster-representative:hover {
        border-color: #007bff;
        background-color: rgba(255, 255, 255, 0.8);
    }
    
    .cluster-representative.editing {
        border-color: #28a745;
        background-color: white;
        outline: none;
        box-shadow: 0 0 0 0.2rem rgba(40, 167, 69, 0.25);
    }
    
    /* FontAwesome state icons */
    .text-state-icon {
        font-size: 0.8em;
        opacity: 0.7;
        margin-right: 4px;
        flex-shrink: 0;
    }
    
    .text-state-icon.fa-quote-left {
        color: #6c757d;
    }
    
    .text-state-icon.fa-pencil {
        color: #228B22; /* Green for manual edit */
    }
    
    .text-state-icon.fa-wand-magic-sparkles {
        color: #6f42c1;
    }
    
    /* State-based text coloring for representative text */
    .cluster-representative[data-state="default"] .representative-text,
    .cluster-representative:not([data-state]) .representative-text {
        color: #495057; /* Dark grey for default/representative */
    }
    
    .cluster-representative[data-state="manual"] .representative-text {
        color: #228B22; /* Green for manually edited */
    }
    
    .cluster-representative[data-state="ai"] .representative-text {
        color: #6f42c1; /* Purple for AI generated */
    }
    
    /* Auto-generate button */
    .auto-generate-btn {
        background: linear-gradient(135deg, #f8f9fa, #e9ecef);
        border: 1px solid #6f42c1;
        border-radius: 6px;
        padding: 6px 10px;
        margin-right: 12px;
        cursor: pointer;
        color: #6f42c1;
        font-size: 0.75em;
        transition: all 0.2s ease;
        flex-shrink: 0;
        box-shadow: 0 1px 2px rgba(111, 66, 193, 0.1);
    }
    
    .auto-generate-btn:hover {
        background: linear-gradient(135deg, #6f42c1, #8a5cf5);
        border-color: #6f42c1;
        color: white;
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(111, 66, 193, 0.2);
    }
    
    /* NEW: Small gray label - now secondary with more spacing */
    .cluster-label {
        font-size: 0.75em;
        color: #6c757d;
        font-weight: normal;
        margin-right: 15px;
        margin-left: 5px;
        padding: 2px 6px;
        background-color: #f8f9fa;
        border-radius: 3px;
        flex-shrink: 0;
    }
    
    .cluster-size {
        background-color: #007bff;
        color: white;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.8em;
        margin-left: auto;
        flex-shrink: 0;
    }
    
    .cluster-actions {
        margin-left: 8px;
        display: flex;
        gap: 5px;
    }
    
    .collapse-icon {
        transition: transform 0.2s ease;
        margin-right: 8px;
        color: #6c757d;
        flex-shrink: 0;
    }
    
    .collapse-icon.expanded {
        transform: rotate(90deg);
    }
    
    .cluster-content {
        padding: 15px 8px 15px 0px;
        background-color: #f8f9fa;
        border: 1px solid #dee2e6;
        border-top: none;
        border-radius: 0 0 6px 6px;
        margin-bottom: 10px;
    }
    
    .goal-item {
        padding: 8px 12px;
        margin: 5px 0;
        background-color: white;
        border-left: 3px solid #007bff;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    
    .goal-text {
        font-size: 0.9em;
        line-height: 1.4;
        margin-bottom: 4px;
        color: #343a40;
    }
    
    .goal-source {
        font-size: 0.6em;
        color: #6c757d;
        font-style: italic;
    }
    
    .clustering-stats {
        background-color: #e3f2fd;
        border: 1px solid #90caf9;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
    }
    
    /* Level Controls - matching cluster_tree */
    .level-button {
        font-weight: bold;
        min-width: 80px;
        min-height: 60px;
        text-align: center;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding: 8px 12px;
        line-height: 1.2;
    }
    
    .level-button.active {
        background-color: #28a745;
        border-color: #28a745;
        color: white;
    }
    
    /* Flattened Content */
    .flattened-cluster {
        margin-bottom: 20px;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        overflow: hidden;
    }
    
    .flattened-cluster-header {
        background-color: #f8f9fa;
        padding: 12px 15px;
        border-bottom: 1px solid #dee2e6;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .flattened-cluster-title {
        font-weight: bold;
        color: #495057;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .flattened-cluster-content {
        padding: 15px;
        background-color: white;
    }
    
    .artifact-badge {
        background: linear-gradient(45deg, #6f42c1, #e83e8c);
        color: white;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 0.7em;
        font-weight: bold;
    }

    /* AI Generation Modal */
    .goal-preview {
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        padding: 10px;
        background-color: #f8f9fa;
        font-size: 0.85em;
    }
    
    .goal-preview-item {
        padding: 4px 0;
        border-bottom: 1px solid #e9ecef;
    }
    
    .goal-preview-item:last-child {
        border-bottom: none;
    }
    
    .goal-preview-text {
        font-weight: 500;
        color: #495057;
    }
    
    .goal-preview-source {
        font-size: 0.75em;
        color: #6c757d;
        margin-top: 2px;
    }
    
    /* Collapsible artifact selection styling */
    .artifact-selection-container {
        margin-bottom: 20px;
    }
    
    .collapsed-title {
        padding: 5px 0;
        margin-bottom: 5px;
    }
    
    .collapsed-title .btn {
        font-size: 0.85em;
        color: #6c757d !important;
        transition: all 0.2s ease;
    }
    
    .collapsed-title .btn:hover {
        color: #6f42c1 !important;
    }
    
    .collapsed-title .btn i {
        transition: transform 0.2s ease;
    }
    
    /* Show collapsed title only when section is collapsed */
    .artifact-selection-container:has(#artifact-selection.show) .collapsed-title,
    .artifact-selection-container:has(#artifact-selection.collapsing) .collapsed-title {
        display: none;
    }
    
    /* Alternative approach for broader browser support */
    .collapsed-title.hidden {
        display: none;
    }
    
    /* Chevron rotation */
    .collapsed-title .btn[aria-expanded="true"] i {
        transform: rotate(90deg);
    }

    /* Move/Delete Action Buttons */
    .action-buttons {
        display: flex;
        gap: 5px;
        margin-left: 8px;
        flex-shrink: 0;
    }
    
    .move-btn, .delete-btn {
        padding: 4px 6px;
        border-radius: 4px;
        border: 1px solid;
        cursor: pointer;
        font-size: 0.7em;
        transition: all 0.2s ease;
        background-color: white;
        opacity: 0.7;
        min-width: 24px;
        text-align: center;
    }
    
    .move-btn {
        border-color: #17a2b8;
        color: #17a2b8;
    }
    
    .move-btn:hover {
        background-color: #17a2b8;
        color: white;
        opacity: 1;
        transform: scale(1.1);
    }
    
    .delete-btn {
        border-color: #dc3545;
        color: #dc3545;
    }
    
    .delete-btn:hover {
        background-color: #dc3545;
        color: white;
        opacity: 1;
        transform: scale(1.1);
    }
    
    .delete-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
        border-color: #6c757d;
        color: #6c757d;
    }
    
    .delete-btn:disabled:hover {
        background-color: white;
        color: #6c757d;
        transform: none;
    }

    /* Individual Goal Move/Delete Buttons */
    .goal-actions {
        display: flex;
        gap: 4px;
        margin-top: 4px;
        margin-left: auto;
        opacity: 0;
        transition: opacity 0.2s ease;
    }
    
    .goal-item:hover .goal-actions {
        opacity: 1;
    }
    
    .goal-move-btn, .goal-delete-btn {
        padding: 2px 4px;
        border-radius: 3px;
        border: 1px solid;
        cursor: pointer;
        font-size: 0.6em;
        transition: all 0.2s ease;
        background-color: white;
        min-width: 20px;
        text-align: center;
    }
    
    .goal-move-btn {
        border-color: #17a2b8;
        color: #17a2b8;
    }
    
    .goal-move-btn:hover {
        background-color: #17a2b8;
        color: white;
    }
    
    .goal-delete-btn {
        border-color: #dc3545;
        color: #dc3545;
    }
    
    .goal-delete-btn:hover {
        background-color: #dc3545;
        color: white;
    }

    /* Archive Button */
    .archive-btn {
        background-color: #f8f9fa;
        border: 1px solid #6c757d;
        color: #6c757d;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.7em;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .archive-btn:hover {
        background-color: #6c757d;
        color: white;
    }

    /* Move Modal Styles */
    .move-modal .modal-dialog {
        max-width: 700px;
    }
    
    .move-destination-tree {
        max-height: 400px;
        overflow-y: auto;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 10px;
        background-color: #f8f9fa;
    }
    
    .destination-node {
        margin: 2px 0;
        padding: 4px 8px;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .destination-node:hover {
        background-color: #e3f2fd;
    }
    
    .destination-node.current-location {
        background-color: #fff3e0;
        border: 1px solid #ff9800;
    }
    
    .destination-node.invalid-destination {
        background-color: #ffebee;
        opacity: 0.6;
        cursor: not-allowed;
    }
    
    .destination-node-content {
        flex: 1;
        display: flex;
        align-items: center;
    }
    
    .destination-node-text {
        font-weight: 500;
        flex-grow: 1;
    }
    
    .destination-path-info {
        flex-shrink: 0;
        opacity: 0.7;
        transition: opacity 0.2s ease;
    }
    
    .destination-path-info:hover {
        opacity: 1;
        color: #007bff !important;
    }
    
    .move-here-btn {
        padding: 2px 8px;
        font-size: 0.7em;
        border-radius: 3px;
        background-color: #28a745;
        border: 1px solid #28a745;
        color: white;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .move-here-btn:hover {
        background-color: #218838;
        transform: scale(1.05);
    }
    
    .move-search-input {
        margin-bottom: 15px;
        padding: 8px 12px;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        font-size: 0.9em;
        width: 100%;
    }
    
    .move-search-input:focus {
        outline: none;
        border-color: #007bff;
        box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
    }
    
    .destination-node.search-match {
        background-color: #fff9c4;
        border: 1px solid #fbc02d;
    }
    
    .destination-node.search-match .destination-node-text {
        font-weight: bold;
    }

    /* New Group Creation Styles */
    .new-group-tree-selector {
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 10px;
        background-color: #f8f9fa;
    }
    
    .tree-level-item {
        margin: 3px 0;
        padding: 6px 10px;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 8px;
        border: 1px solid transparent;
    }
    
    .tree-level-item:hover {
        background-color: #e3f2fd;
        border-color: #2196f3;
    }
    
    .tree-level-item.selected {
        background-color: #c8e6c9;
        border-color: #4caf50;
        font-weight: 500;
    }
    
    .tree-level-item .expand-icon {
        transition: transform 0.2s ease;
        color: #6c757d;
        font-size: 0.8em;
        width: 12px;
        text-align: center;
    }
    
    .tree-level-item.expanded .expand-icon {
        transform: rotate(90deg);
    }
    
    .tree-level-item.leaf .expand-icon {
        opacity: 0.3;
    }
    
    .tree-level-text {
        flex-grow: 1;
    }
    
    .select-location-btn {
        padding: 2px 8px;
        font-size: 0.7em;
        border-radius: 3px;
        background-color: #28a745;
        border: 1px solid #28a745;
        color: white;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .select-location-btn:hover {
        background-color: #218838;
        transform: scale(1.05);
    }
    
    .tree-children {
        margin-left: 20px;
        margin-top: 5px;
        border-left: 1px dashed #dee2e6;
        padding-left: 10px;
    }

    /* Archive Modal Styles */
    .archived-goals-container {
        max-height: 400px;
        overflow-y: auto;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 15px;
        background-color: #f8f9fa;
    }
    
    .archived-goal-item {
        padding: 10px;
        margin: 8px 0;
        background-color: white;
        border-left: 3px solid #6c757d;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    
    .archived-goal-text {
        font-size: 0.9em;
        color: #495057;
        margin-bottom: 5px;
    }
    
    .archived-goal-meta {
        font-size: 0.7em;
        color: #6c757d;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .restore-btn {
        padding: 2px 6px;
        font-size: 0.6em;
        background-color: #28a745;
        border: 1px solid #28a745;
        color: white;
        border-radius: 3px;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .restore-btn:hover {
        background-color: #218838;
    }

    /* Progress Animation Styles */
    .operation-progress {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        border: 2px solid #007bff;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        z-index: 9999;
        min-width: 300px;
        text-align: center;
    }
    
    .operation-progress .spinner-border {
        margin-bottom: 10px;
    }
    
    .operation-progress-text {
        margin-bottom: 10px;
        font-weight: 500;
    }
    
    .operation-progress-details {
        font-size: 0.8em;
        color: #6c757d;
    }
</style>
{% endblock %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-12">
        <div class="card">
            <div class="card-header bg-purple text-white" style="background: linear-gradient(45deg, #6f42c1, #e83e8c);">
                <h2 class="card-title h4 mb-0">
                    <i class="bi bi-archive"></i> Tree Artifacts Explorer
                    <span class="artifact-badge">SAVED TREES</span>
                </h2>
                <small>View and edit saved hierarchical clustering trees from cluster analysis</small>
            </div>
            <div class="card-body">
                
                <!-- Artifact Selection -->
                <div class="artifact-selection-container">
                    <!-- Collapsed Title (visible when collapsed) -->
                    <div class="collapsed-title" id="collapsed-title">
                        <button class="btn btn-link p-0 text-decoration-none" type="button" data-bs-toggle="collapse" data-bs-target="#artifact-selection" aria-expanded="false" aria-controls="artifact-selection">
                            <small class="text-muted">
                                <i class="bi bi-chevron-right me-1"></i>
                                üìÇ Saved Artifacts
                            </small>
                        </button>
                    </div>
                    
                    <!-- Expanded Content (collapsed by default) -->
                    <div class="collapse" id="artifact-selection">
                        <div class="clustering-controls">
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <h4 class="text-purple mb-0" style="color: #6f42c1;">üìÇ Saved Artifacts</h4>
                                <button class="btn btn-link p-0 text-decoration-none" type="button" data-bs-toggle="collapse" data-bs-target="#artifact-selection" aria-expanded="true" aria-controls="artifact-selection">
                                    <i class="bi bi-chevron-up text-muted"></i>
                                </button>
                            </div>
                            <div class="row align-items-center">
                                <div class="col-md-6">
                                    <div class="mb-3">
                                        <label for="artifact-selector" class="form-label"><strong>Select Artifact:</strong></label>
                                        <select class="form-select form-select-lg" id="artifact-selector">
                                            <option value="">Loading artifacts...</option>
                                        </select>
                                        <div class="form-text">
                                            Choose a saved tree to view and edit
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="col-md-3">
                                    <div class="mb-3">
                                        <label class="form-label d-block">&nbsp;</label>
                                        <button id="load-artifact-btn" class="btn btn-purple btn-lg w-100" style="background: linear-gradient(45deg, #6f42c1, #e83e8c); border: none;" disabled>
                                            üìÇ Load Artifact
                                        </button>
                                    </div>
                                </div>
                                
                                <div class="col-md-3">
                                    <div class="mb-3">
                                        <label class="form-label d-block">&nbsp;</label>
                                        <button id="delete-artifact-btn" class="btn btn-outline-danger btn-lg w-100" disabled>
                                            <i class="bi bi-trash"></i> Delete
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Artifact Display -->
                <div id="artifact-section" style="display: none;">
                    <!-- Stats Section -->
                    <div id="artifact-stats" class="clustering-stats">
                        <!-- Stats will be populated here -->
                    </div>
                    
                    <!-- Hierarchical Tree Container -->
                    <div class="tree-container">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h5><i class="bi bi-diagram-2"></i> Hierarchical Tree (Editable)</h5>
                            <div>
                                <button id="expand-all-btn" class="btn btn-outline-secondary btn-sm me-2">
                                    <i class="bi bi-arrows-expand"></i> Expand All
                                </button>
                                <button id="collapse-all-btn" class="btn btn-outline-secondary btn-sm me-2">
                                    <i class="bi bi-arrows-collapse"></i> Collapse All
                                </button>
                                <button id="view-archived-btn" class="archive-btn me-2" title="View archived learning goals">
                                    <i class="bi bi-archive"></i> Archived
                                </button>
                                <button id="save-changes-btn" class="btn btn-success btn-sm">
                                    <i class="bi bi-save"></i> Save Changes
                                </button>
                            </div>
                        </div>
                        
                        <!-- Level Flattening Controls -->
                        <div id="level-controls" class="mb-3">
                            <div class="d-flex align-items-center gap-2 flex-wrap">
                                <span class="fw-bold text-muted">Flatten at Level:</span>
                                <div id="level-buttons" class="btn-group" role="group">
                                    <!-- Level buttons will be populated here -->
                                </div>
                                <button id="show-tree-btn" class="btn btn-outline-primary btn-sm ms-2" style="display: none;">
                                    <i class="bi bi-diagram-2"></i> Show Tree View
                                </button>
                            </div>
                        </div>
                        
                        <div id="tree-content">
                            <!-- Tree will be populated here -->
                        </div>
                        
                        <!-- Flattened Content (shown when level is selected) -->
                        <div id="flattened-content" style="display: none;">
                            <!-- Flattened view will be populated here -->
                        </div>
                    </div>
                </div>

                <!-- Loading Spinner -->
                <div id="loading-section" class="text-center" style="display: none; padding: 50px;">
                    <div class="spinner-border text-purple" role="status" style="width: 3rem; height: 3rem;">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <h5 class="mt-3">Loading artifact...</h5>
                    <p class="text-muted">Please wait while we load your tree data.</p>
                </div>

                <!-- No Artifacts -->
                <div id="no-artifacts" class="text-center" style="display: none;">
                    <i class="bi bi-archive" style="font-size: 3rem; color: #6c757d;"></i>
                    <h3 class="mt-3">No Artifacts Found</h3>
                    <p class="text-muted">Create some tree artifacts from the <a href="{{ url_for('main.cluster_tree') }}">Cluster Tree</a> page first.</p>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- AI Generation Modal -->
<div class="modal fade" id="aiGenerationModal" tabindex="-1" aria-labelledby="aiGenerationModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="aiGenerationModalLabel">
                    <i class="fa fa-wand-magic-sparkles text-purple"></i> AI Generate Representative Text
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <!-- Model Selection -->
                <div class="mb-3">
                    <label for="ai-model-select" class="form-label"><strong>AI Model:</strong></label>
                    <select class="form-select" id="ai-model-select">
                        <option value="gpt-4o">GPT-4o (Recommended)</option>
                        <option value="gpt-4o-mini">GPT-4o Mini (Faster)</option>
                        <option value="gpt-4o-2024-11-20">GPT-4.1 (Latest)</option>
                    </select>
                </div>
                
                <!-- Prompt Input -->
                <div class="mb-3">
                    <label for="ai-prompt" class="form-label"><strong>Prompt:</strong></label>
                    <textarea class="form-control" id="ai-prompt" rows="3" placeholder="Enter your prompt..."></textarea>
                    <div class="form-text">
                        This prompt will be sent along with all learning goals from the selected region.
                    </div>
                </div>
                
                <!-- Recursive Generation Option -->
                <div class="mb-3">
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="recursive-generation" onchange="updateRecursivePreview()">
                        <label class="form-check-label" for="recursive-generation">
                            <strong>Apply to all nested groups recursively</strong>
                        </label>
                    </div>
                    <div class="form-text">
                        When checked, generates representative text for every collapsible region nested under the selected one.
                    </div>
                    <div id="recursive-warning" class="alert alert-warning mt-2" style="display: none;">
                        <i class="fa fa-exclamation-triangle"></i> 
                        <strong>Warning:</strong> This will run <span id="recursive-count">0</span> AI generation queries.
                        This may take several minutes and consume significant AI credits.
                    </div>
                </div>
                
                <!-- Learning Goals Preview -->
                <div class="mb-3">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <label class="form-label mb-0"><strong>Learning Goals Context:</strong></label>
                        <button type="button" class="btn btn-sm btn-outline-secondary" id="toggle-goals-preview">
                            <i class="bi bi-chevron-down"></i> Show Goals
                        </button>
                    </div>
                    <div id="goals-preview" class="goal-preview" style="display: none;">
                        <!-- Goals will be populated here -->
                    </div>
                    <div class="form-text">
                        <span id="goals-count">0</span> learning goals will be included as context<span id="recursive-context-info"></span>.
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-purple" id="generate-ai-text" style="background: linear-gradient(45deg, #6f42c1, #e83e8c); border: none;">
                    <i class="fa fa-wand-magic-sparkles"></i> Generate
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Move Modal -->
<div class="modal fade move-modal" id="moveModal" tabindex="-1" aria-labelledby="moveModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="moveModalLabel">
                    <i class="bi bi-arrow-left-right text-info"></i> Move Learning Goal
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <!-- Move Description -->
                <div class="mb-3" id="move-description">
                    <!-- Description will be populated here -->
                </div>
                
                <!-- Search Box -->
                <div class="mb-3" id="existing-destinations-section">
                    <div class="d-flex align-items-center mb-2">
                        <strong>Move to existing group:</strong>
                    </div>
                    <input type="text" class="move-search-input" id="move-search" placeholder="Search destination groups by name..." autocomplete="off">
                    <div class="form-text">
                        Type to search group names. Click the <i class="bi bi-info-circle" style="font-size: 0.8em;"></i> icon next to any group to see its full path.
                    </div>
                </div>
                
                <!-- Destination Tree -->
                <div class="move-destination-tree" id="move-destination-tree">
                    <!-- Tree will be populated here -->
                </div>
                
                <!-- Create New Group Option (at bottom) -->
                <div class="mt-4 pt-3 border-top">
                    <div class="d-flex align-items-center justify-content-center gap-2">
                        <button type="button" class="btn btn-link btn-sm text-muted" id="create-new-group-btn" onclick="toggleCreateNewGroup()" style="text-decoration: none; font-size: 0.85em;">
                            <i class="bi bi-plus-circle-dotted"></i> Create new group instead
                        </button>
                        <button type="button" class="btn btn-link btn-sm text-muted p-0" onclick="showCreateGroupInfo()" title="Learn more about creating new groups">
                            <i class="bi bi-info-circle" style="font-size: 0.8em;"></i>
                        </button>
                    </div>
                </div>
                
                <!-- New Group Creation Panel (hidden by default) -->
                <div id="create-new-group-panel" style="display: none;">
                    <hr class="my-3">
                    <div class="alert alert-info">
                        <strong>Creating new group:</strong> "<em id="new-group-name-preview"></em>"<br>
                        <small>Navigate to the group that contains existing groups, then select where to add the new group:</small>
                    </div>
                    
                    <!-- Hierarchical Tree Selector -->
                    <div class="new-group-tree-selector mb-3" id="new-group-tree-selector">
                        <!-- Hierarchical tree will be populated here -->
                    </div>
                    
                    <div class="text-center mb-3">
                        <button type="button" class="btn btn-success btn-sm" id="create-and-move-btn" onclick="createNewGroupAndMove()" disabled>
                            <i class="bi bi-plus-circle"></i> Create Group & Move Goal
                        </button>
                        <button type="button" class="btn btn-outline-secondary btn-sm ms-2" onclick="toggleCreateNewGroup()">
                            Cancel
                        </button>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
            </div>
        </div>
    </div>
</div>

<!-- Archive Modal -->
<div class="modal fade" id="archiveModal" tabindex="-1" aria-labelledby="archiveModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="archiveModalLabel">
                    <i class="bi bi-archive text-secondary"></i> Archived Learning Goals
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <small class="text-muted">
                        These learning goals have been deleted but are preserved for reference. You can restore them if needed.
                    </small>
                </div>
                
                <div class="archived-goals-container" id="archived-goals-container">
                    <!-- Archived goals will be populated here -->
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Progress Overlay -->
<div id="operation-progress" class="operation-progress" style="display: none;">
    <div class="spinner-border text-primary" role="status">
        <span class="visually-hidden">Loading...</span>
    </div>
    <div class="operation-progress-text" id="progress-text">
        Processing...
    </div>
    <div class="operation-progress-details" id="progress-details">
        Please wait while we update the tree structure.
    </div>
</div>

{% endblock %}

{% block scripts %}
<script>
// Global variables
let currentArtifact = null;
let currentArtifactId = null;
let availableArtifacts = [];
let flattenedAtLevel = null;
let currentAINodeId = null;

// Move/Delete variables
let currentMoveNodeId = null;
let currentMoveType = null; // 'node' or 'goal'
let currentMoveGoalIndex = null;
let searchTimeout = null;

// New group creation variables
let selectedNewGroupLocation = null;
let currentNewGroupName = null;

// Fix for total goals display issue - detects and corrects extra trailing zeros
function fixTotalGoals(totalGoalsValue, treeStructure = null) {
    let fixed = 0;
    
    // Convert to string first to handle both string and number inputs
    let totalStr = String(totalGoalsValue || '0');
    
    // Remove any non-digit characters
    totalStr = totalStr.replace(/\D/g, '');
    
    if (totalStr === '') return 0;
    
    // Parse as integer
    let total = parseInt(totalStr);
    
    // If we have tree structure, count the actual goals to validate
    if (treeStructure && Array.isArray(treeStructure)) {
        const actualCount = countTotalGoalsInTree(treeStructure);
        
        // If the parsed total ends with 0 and removing it gives us the actual count
        if (totalStr.endsWith('0')) {
            const withoutLastZero = parseInt(totalStr.slice(0, -1));
            if (withoutLastZero === actualCount) {
                console.log(`üîß Fixed total goals: ${total} ‚Üí ${withoutLastZero} (matched actual count)`);
                return withoutLastZero;
            }
        }
        
        // If the actual count matches exactly, use it
        if (total !== actualCount && actualCount > 0) {
            console.log(`üîß Using actual goal count: ${total} ‚Üí ${actualCount}`);
            return actualCount;
        }
    }
    
    // Fallback pattern detection: if number ends with 0 and is suspiciously round
    if (totalStr.endsWith('0') && total > 100) {
        const withoutLastZero = parseInt(totalStr.slice(0, -1));
        // Check if removing the last zero gives a more reasonable number
        // (This is a heuristic for the specific "6485" -> "64850" issue)
        if (withoutLastZero > 0 && withoutLastZero < total * 0.5) {
            console.log(`üîß Detected extra trailing zero: ${total} ‚Üí ${withoutLastZero}`);
            return withoutLastZero;
        }
    }
    
    return total;
}

// Helper function to count actual goals in tree structure
function countTotalGoalsInTree(nodes) {
    let count = 0;
    
    function countInNode(node) {
        if (node.goals && Array.isArray(node.goals)) {
            count += node.goals.length;
        }
        if (node.children && node.children.length > 0) {
            node.children.forEach(child => countInNode(child));
        }
    }
    
    if (Array.isArray(nodes)) {
        nodes.forEach(node => countInNode(node));
    }
    
    return count;
}

$(document).ready(function() {
    // Load available artifacts on page load
    loadAvailableArtifacts();
    
    // Handle collapse/expand of artifact selection
    $('#artifact-selection').on('show.bs.collapse', function() {
        $('#collapsed-title').addClass('hidden');
    });
    
    $('#artifact-selection').on('hide.bs.collapse', function() {
        $('#collapsed-title').removeClass('hidden');
    });
    
    // Artifact selector change handler
    $('#artifact-selector').change(function() {
        const selectedId = $(this).val();
        $('#load-artifact-btn').prop('disabled', !selectedId);
        $('#delete-artifact-btn').prop('disabled', !selectedId);
    });
    
    // Load artifact button handler
    $('#load-artifact-btn').click(function() {
        const selectedId = $('#artifact-selector').val();
        if (selectedId) {
            loadArtifact(selectedId);
        }
    });
    
    // Delete artifact button handler
    $('#delete-artifact-btn').click(function() {
        const selectedId = $('#artifact-selector').val();
        if (selectedId && confirm('Are you sure you want to delete this artifact? This action cannot be undone.')) {
            deleteArtifact(selectedId);
        }
    });
    
    // Tree control buttons
    $('#expand-all-btn').click(expandAll);
    $('#collapse-all-btn').click(collapseAll);
    $('#save-changes-btn').click(saveChanges);
    $('#show-tree-btn').click(showTreeView);
    
    // AI Generation Modal handlers
    $('#toggle-goals-preview').click(function() {
        const preview = $('#goals-preview');
        const btn = $(this);
        const icon = btn.find('i');
        
        if (preview.is(':visible')) {
            preview.slideUp();
            icon.removeClass('bi-chevron-up').addClass('bi-chevron-down');
            btn.html('<i class="bi bi-chevron-down"></i> Show Goals');
        } else {
            preview.slideDown();
            icon.removeClass('bi-chevron-down').addClass('bi-chevron-up');
            btn.html('<i class="bi bi-chevron-up"></i> Hide Goals');
        }
    });
    
    $('#generate-ai-text').click(function() {
        generateAIText();
    });
    
    // Move/Delete/Archive handlers
    $('#view-archived-btn').click(function() {
        loadArchivedGoals();
    });
    
    // Move modal search functionality with debouncing
    $('#move-search').on('input', function() {
        const searchTerm = $(this).val();
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
            filterMoveDestinations(searchTerm);
        }, 300); // 300ms debounce
    });
    
    // Hide tooltips when clicking elsewhere
    $(document).on('click', function() {
        $('.path-tooltip').fadeOut(200, function() {
            $(this).remove();
        });
    });
});

function loadAvailableArtifacts() {
    // Show loading spinner
    $('#loading-section').show();
    $('#artifact-section').hide();
    $('#no-artifacts').hide();
    
    $.get('/api/get-artifacts')
        .done(function(response) {
            if (response.success && response.artifacts.length > 0) {
                availableArtifacts = response.artifacts;
                
                // Populate artifact selector
                let optionsHtml = '<option value="">Select an artifact...</option>';
                response.artifacts.forEach(artifact => {
                    const date = new Date(artifact.created_at).toLocaleDateString();
                    const fixedGoals = fixTotalGoals(artifact.total_goals);
                    optionsHtml += `<option value="${artifact.id}">${artifact.name} (${fixedGoals} goals, ${date})</option>`;
                });
                
                $('#artifact-selector').html(optionsHtml);
                
                // Auto-load the first artifact
                const firstArtifactId = response.artifacts[0].id;
                $('#artifact-selector').val(firstArtifactId);
                $('#load-artifact-btn').prop('disabled', false);
                $('#delete-artifact-btn').prop('disabled', false);
                
                // Load the first artifact automatically
                loadArtifact(firstArtifactId);
                
            } else {
                $('#loading-section').hide();
                $('#artifact-selector').html('<option value="">No artifacts found</option>');
                $('#no-artifacts').show();
            }
        })
        .fail(function() {
            $('#loading-section').hide();
            $('#artifact-selector').html('<option value="">Error loading artifacts</option>');
            $('#no-artifacts').show();
        });
}

function loadArtifact(artifactId) {
    currentArtifactId = artifactId;
    
    $.get(`/api/get-artifact/${artifactId}`)
        .done(function(response) {
            if (response.success) {
                currentArtifact = response.artifact;
                $('#loading-section').hide();
                displayArtifact(currentArtifact);
            } else {
                $('#loading-section').hide();
                alert('Failed to load artifact: ' + response.message);
            }
        })
        .fail(function() {
            $('#loading-section').hide();
            alert('Failed to load artifact: Network error');
        });
}

function displayArtifact(artifact) {
    $('#no-artifacts').hide();
    $('#artifact-section').show();
    
    // Display stats
    displayStats(artifact);
    
    // Display tree using the updated functions
    displayTree(artifact.tree_structure);
    
    console.log('Artifact loaded:', artifact.name);
}

function displayStats(artifact) {
    // Use the new fixTotalGoals function to handle the extra "0" issue
    const totalGoals = fixTotalGoals(artifact.total_goals, artifact.tree_structure);
    
    console.log('üîç DEBUG - Original artifact.total_goals:', artifact.total_goals, typeof artifact.total_goals);
    console.log('üîç DEBUG - Fixed totalGoals:', totalGoals);
    
    const statsHtml = `
        <h5><i class="bi bi-archive"></i> Artifact: ${artifact.name}</h5>
        <div class="row mb-2">
            <div class="col-md-3">
                <strong>Total Goals:</strong> ${totalGoals}
            </div>
            <div class="col-md-3">
                <strong>Parameters:</strong> ${artifact.parameter_summary}
            </div>
            <div class="col-md-3">
                <strong>Created:</strong> ${new Date(artifact.created_at).toLocaleDateString()}
            </div>
            <div class="col-md-3">
                <strong>Modified:</strong> ${new Date(artifact.modified_at).toLocaleDateString()}
            </div>
        </div>
    `;
    $('#artifact-stats').html(statsHtml);
}

function displayTree(treeStructure) {
    // Generate level buttons
    generateLevelButtons(treeStructure);
    
    // Build tree HTML with new layout
    const treeHtml = treeStructure.map(node => buildTreeNode(node, 0)).join('');
    $('#tree-content').html(treeHtml);
    
    // Show tree view
    $('#tree-content').show();
    $('#flattened-content').hide();
    $('#show-tree-btn').hide();
}

function generateLevelButtons(nodes) {
    const maxDepth = findMaxDepth(nodes);
    let buttonsHtml = '';
    
    for (let level = 0; level <= maxDepth; level++) {
        const levelLabel = String.fromCharCode(65 + level); // A, B, C, etc.
        const groupCount = countGroupsAtLevel(nodes, level);
        const totalGoals = countGoalsAtLevel(nodes, level);
        const avgGoalsPerGroup = groupCount > 0 ? Math.round(totalGoals / groupCount) : 0;
        
        buttonsHtml += `
            <button class="btn btn-outline-secondary level-button" data-level="${level}">
                <strong>${levelLabel}</strong>
                <small>${groupCount} groups</small>
                <small style="font-size: 0.65em; opacity: 0.8;">${avgGoalsPerGroup} avg goals</small>
            </button>
        `;
    }
    
    $('#level-buttons').html(buttonsHtml);
    
    // Add click handlers
    $('.level-button').click(function() {
        const level = parseInt($(this).data('level'));
        flattenAtLevel(level);
    });
}

function countGroupsAtLevel(nodes, targetLevel, currentLevel = 0) {
    let count = 0;
    nodes.forEach(node => {
        if (currentLevel === targetLevel) {
            count += 1; // Count this group
        } else if (node.children && node.children.length > 0 && currentLevel < targetLevel) {
            count += countGroupsAtLevel(node.children, targetLevel, currentLevel + 1);
        }
    });
    return count;
}

function findMaxDepth(nodes, currentDepth = 0) {
    let maxDepth = currentDepth;
    nodes.forEach(node => {
        if (node.children && node.children.length > 0) {
            maxDepth = Math.max(maxDepth, findMaxDepth(node.children, currentDepth + 1));
        }
    });
    return maxDepth;
}

function countGoalsAtLevel(nodes, targetLevel, currentLevel = 0) {
    let count = 0;
    nodes.forEach(node => {
        if (currentLevel === targetLevel) {
            count += countAllGoalsInSubtree(node);
        } else if (node.children && node.children.length > 0 && currentLevel < targetLevel) {
            count += countGoalsAtLevel(node.children, targetLevel, currentLevel + 1);
        }
    });
    return count;
}

function countAllGoalsInSubtree(node) {
    let count = (node.goals || []).length;
    if (node.children) {
        node.children.forEach(child => {
            count += countAllGoalsInSubtree(child);
        });
    }
    return count;
}

function buildTreeNode(node, level = 0) {
    const levelClass = level <= 10 ? `tree-level-${level}` : 'tree-level-deep';
    const hasChildren = node.children && node.children.length > 0;
    const hasGoals = node.goals && node.goals.length > 0;
    
    // Get representative text and determine state
    let representativeText = node.representative_goal || '';
    let textState = node.text_state || 'default';
    let aiPrompt = node.ai_prompt || '';
    
    // Get appropriate icon based on state
    let stateIcon = 'fa-quote-left'; // default
    if (textState === 'manual') {
        stateIcon = 'fa-pencil';
    } else if (textState === 'ai') {
        stateIcon = 'fa-wand-magic-sparkles';
    }
    
    // If no representative text, create one from goals
    if (!representativeText && hasGoals) {
        representativeText = node.goals.reduce((longest, current) => 
            current.length > longest.length ? current : longest
        );
    } else if (!representativeText && hasChildren) {
        representativeText = findRepresentativeGoal(node);
    }
    
    let nodeHtml = `<div class="tree-node ${levelClass}" data-level="${level}" data-node-id="${node.id}">`;
    
    // Check if this node represents no subdivision
    const isNoSubdivision = hasChildren && node.children.length === 1 && 
                           node.children[0].size === node.size;
    const subdivisionClass = isNoSubdivision ? ' no-subdivision' : '';
    
    // NEW LAYOUT: [Large Black Text][Icon][Auto-Gen Button][Small Gray Label][Size]
    nodeHtml += `
        <div class="cluster-header${subdivisionClass}" onclick="toggleCluster('${node.id}')">
            ${hasChildren ? '<i class="bi bi-chevron-right collapse-icon"></i>' : '<i class="bi bi-circle-fill collapse-icon" style="font-size: 0.5em;"></i>'}
            
            <div class="cluster-representative" 
                 contenteditable="true"
                 data-state="${textState}"
                 onclick="event.stopPropagation(); startEditing(this)"
                 onblur="saveRepresentativeText(this, '${node.id}')"
                 onkeydown="handleRepresentativeKeydown(event, this, '${node.id}')">
                <i class="fa ${stateIcon} text-state-icon"></i>
                <span class="representative-text">${representativeText}</span>
            </div>
            
            <button class="auto-generate-btn" onclick="event.stopPropagation(); openAIGenerationModal('${node.id}')" title="Generate with AI">
                <i class="fa fa-wand-magic-sparkles"></i>
            </button>
            
            <span class="cluster-label">${node.label}</span>
            <span class="cluster-size">${node.size || 0}</span>
        </div>
    `;
    
    // Cluster content (goals for leaf nodes, children for branch nodes)
    if ((hasGoals || hasChildren) && (hasGoals || node.size > 0)) {
        nodeHtml += `<div class="cluster-content" id="content-${node.id}" style="display: none;">`;
        
        if (hasGoals) {
            node.goals.forEach(function(goal, index) {
                const source = node.sources ? node.sources[index] : {};
                nodeHtml += `
                    <div class="goal-item" data-goal-index="${index}">
                        <div class="d-flex justify-content-between align-items-start">
                            <div class="flex-grow-1">
                                <div class="goal-text">"${goal}"</div>
                                                        <div class="goal-source">
                            üìÑ ${truncateText(source.document_name || 'Unknown', 25)} | 
                            üë§ ${truncateText(source.creator || 'Unknown', 15)}
                            ${source.course_name ? ` | üìö ${truncateText(source.course_name, 20)}` : ''}
                            ${source.institution ? ` | üèõÔ∏è ${truncateText(source.institution, 20)}` : ''}
                        </div>
                            </div>
                            <div class="goal-actions">
                                <button class="goal-move-btn" onclick="openMoveModal('${node.id}', 'goal', ${index})" title="Move this learning goal">
                                    ‚Üî
                                </button>
                                <button class="goal-delete-btn" onclick="deleteGoal('${node.id}', ${index})" title="Delete this learning goal">
                                    üóë
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            });
        }
        
        if (hasChildren) {
            node.children.forEach(child => {
                nodeHtml += buildTreeNode(child, level + 1);
            });
        }
        
        nodeHtml += `</div>`;
    }
    
    nodeHtml += `</div>`;
    return nodeHtml;
}

function findRepresentativeGoal(node) {
    // Recursively find a representative goal from children
    if (node.goals && node.goals.length > 0) {
        return node.goals.reduce((longest, current) => 
            current.length > longest.length ? current : longest
        );
    }
    
    if (node.children) {
        for (let child of node.children) {
            const childRep = findRepresentativeGoal(child);
            if (childRep) return childRep;
        }
    }
    
    return '';
}

function truncateText(text, maxLength) {
    if (!text) return '';
    return text.length <= maxLength ? text : text.substring(0, maxLength - 3) + '...';
}

function startEditing(element) {
    $(element).addClass('editing');
    // Don't interfere with the browser's natural cursor placement
    // The contenteditable element will handle cursor positioning automatically
}

function editRepresentativeText(element) {
    $(element).addClass('editing');
    
    // Don't auto-select all text - let the user click where they want to edit
    // Just ensure the element is focused
    element.focus();
    
    // If the user wants to select all, they can use Ctrl+A
    // For now, just place the cursor at the end if no selection is made
    setTimeout(() => {
        if (window.getSelection().toString() === '') {
            // No text is selected, place cursor at click position
            // The browser will naturally handle this when we don't interfere
        }
    }, 10);
}

function saveRepresentativeText(element, nodeId) {
    $(element).removeClass('editing');
    const textSpan = $(element).find('.representative-text');
    const newText = textSpan.text().trim();
    
    if (!newText) {
        alert('Representative text cannot be empty');
        return;
    }
    
    // Update the state to manual and change icon
    const icon = $(element).find('.text-state-icon');
    icon.removeClass('fa-quote-left fa-wand-magic-sparkles').addClass('fa-pencil');
    
    // Set data-state attribute to manual
    $(element).attr('data-state', 'manual');
    
    // Mark as changed for saving later
    element.setAttribute('data-changed', 'true');
    element.style.backgroundColor = '#fff3cd'; // Light yellow to indicate unsaved changes
}

function handleRepresentativeKeydown(event, element, nodeId) {
    if (event.key === 'Enter') {
        event.preventDefault();
        element.blur();
    } else if (event.key === 'Escape') {
        // Restore original text (would need to be stored)
        element.blur();
    }
}

function openAIGenerationModal(nodeId) {
    currentAINodeId = nodeId;
    
    // Find the node in the current artifact
    const node = findNodeById(currentArtifact.tree_structure, nodeId);
    if (!node) {
        alert('Node not found');
        return;
    }
    
    // Set default prompt or use saved prompt
    const defaultPrompt = "Please provide a brief overarching learning goal (or skill) that encapsulates, specifically all of the learning goals or skills in the list below.";
    const savedPrompt = node.ai_prompt || defaultPrompt;
    $('#ai-prompt').val(savedPrompt);
    
    // Reset recursive checkbox
    $('#recursive-generation').prop('checked', false);
    
    // Collect all goals from this region
    const allGoals = collectAllGoalsFromNode(node);
    
    // Populate goals preview
    let goalsHtml = '';
    allGoals.forEach((goalData, index) => {
        goalsHtml += `
            <div class="goal-preview-item">
                <div class="goal-preview-text">"${goalData.goal}"</div>
                <div class="goal-preview-source">
                    üìÑ ${goalData.source.document_name || 'Unknown'} | 
                    üë§ ${goalData.source.creator || 'Unknown'}
                    ${goalData.source.course_name ? ` | üìö ${goalData.source.course_name}` : ''}
                </div>
            </div>
        `;
    });
    
    $('#goals-preview').html(goalsHtml);
    $('#goals-count').text(allGoals.length);
    
    // Update recursive preview
    updateRecursivePreview();
    
    // Show the modal
    $('#aiGenerationModal').modal('show');
}

function findNodeById(nodes, targetId) {
    for (let node of nodes) {
        if (node.id === targetId) {
            return node;
        }
        if (node.children) {
            const found = findNodeById(node.children, targetId);
            if (found) return found;
        }
    }
    return null;
}

function collectAllGoalsFromNode(node) {
    let allGoals = [];
    
    // Add goals from this node
    if (node.goals) {
        node.goals.forEach((goal, index) => {
            const source = node.sources ? node.sources[index] : {};
            allGoals.push({
                goal: goal,
                source: source
            });
        });
    }
    
    // Add goals from children recursively
    if (node.children) {
        node.children.forEach(child => {
            allGoals = allGoals.concat(collectAllGoalsFromNode(child));
        });
    }
    
    return allGoals;
}

function generateAIText() {
    const model = $('#ai-model-select').val();
    const prompt = $('#ai-prompt').val().trim();
    const isRecursive = $('#recursive-generation').is(':checked');
    
    if (!prompt) {
        alert('Please enter a prompt');
        return;
    }
    
    if (!currentAINodeId) {
        alert('No node selected');
        return;
    }
    
    // Find the node
    const node = findNodeById(currentArtifact.tree_structure, currentAINodeId);
    if (!node) {
        alert('Node not found');
        return;
    }
    
    if (isRecursive) {
        // Get user confirmation for recursive generation
        const recursiveNodes = collectRecursiveNodes(node);
        const confirmMessage = `This will generate AI text for ${recursiveNodes.length} groups. This may take several minutes and consume significant AI credits. Continue?`;
        
        if (!confirm(confirmMessage)) {
            return;
        }
        
        generateRecursiveAIText(recursiveNodes, model, prompt);
    } else {
        generateSingleAIText(node, model, prompt);
    }
}

function generateSingleAIText(node, model, prompt) {
    const generateBtn = $('#generate-ai-text');
    generateBtn.prop('disabled', true).html('<i class="fa fa-spinner fa-spin"></i> Generating...');
    
    // Collect goals for this node only
    const allGoals = collectAllGoalsFromNode(node);
    const goalsList = allGoals.map(g => `"${g.goal}"`).join('\n');
    const fullPrompt = `${prompt}\n\nLearning goals:\n${goalsList}`;
    
    // Send to API
    $.ajax({
        url: '/api/generate-representative-text',
        method: 'POST',
        contentType: 'application/json',
        data: JSON.stringify({
            artifact_id: currentArtifactId,
            node_id: currentAINodeId,
            prompt: prompt,
            full_prompt: fullPrompt,
            model: model
        })
    })
    .done(function(response) {
        if (response.success) {
            // Update the in-memory artifact data with the saved prompt and generated text
            const node = findNodeById(currentArtifact.tree_structure, currentAINodeId);
            if (node) {
                node.ai_prompt = prompt;
                node.representative_goal = response.generated_text;
                node.text_state = 'ai';
            }
            
            updateNodeUI(currentAINodeId, response.generated_text, 'ai');
            $('#aiGenerationModal').modal('hide');
        } else {
            alert('Failed to generate text: ' + response.message);
        }
    })
    .fail(function() {
        alert('Failed to generate text: Network error');
    })
    .always(function() {
        generateBtn.prop('disabled', false).html('<i class="fa fa-wand-magic-sparkles"></i> Generate');
    });
}

function generateRecursiveAIText(recursiveNodes, model, prompt) {
    const generateBtn = $('#generate-ai-text');
    generateBtn.prop('disabled', true);
    
    let completed = 0;
    let successful = 0;
    let errors = 0;
    const total = recursiveNodes.length;
    
    // Collect all results in memory - NO database saves during generation
    const generatedResults = [];
    const failedNodes = [];
    
    // Add progress indicator to the modal title
    const modalTitle = $('#aiGenerationModalLabel');
    const originalTitle = modalTitle.html();
    
    // Process each node
    recursiveNodes.forEach((nodeData, index) => {
        const goalsList = nodeData.goals.map(g => `"${g.goal}"`).join('\n');
        const fullPrompt = `${prompt}\n\nLearning goals:\n${goalsList}`;
        
        // Update progress in button and modal title
        const progressText = `Generating ${index + 1}/${total}`;
        generateBtn.html(`<i class="fa fa-spinner fa-spin"></i> ${progressText}...`);
        modalTitle.html(`<i class="fa fa-wand-magic-sparkles text-purple"></i> AI Generate - ${progressText}`);
        
        // Small delay between requests to avoid overwhelming the API
        setTimeout(() => {
            $.ajax({
                url: '/api/generate-representative-text',
                method: 'POST',
                contentType: 'application/json',
                data: JSON.stringify({
                    artifact_id: currentArtifactId,
                    node_id: nodeData.id,
                    prompt: prompt,
                    full_prompt: fullPrompt,
                    model: model,
                    skip_save: true  // NEW: Skip individual saves during batch operations
                })
            })
            .done(function(response) {
                if (response.success) {
                    // Store result in memory and update UI immediately
                    generatedResults.push({
                        node_id: nodeData.id,
                        representative_text: response.generated_text,
                        text_state: 'ai',
                        ai_prompt: prompt  // Store the prompt for batch saving
                    });
                    
                    // Update UI immediately for visual feedback
                    updateNodeUI(nodeData.id, response.generated_text, 'ai');
                    successful++;
                } else {
                    failedNodes.push({
                        node_id: nodeData.id,
                        error: response.message
                    });
                    errors++;
                    console.error(`Failed to generate for node ${nodeData.id}:`, response.message);
                }
            })
            .fail(function() {
                failedNodes.push({
                    node_id: nodeData.id,
                    error: 'Network error'
                });
                errors++;
                console.error(`Network error for node ${nodeData.id}`);
            })
            .always(function() {
                completed++;
                
                // Update progress with completion status
                const completedText = `Completed ${completed}/${total} (${successful} successful, ${errors} failed)`;
                generateBtn.html(`<i class="fa fa-spinner fa-spin"></i> ${completedText}`);
                modalTitle.html(`<i class="fa fa-wand-magic-sparkles text-purple"></i> AI Generate - ${completedText}`);
                
                if (completed === total) {
                    // All generations complete - now save everything in one batch
                    if (generatedResults.length > 0) {
                        batchSaveAIResults(generatedResults, originalTitle, modalTitle, generateBtn, successful, errors, total);
                    } else {
                        // No successful results to save
                        setTimeout(() => {
                            modalTitle.html(originalTitle);
                            generateBtn.prop('disabled', false).html('<i class="fa fa-wand-magic-sparkles"></i> Generate');
                            alert(`‚ùå All generations failed. No changes to save.`);
                        }, 1000);
                    }
                }
            });
        }, index * 500); // 500ms delay between requests
    });
}

function batchSaveAIResults(generatedResults, originalTitle, modalTitle, generateBtn, successful, errors, total) {
    // For recursive generation, individual saves were skipped, so we need to save everything now
    // including the prompts that were used for generation
    
    // Show finalizing progress
    const finalizingText = `Saving ${generatedResults.length} changes...`;
    generateBtn.html(`<i class="fa fa-spinner fa-spin"></i> ${finalizingText}`);
    modalTitle.html(`<i class="fa fa-check-circle text-purple"></i> AI Generate - ${finalizingText}`);
    
    // Prepare updates for batch save (including prompts)
    const updates = generatedResults.map(result => ({
        node_id: result.node_id,
        representative_text: result.representative_text,
        text_state: result.text_state,
        ai_prompt: result.ai_prompt  // Include the prompt that was used
    }));
    
    // Send batch update to save everything including prompts
    $.ajax({
        url: '/api/batch-update-artifact-representative-texts',
        method: 'POST',
        contentType: 'application/json',
        data: JSON.stringify({
            artifact_id: currentArtifactId,
            updates: updates
        })
    })
    .done(function(response) {
        if (response.success) {
            // Update the in-memory artifact data with the saved prompts
            generatedResults.forEach(result => {
                const node = findNodeById(currentArtifact.tree_structure, result.node_id);
                if (node) {
                    node.ai_prompt = result.ai_prompt;
                    node.representative_goal = result.representative_text;
                    node.text_state = result.text_state;
                }
            });
            
            // Clear all change indicators after successful save
            generatedResults.forEach(result => {
                const nodeElements = $(`[data-changed="true"]`).filter(function() {
                    // Check if this element itself has data-node-id (flattened view)
                    // or find it in the closest parent (tree view)
                    let nodeId = $(this).data('node-id');
                    if (!nodeId) {
                        nodeId = $(this).closest('[data-node-id]').data('node-id');
                    }
                    return nodeId === result.node_id;
                });
                nodeElements.each(function() {
                    $(this).removeAttr('data-changed');
                    $(this).css('backgroundColor', '');
                });
            });
            
            // Show final success
            generateBtn.html(`<i class="fa fa-check text-success"></i> All saved successfully!`);
            modalTitle.html(`<i class="fa fa-check text-success"></i> Generation Complete!`);
            
            setTimeout(() => {
                modalTitle.html(originalTitle);
                generateBtn.prop('disabled', false).html('<i class="fa fa-wand-magic-sparkles"></i> Generate');
                $('#aiGenerationModal').modal('hide');
                
                if (errors === 0) {
                    alert(`üéâ Successfully generated and saved text for all ${total} groups!\n\nüíæ All results including prompts were saved.`);
                } else {
                    alert(`üìä Generation completed!\n‚úÖ Generated & Saved: ${successful}\n‚ùå Failed: ${errors}\nüìù Total: ${total}\n\nüíæ All successful results including prompts were saved.`);
                }
            }, 1500);
        } else {
            // Save failed
            generateBtn.html(`<i class="fa fa-exclamation-triangle text-warning"></i> Save Failed`);
            modalTitle.html(`<i class="fa fa-exclamation-triangle text-warning"></i> Save Failed`);
            alert('Generated text successfully but failed to save to database: ' + response.message);
            
            setTimeout(() => {
                modalTitle.html(originalTitle);
                generateBtn.prop('disabled', false).html('<i class="fa fa-wand-magic-sparkles"></i> Generate');
            }, 3000);
        }
    })
    .fail(function() {
        // Network error
        generateBtn.html(`<i class="fa fa-times text-danger"></i> Network Error`);
        modalTitle.html(`<i class="fa fa-times text-danger"></i> Network Error`);
        alert('Generated text successfully but failed to save: Network error');
        
        setTimeout(() => {
            modalTitle.html(originalTitle);
            generateBtn.prop('disabled', false).html('<i class="fa fa-wand-magic-sparkles"></i> Generate');
        }, 3000);
    });
}

function updateNodeUI(nodeId, generatedText, state) {
    let nodeElement, textSpan, icon;
    
    if ($('#flattened-content').is(':visible')) {
        // Flattened view is active - find the representative element by node ID
        // We need to find which flattened cluster contains this node ID
        nodeElement = $(`#flattened-content .cluster-representative`).filter(function() {
            // Check if the onblur attribute contains this nodeId
            const onblurAttr = $(this).attr('onblur');
            return onblurAttr && onblurAttr.includes(`'${nodeId}'`);
        });
    } else {
        // Tree view is active - use the existing selector
        nodeElement = $(`.tree-node[data-node-id="${nodeId}"] > .cluster-header > .cluster-representative`);
    }
    
    if (nodeElement.length === 0) {
        console.error(`Could not find node element for ID: ${nodeId}`);
        return;
    }
    
    textSpan = nodeElement.find('.representative-text');
    icon = nodeElement.find('.text-state-icon');
    
    textSpan.text(generatedText);
    icon.removeClass('fa-quote-left fa-pencil').addClass('fa-wand-magic-sparkles');
    
    // Set data-state attribute
    nodeElement.attr('data-state', state);
    
    // Mark as changed for saving
    nodeElement[0].setAttribute('data-changed', 'true');
    nodeElement[0].style.backgroundColor = '#e1f5fe'; // Light blue for AI
}

function collectRecursiveNodes(rootNode) {
    const nodes = [];
    
    function collectNode(node) {
        // Add this node if it has goals or children (any collapsible region)
        const hasChildren = node.children && node.children.length > 0;
        const hasGoals = node.goals && node.goals.length > 0;
        
        if (hasChildren || hasGoals) {
            const allGoals = collectAllGoalsFromNode(node);
            // Only include groups with more than 1 goal (no point generating for single goals)
            if (allGoals.length > 1) {
                nodes.push({
                    id: node.id,
                    label: node.label,
                    goals: allGoals
                });
            }
        }
        
        // Recursively collect from children
        if (hasChildren) {
            node.children.forEach(child => {
                collectNode(child);
            });
        }
    }
    
    collectNode(rootNode);
    return nodes;
}

function updateRecursivePreview() {
    const isRecursive = $('#recursive-generation').is(':checked');
    const warning = $('#recursive-warning');
    const recursiveInfo = $('#recursive-context-info');
    
    if (isRecursive && currentAINodeId) {
        const node = findNodeById(currentArtifact.tree_structure, currentAINodeId);
        if (node) {
            const recursiveNodes = collectRecursiveNodes(node);
            $('#recursive-count').text(recursiveNodes.length);
            warning.show();
            
            // Update context info
            if (recursiveNodes.length > 1) {
                recursiveInfo.text(` (${recursiveNodes.length} total queries)`);
            } else {
                recursiveInfo.text('');
            }
        }
    } else {
        warning.hide();
        recursiveInfo.text('');
    }
}

function flattenAtLevel(level) {
    flattenedAtLevel = level;
    
    // Update button states
    $('.level-button').removeClass('active');
    $(`.level-button[data-level="${level}"]`).addClass('active');
    
    // Generate flattened view
    const flattened = flattenTreeAtLevel(currentArtifact.tree_structure, level);
    displayFlattenedView(flattened, level);
    
    // Show flattened content, hide tree
    $('#tree-content').hide();
    $('#flattened-content').show();
    $('#show-tree-btn').show();
}

function flattenTreeAtLevel(nodes, targetLevel, currentLevel = 0) {
    let flattened = [];
    
    nodes.forEach(node => {
        if (currentLevel === targetLevel) {
            // Collect all goals from this node and its children, preserving source node info
            const allGoalsWithSource = collectAllGoalsWithSourceFromNode(node);
            if (allGoalsWithSource.length > 0) {
                flattened.push({
                    label: node.label,
                    representative: node.representative_goal || '',
                    goalsWithSource: allGoalsWithSource,
                    size: allGoalsWithSource.length,
                    originalNode: node
                });
            }
        } else if (node.children && node.children.length > 0 && currentLevel < targetLevel) {
            flattened = flattened.concat(flattenTreeAtLevel(node.children, targetLevel, currentLevel + 1));
        }
    });
    
    return flattened;
}

function collectAllGoalsWithSourceFromNode(node) {
    // Collect all goals from this node and its children, preserving which node each goal came from
    let allGoals = [];
    
    // Add goals from this node
    if (node.goals) {
        node.goals.forEach((goal, index) => {
            const source = node.sources ? node.sources[index] : {};
            allGoals.push({
                goal: goal,
                source: source,
                sourceNodeId: node.id,
                originalIndex: index
            });
        });
    }
    
    // Add goals from children recursively
    if (node.children) {
        node.children.forEach(child => {
            allGoals = allGoals.concat(collectAllGoalsWithSourceFromNode(child));
        });
    }
    
    return allGoals;
}

function displayFlattenedView(flattened, level) {
    const levelLabel = String.fromCharCode(65 + level);
    const totalGoals = flattened.reduce((sum, cluster) => sum + cluster.size, 0);
    
    let flattenedHtml = `
        <div class="mb-3 d-flex justify-content-between align-items-center">
            <div>
                <h5><i class="bi bi-list-ul"></i> Flattened View - Level ${levelLabel}</h5>
                <small class="text-muted">${flattened.length} clusters, ${totalGoals} total goals</small>
            </div>
            <div class="d-flex align-items-center gap-2">
                <select id="download-column-type" class="form-select form-select-sm" style="width: auto;">
                    <option value="institution">by Institution</option>
                    <option value="creator">by Creator</option>
                    <option value="course_name">by Course</option>
                </select>
                <button id="download-csv-btn" class="btn btn-primary btn-sm" onclick="downloadFlattenedCSV('${levelLabel}')">
                    <i class="bi bi-download"></i> Download CSV
                </button>
            </div>
        </div>
    `;
    
    flattened.forEach((cluster, index) => {
        // Get the original node's state information
        const originalNode = cluster.originalNode;
        const representativeText = originalNode.representative_goal || '';
        const textState = originalNode.text_state || 'default';
        
        // Get appropriate icon based on state
        let stateIcon = 'fa-quote-left'; // default
        if (textState === 'manual') {
            stateIcon = 'fa-pencil';
        } else if (textState === 'ai') {
            stateIcon = 'fa-wand-magic-sparkles';
        }
        
        flattenedHtml += `
            <div class="flattened-cluster">
                <div class="cluster-header" onclick="toggleFlattenedCluster('flattened-${index}')">
                    <i class="bi bi-chevron-right collapse-icon"></i>
                    
                    <div class="cluster-representative" 
                         contenteditable="true"
                         data-state="${textState}"
                         data-node-id="${originalNode.id}"
                         onclick="event.stopPropagation(); startEditing(this)"
                         onblur="saveRepresentativeText(this, '${originalNode.id}')"
                         onkeydown="handleRepresentativeKeydown(event, this, '${originalNode.id}')">
                        <i class="fa ${stateIcon} text-state-icon"></i>
                        <span class="representative-text">${representativeText}</span>
                    </div>
                    
                    <button class="auto-generate-btn" onclick="event.stopPropagation(); openAIGenerationModal('${originalNode.id}')" title="Generate with AI">
                        <i class="fa fa-wand-magic-sparkles"></i>
                    </button>
                    
                    <span class="cluster-label">${cluster.label}</span>
                    <span class="cluster-size">${cluster.size}</span>
                </div>
                <div class="cluster-content" id="flattened-content-${index}" style="display: none;">
        `;
        
        cluster.goalsWithSource.forEach((goalData, displayIndex) => {
            const { goal, source, sourceNodeId, originalIndex } = goalData;
            flattenedHtml += `
                <div class="goal-item" data-goal-index="${displayIndex}">
                    <div class="d-flex justify-content-between align-items-start">
                        <div class="flex-grow-1">
                            <div class="goal-text">"${goal}"</div>
                            <div class="goal-source">
                                üìÑ ${truncateText(source.document_name || 'Unknown', 25)} | 
                                üë§ ${truncateText(source.creator || 'Unknown', 15)}
                                ${source.course_name ? ` | üìö ${truncateText(source.course_name, 20)}` : ''}
                                ${source.institution ? ` | üèõÔ∏è ${truncateText(source.institution, 20)}` : ''}
                            </div>
                        </div>
                        <div class="goal-actions">
                            <button class="goal-move-btn" onclick="openMoveModal('${sourceNodeId}', 'goal', ${originalIndex})" title="Move this learning goal">
                                ‚Üî
                            </button>
                            <button class="goal-delete-btn" onclick="deleteGoal('${sourceNodeId}', ${originalIndex})" title="Delete this learning goal">
                                üóë
                            </button>
                        </div>
                    </div>
                </div>
            `;
        });
        
        flattenedHtml += `
                </div>
            </div>
        `;
    });
    
    $('#flattened-content').html(flattenedHtml);
    
    // Update download dropdown options based on available data
    updateDownloadOptions(flattened);
}

function showTreeView() {
    flattenedAtLevel = null;
    $('.level-button').removeClass('active');
    $('#tree-content').show();
    $('#flattened-content').hide();
    $('#show-tree-btn').hide();
}

function toggleCluster(nodeId) {
    const content = $(`#content-${nodeId}`);
    const icon = $(`.tree-node[data-node-id="${nodeId}"] > .cluster-header > .collapse-icon`);
    const header = $(`.tree-node[data-node-id="${nodeId}"] > .cluster-header`);
    
    if (content.is(':visible')) {
        content.slideUp(200);
        icon.removeClass('expanded');
        header.removeClass('expanded');
    } else {
        content.slideDown(200);
        icon.addClass('expanded');
        header.addClass('expanded');
    }
}

function toggleFlattenedCluster(clusterId) {
    const index = clusterId.replace('flattened-', '');
    const content = $(`#flattened-content-${index}`);
    const clusterElement = content.closest('.flattened-cluster');
    const icon = clusterElement.find('.cluster-header .collapse-icon');
    const header = clusterElement.find('.cluster-header');
    
    if (content.is(':visible')) {
        content.slideUp(200);
        icon.removeClass('expanded');
        header.removeClass('expanded');
    } else {
        content.slideDown(200);
        icon.addClass('expanded');
        header.addClass('expanded');
    }
}

function expandAll() {
    if ($('#flattened-content').is(':visible')) {
        // Flattened view is active
        $('#flattened-content .cluster-content').slideDown(200);
        $('#flattened-content .collapse-icon').addClass('expanded');
        $('#flattened-content .cluster-header').addClass('expanded');
    } else {
        // Tree view is active
        $('.cluster-content').slideDown(200);
        $('.collapse-icon').addClass('expanded');
        $('.cluster-header').addClass('expanded');
    }
}

function collapseAll() {
    if ($('#flattened-content').is(':visible')) {
        // Flattened view is active
        $('#flattened-content .cluster-content').slideUp(200);
        $('#flattened-content .collapse-icon').removeClass('expanded');
        $('#flattened-content .cluster-header').removeClass('expanded');
    } else {
        // Tree view is active
        $('.cluster-content').slideUp(200);
        $('.collapse-icon').removeClass('expanded');
        $('.cluster-header').removeClass('expanded');
    }
}

function saveChanges() {
    if (!currentArtifactId) {
        alert('No artifact loaded');
        return;
    }
    
    const saveBtn = $('#save-changes-btn');
    
    // Find all changed representative texts
    const changedTexts = [];
    $('[data-changed="true"]').each(function() {
        // Check if this element itself has data-node-id (flattened view)
        // or find it in the closest parent (tree view)
        let nodeId = $(this).data('node-id');
        if (!nodeId) {
            nodeId = $(this).closest('[data-node-id]').data('node-id');
        }
        
        const newText = $(this).find('.representative-text').text().trim();
        const state = $(this).attr('data-state') || 'manual';
        
        // Only add if we have all required fields
        if (nodeId && newText && state) {
            changedTexts.push({
                node_id: nodeId,
                representative_text: newText,
                text_state: state
            });
        } else {
            console.warn('Skipping element with missing data:', {
                nodeId: nodeId,
                newText: newText,
                state: state,
                element: this
            });
        }
    });
    
    if (changedTexts.length === 0) {
        alert('No changes to save');
        return;
    }
    
    // Show progress - start with spinner and count
    saveBtn.prop('disabled', true).html(`<i class="fa fa-spinner fa-spin"></i> Saving ${changedTexts.length} changes...`);
    
    // Use batch update API for much better performance
    $.ajax({
        url: '/api/batch-update-artifact-representative-texts',
        method: 'POST',
        contentType: 'application/json',
        data: JSON.stringify({
            artifact_id: currentArtifactId,
            updates: changedTexts
        })
    })
    .done(function(response) {
        if (response.success) {
            // Show success animation
            saveBtn.html('<i class="fa fa-check text-success"></i> Saved Successfully!');
            
            // All successful - clear change indicators
            $('[data-changed="true"]').each(function() {
                $(this).removeAttr('data-changed');
                $(this).css('backgroundColor', '');
            });
            
            // Brief success message then return to normal
            setTimeout(() => {
                saveBtn.html('<i class="bi bi-save"></i> Save Changes');
            }, 2500);
        } else {
            saveBtn.html('<i class="fa fa-exclamation-triangle text-warning"></i> Save Failed');
            alert('Failed to save changes: ' + response.message);
            
            setTimeout(() => {
                saveBtn.html('<i class="bi bi-save"></i> Save Changes');
            }, 3000);
        }
    })
    .fail(function() {
        saveBtn.html('<i class="fa fa-times text-danger"></i> Network Error');
        alert('Failed to save changes: Network error');
        
        setTimeout(() => {
            saveBtn.html('<i class="bi bi-save"></i> Save Changes');
        }, 3000);
    })
    .always(function() {
        // Always re-enable the button after the operation completes
        setTimeout(() => {
            saveBtn.prop('disabled', false);
        }, 2500);
    });
}

function deleteArtifact(artifactId) {
    $.post(`/api/delete-artifact/${artifactId}`)
        .done(function(response) {
            if (response.success) {
                // Reset everything
                currentArtifact = null;
                currentArtifactId = null;
                $('#artifact-section').hide();
                
                // Reload artifacts list
                loadAvailableArtifacts();
                
                alert('Artifact deleted successfully');
            } else {
                alert('Failed to delete artifact: ' + response.message);
            }
        })
        .fail(function() {
            alert('Failed to delete artifact: Network error');
        });
}

// =====================================
// MOVE AND DELETE FUNCTIONALITY
// =====================================

function openMoveModal(nodeId, moveType, goalIndex = null) {
    // Validate inputs first
    if (!currentArtifact || !currentArtifact.tree_structure) {
        alert('Error: No artifact loaded. Please load an artifact first.');
        return;
    }
    
    currentMoveNodeId = nodeId;
    currentMoveType = moveType;
    currentMoveGoalIndex = goalIndex;
    
    // Find the source node
    const sourceNode = findNodeById(currentArtifact.tree_structure, nodeId);
    
    if (!sourceNode) {
        console.error('Source node not found:', { nodeId, moveType, goalIndex });
        alert(`Error: Source node not found (ID: ${nodeId}). The tree structure may have changed.`);
        return;
    }
    
    // Update modal title and description (only for goal moves now)
    let description = '';
    if (moveType === 'goal' && goalIndex !== null) {
        if (!sourceNode.goals || goalIndex >= sourceNode.goals.length) {
            console.error('Goal not found:', { nodeId, goalIndex, availableGoals: sourceNode.goals ? sourceNode.goals.length : 0 });
            alert(`Error: Learning goal not found (index: ${goalIndex}). The goal may have been moved or deleted.`);
            return;
        }
        
        const goalText = sourceNode.goals[goalIndex];
        description = `<strong>Moving Learning Goal:</strong><br/><em>"${truncateText(goalText, 100)}"</em><br/><br/>Select where you want to move this learning goal:`;
        $('#moveModalLabel').html('<i class="bi bi-arrow-left-right text-info"></i> Move Learning Goal');
    } else {
        // This should not happen anymore since we only allow goal moves
        alert('Invalid move operation. Only individual learning goals can be moved.');
        return;
    }
    
    $('#move-description').html(description);
    
    // Reset new group panel
    resetNewGroupPanel();
    
    // Build destination tree
    buildMoveDestinationTree();
    
    // Clear search
    $('#move-search').val('');
    
    // Show modal
    $('#moveModal').modal('show');
}

function buildMoveDestinationTree() {
    // Only show leaf nodes (deepest level groups that can contain goals)
    const leafNodes = collectLeafNodes(currentArtifact.tree_structure);
    const treeHtml = buildMoveDestinationLeafNodes(leafNodes);
    $('#move-destination-tree').html(treeHtml);
}

function collectLeafNodes(nodes, path = []) {
    // Collect all leaf nodes (deepest level groups that can contain goals)
    let leafNodes = [];
    
    if (!nodes || !Array.isArray(nodes)) return leafNodes;
    
    nodes.forEach((node, index) => {
        if (!node || typeof node !== 'object') return;
        
        // Use representative text instead of labels (A2B3C1...) for meaningful paths
        const nodeName = node.representative_goal || `Group ${index + 1}`;
        const nodePath = [...path, nodeName];
        const hasChildren = node.children && node.children.length > 0;
        
        if (!hasChildren) {
            // This is a leaf node - can accept learning goals
            leafNodes.push({
                ...node,
                fullPath: nodePath.join(' > ')
            });
        } else {
            // Recursively collect leaf nodes from children
            leafNodes = leafNodes.concat(collectLeafNodes(node.children, nodePath));
        }
    });
    
    return leafNodes;
}

function buildMoveDestinationLeafNodes(leafNodes) {
    // Build a simple list of leaf nodes as move destinations
    let html = '';
    
    if (!leafNodes || leafNodes.length === 0) {
        return '<div class="text-center p-3 text-muted">No valid destinations found</div>';
    }
    
    leafNodes.forEach((node, index) => {
        const isCurrentLocation = node.id === currentMoveNodeId;
        const nodeTitle = node.representative_goal || `Group ${node.label}`;
        
        const nodeClasses = [
            'destination-node',
            isCurrentLocation ? 'current-location' : ''
        ].filter(Boolean).join(' ');
        
        html += `
            <div class="${nodeClasses}" data-node-id="${node.id}" data-node-name="${nodeTitle.toLowerCase()}">
                <div class="destination-node-content">
                    <div class="destination-node-text" title="${nodeTitle}">
                        ${truncateText(nodeTitle, 70)}
                    </div>
                    <i class="bi bi-info-circle destination-path-info" 
                       title="${node.fullPath}" 
                       onclick="event.stopPropagation(); showPathTooltip(this, '${node.fullPath.replace(/'/g, "&apos;")}')"
                       style="color: #6c757d; cursor: help; margin-left: 8px; font-size: 0.8em;">
                    </i>
                </div>
                ${!isCurrentLocation ? `
                    <button class="move-here-btn" onclick="performMove('${node.id}')">
                        Move Here
                    </button>
                ` : '<small class="text-warning">(Current Location)</small>'}
            </div>
        `;
    });
    
    return html;
}

function filterMoveDestinations(searchTerm) {
    const destinations = $('.destination-node');
    
    if (!searchTerm.trim()) {
        // Clear search - show all destinations
        destinations.removeClass('search-match').show();
        $('#no-matches').remove();
        return;
    }
    
    const lowerSearchTerm = searchTerm.toLowerCase();
    let hasMatches = false;
    
    destinations.each(function() {
        // Only search on the node name (not the full path)
        const nodeName = $(this).data('node-name') || $(this).find('.destination-node-text').text().toLowerCase();
        const isMatch = nodeName.includes(lowerSearchTerm);
        
        if (isMatch) {
            $(this).addClass('search-match').show();
            hasMatches = true;
        } else {
            $(this).removeClass('search-match').hide();
        }
    });
    
    if (!hasMatches) {
        $('#move-destination-tree').prepend('<div class="text-muted text-center p-3" id="no-matches">No matching destinations found</div>');
    } else {
        $('#no-matches').remove();
    }
}

function showPathTooltip(element, fullPath) {
    // Remove any existing tooltips
    $('.path-tooltip').remove();
    
    // Create and show a temporary tooltip
    const tooltip = $(`
        <div class="path-tooltip" style="
            position: absolute;
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.8em;
            z-index: 10000;
            max-width: 300px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            pointer-events: none;
        ">
            <strong>Full Path:</strong><br/>${fullPath}
        </div>
    `);
    
    $('body').append(tooltip);
    
    // Position the tooltip near the icon
    const iconOffset = $(element).offset();
    tooltip.css({
        top: iconOffset.top - tooltip.outerHeight() - 5,
        left: Math.max(10, iconOffset.left - tooltip.outerWidth() / 2)
    });
    
    // Auto-hide after 3 seconds
    setTimeout(() => {
        tooltip.fadeOut(200, () => tooltip.remove());
    }, 3000);
}

// Node-level validation functions removed - no longer needed for goal-only operations

function performMove(destinationNodeId) {
    if (!currentMoveNodeId || !currentMoveType) {
        alert('Invalid move operation');
        return;
    }
    
    // Show progress
    showProgress('Moving...', 'Updating tree structure...');
    
    const moveData = {
        artifact_id: currentArtifactId,
        source_node_id: currentMoveNodeId,
        destination_node_id: destinationNodeId,
        move_type: currentMoveType,
        goal_index: currentMoveGoalIndex
    };
    
    $.ajax({
        url: '/api/move-learning-goal',
        method: 'POST',
        contentType: 'application/json',
        data: JSON.stringify(moveData)
    })
    .done(function(response) {
        hideProgress();
        
        if (response.success) {
            // Update the current artifact with the new structure
            currentArtifact.tree_structure = response.updated_tree_structure;
            
            // Refresh the display
            if (flattenedAtLevel !== null) {
                flattenAtLevel(flattenedAtLevel);
            } else {
                displayTree(currentArtifact.tree_structure);
            }
            
            // Close modal
            $('#moveModal').modal('hide');
            
            // Show success message
            const moveTypeText = currentMoveType === 'goal' ? 'learning goal' : 'group';
            alert(`‚úÖ Successfully moved ${moveTypeText}!`);
        } else {
            alert('Failed to move: ' + response.message);
        }
    })
    .fail(function() {
        hideProgress();
        alert('Failed to move: Network error');
    });
}

// deleteNode function removed - we only delete individual learning goals now

function deleteGoal(nodeId, goalIndex) {
    // Validate inputs first
    if (!currentArtifact || !currentArtifact.tree_structure) {
        alert('Error: No artifact loaded. Please load an artifact first.');
        return;
    }
    
    const node = findNodeById(currentArtifact.tree_structure, nodeId);
    
    if (!node || !node.goals || goalIndex >= node.goals.length) {
        console.error('Goal not found for deletion:', { nodeId, goalIndex, availableGoals: node ? (node.goals ? node.goals.length : 0) : 'node not found' });
        alert(`Error: Learning goal not found (index: ${goalIndex}). The goal may have been moved or deleted.`);
        return;
    }
    
    const goalText = node.goals[goalIndex];
    const confirmMessage = `Are you sure you want to delete this learning goal?\n\n"${truncateText(goalText, 100)}"\n\nIt will be moved to the archive.`;
    
    if (!confirm(confirmMessage)) return;
    
    // Show progress
    showProgress('Deleting...', 'Moving to archive...');
    
    $.ajax({
        url: '/api/delete-goal',
        method: 'POST',
        contentType: 'application/json',
        data: JSON.stringify({
            artifact_id: currentArtifactId,
            node_id: nodeId,
            goal_index: goalIndex
        })
    })
    .done(function(response) {
        hideProgress();
        
        if (response.success) {
            // Update the current artifact with the new structure
            currentArtifact.tree_structure = response.updated_tree_structure;
            
            // Refresh the display
            if (flattenedAtLevel !== null) {
                flattenAtLevel(flattenedAtLevel);
            } else {
                displayTree(currentArtifact.tree_structure);
            }
            
            alert('‚úÖ Learning goal deleted successfully and moved to archive.');
        } else {
            alert('Failed to delete: ' + response.message);
        }
    })
    .fail(function() {
        hideProgress();
        alert('Failed to delete: Network error');
    });
}

function loadArchivedGoals() {
    $('#archived-goals-container').html('<div class="text-center p-3"><div class="spinner-border spinner-border-sm"></div> Loading archived goals...</div>');
    $('#archiveModal').modal('show');
    
    $.get(`/api/get-archived-goals/${currentArtifactId}`)
        .done(function(response) {
            if (response.success) {
                displayArchivedGoals(response.archived_goals);
            } else {
                $('#archived-goals-container').html('<div class="text-center p-3 text-muted">Failed to load archived goals</div>');
            }
        })
        .fail(function() {
            $('#archived-goals-container').html('<div class="text-center p-3 text-muted">Network error loading archived goals</div>');
        });
}

function displayArchivedGoals(archivedGoals) {
    if (!archivedGoals || archivedGoals.length === 0) {
        $('#archived-goals-container').html('<div class="text-center p-3 text-muted">No archived learning goals found</div>');
        return;
    }
    
    let html = '';
    archivedGoals.forEach((archivedGoal, index) => {
        const archivedDate = new Date(archivedGoal.archived_at).toLocaleDateString();
        html += `
            <div class="archived-goal-item">
                <div class="archived-goal-text">"${archivedGoal.goal_text}"</div>
                <div class="archived-goal-meta">
                    <div>
                        <small>üìÑ ${archivedGoal.document_name || 'Unknown'} | üë§ ${archivedGoal.creator || 'Unknown'}</small><br/>
                        <small>üóìÔ∏è Archived: ${archivedDate} | Original path: ${archivedGoal.original_path || 'Unknown'}</small>
                    </div>
                    <button class="restore-btn" onclick="restoreGoal('${archivedGoal.id}', ${index})" title="Restore this learning goal">
                        ‚Ü©Ô∏è Restore
                    </button>
                </div>
            </div>
        `;
    });
    
    $('#archived-goals-container').html(html);
}

function restoreGoal(archivedGoalId, index) {
    if (!confirm('Restore this learning goal to its original location?')) return;
    
    $.ajax({
        url: '/api/restore-goal',
        method: 'POST',
        contentType: 'application/json',
        data: JSON.stringify({
            artifact_id: currentArtifactId,
            archived_goal_id: archivedGoalId
        })
    })
    .done(function(response) {
        if (response.success) {
            // Update the current artifact with the new structure
            currentArtifact.tree_structure = response.updated_tree_structure;
            
            // Refresh the display
            if (flattenedAtLevel !== null) {
                flattenAtLevel(flattenedAtLevel);
            } else {
                displayTree(currentArtifact.tree_structure);
            }
            
            // Remove the restored item from the archive display
            $(`.archived-goal-item:eq(${index})`).fadeOut();
            
            alert('‚úÖ Learning goal restored successfully!');
        } else {
            alert('Failed to restore: ' + response.message);
        }
    })
    .fail(function() {
        alert('Failed to restore: Network error');
    });
}

function showProgress(title, details) {
    $('#progress-text').text(title);
    $('#progress-details').text(details);
    $('#operation-progress').show();
}

function hideProgress() {
    $('#operation-progress').hide();
}

// =====================================
// NEW GROUP CREATION FUNCTIONALITY
// =====================================

function resetNewGroupPanel() {
    const panel = $('#create-new-group-panel');
    const btn = $('#create-new-group-btn');
    
    // Reset to initial state
    panel.hide();
    btn.html('<i class="bi bi-plus-circle-dotted"></i> Create new group instead');
    selectedNewGroupLocation = null;
    currentNewGroupName = null;
    $('#create-and-move-btn').prop('disabled', true);
    $('#new-group-tree-selector').empty();
    $('.tree-level-item').removeClass('selected');
}

function showCreateGroupInfo() {
    alert(`About Creating New Groups:\n\n‚Ä¢ Use this option if none of the existing groups above are suitable for your learning goal\n‚Ä¢ A new group will be created with your learning goal as its name\n‚Ä¢ You'll choose where in the hierarchy to place this new group\n‚Ä¢ You can only create new groups at the level that contains other groups (not deeper levels)`);
}

function toggleCreateNewGroup() {
    const panel = $('#create-new-group-panel');
    const btn = $('#create-new-group-btn');
    
    if (panel.is(':visible')) {
        // Hide the panel
        panel.slideUp();
        btn.html('<i class="bi bi-plus-circle-dotted"></i> Create new group instead');
        selectedNewGroupLocation = null;
        $('#create-and-move-btn').prop('disabled', true);
    } else {
        // Show the panel and set up the goal name
        if (currentMoveType === 'goal' && currentMoveGoalIndex !== null) {
            const sourceNode = findNodeById(currentArtifact.tree_structure, currentMoveNodeId);
            if (sourceNode && sourceNode.goals && sourceNode.goals[currentMoveGoalIndex]) {
                currentNewGroupName = sourceNode.goals[currentMoveGoalIndex];
                $('#new-group-name-preview').text(truncateText(currentNewGroupName, 100));
                
                // Build the hierarchical tree selector
                buildNewGroupTreeSelector();
                
                panel.slideDown();
                btn.html('<i class="bi bi-x-circle text-muted"></i> Cancel');
            }
        }
    }
}

function buildNewGroupTreeSelector() {
    // Start with top-level nodes - no "Select Here" buttons at top level
    const topLevelHtml = buildTreeLevel(currentArtifact.tree_structure, [], 'top');
    
    $('#new-group-tree-selector').html(topLevelHtml);
}

function isSecondToLastLevel(node) {
    // A node is at second-to-last level if:
    // 1. It has children (not a leaf group itself)
    // 2. All its children are leaf groups (have no children of their own)
    if (!node.children || node.children.length === 0) {
        return false; // This is a leaf group
    }
    
    // Check if all children are leaf groups
    return node.children.every(child => !child.children || child.children.length === 0);
}

function buildTreeLevel(nodes, path = [], containerId = null) {
    let html = '';
    
    nodes.forEach((node, index) => {
        const hasChildren = node.children && node.children.length > 0;
        const nodeTitle = node.representative_goal || `Group ${node.label}`;
        const currentPath = [...path, { id: node.id, title: nodeTitle }];
        const pathStr = JSON.stringify(currentPath).replace(/"/g, '&quot;');
        
        const itemId = containerId ? `${containerId}-${index}` : `item-${index}`;
        const canSelectHere = isSecondToLastLevel(node);
        
        html += `
            <div class="tree-level-item ${hasChildren ? '' : 'leaf'}" data-node-id="${node.id}" data-item-id="${itemId}">
                ${hasChildren ? 
                    `<i class="bi bi-chevron-right expand-icon" onclick="event.stopPropagation(); toggleTreeLevel('${itemId}', '${node.id}', '${pathStr}')"></i>` :
                    `<i class="bi bi-circle-fill expand-icon"></i>`
                }
                <div class="tree-level-text" title="${nodeTitle}">
                    ${truncateText(nodeTitle, 60)}
                    ${canSelectHere ? ' <small class="text-success">(can add groups here)</small>' : ''}
                </div>
                ${canSelectHere ? `
                    <button class="select-location-btn" onclick="event.stopPropagation(); selectNewGroupLocation('${node.id}', '${pathStr}')">
                        Select Here
                    </button>
                ` : hasChildren ? '<small class="text-muted">Navigate deeper ‚Üì</small>' : '<small class="text-muted">Group</small>'}
            </div>
            ${hasChildren ? `<div class="tree-children" id="children-${itemId}" style="display: none;"></div>` : ''}
        `;
    });
    
    return html;
}

function toggleTreeLevel(itemId, nodeId, pathStr) {
    const item = $(`[data-item-id="${itemId}"]`);
    const childrenContainer = $(`#children-${itemId}`);
    const icon = item.find('.expand-icon');
    
    if (childrenContainer.is(':visible')) {
        // Collapse
        childrenContainer.slideUp();
        icon.removeClass('bi-chevron-down').addClass('bi-chevron-right');
        item.removeClass('expanded');
    } else {
        // Expand - load children if not already loaded
        if (childrenContainer.is(':empty')) {
            const node = findNodeById(currentArtifact.tree_structure, nodeId);
            if (node && node.children) {
                const path = JSON.parse(pathStr.replace(/&quot;/g, '"'));
                const childrenHtml = buildTreeLevel(node.children, path, itemId);
                childrenContainer.html(childrenHtml);
            }
        }
        
        childrenContainer.slideDown();
        icon.removeClass('bi-chevron-right').addClass('bi-chevron-down');
        item.addClass('expanded');
    }
}

function selectNewGroupLocation(locationId, pathStr) {
    // Clear previous selection
    $('.tree-level-item').removeClass('selected');
    
    // Set new selection - only "under" type since we removed top-level creation
    const path = JSON.parse(pathStr.replace(/&quot;/g, '"'));
    selectedNewGroupLocation = { type: 'under', parentId: locationId, path: path };
    $(`[data-node-id="${locationId}"]`).addClass('selected');
    
    // Enable the create button
    $('#create-and-move-btn').prop('disabled', false);
}

function createNewGroupAndMove() {
    if (!selectedNewGroupLocation || !currentNewGroupName) {
        alert('Please select a location for the new group');
        return;
    }
    
    // Show progress
    showProgress('Creating new group...', 'Creating group and moving goal...');
    
    // Prepare the data for the backend
    const createData = {
        artifact_id: currentArtifactId,
        source_node_id: currentMoveNodeId,
        goal_index: currentMoveGoalIndex,
        new_group_name: currentNewGroupName,
        location: selectedNewGroupLocation
    };
    
    $.ajax({
        url: '/api/create-group-and-move-goal',
        method: 'POST',
        contentType: 'application/json',
        data: JSON.stringify(createData)
    })
    .done(function(response) {
        hideProgress();
        
        if (response.success) {
            // Update the current artifact with the new structure
            currentArtifact.tree_structure = response.updated_tree_structure;
            
            // Refresh the display
            if (flattenedAtLevel !== null) {
                flattenAtLevel(flattenedAtLevel);
            } else {
                displayTree(currentArtifact.tree_structure);
            }
            
            // Close modal
            $('#moveModal').modal('hide');
            
            // Show success message
            alert(`‚úÖ Successfully created new group "${truncateText(currentNewGroupName, 50)}" and moved the learning goal!`);
        } else {
            alert('Failed to create group and move goal: ' + response.message);
        }
    })
    .fail(function() {
        hideProgress();
        alert('Failed to create group and move goal: Network error');
    });
}

// =====================================
// CSV DOWNLOAD FUNCTIONALITY
// =====================================

function updateDownloadOptions(flattened) {
    // Check what data is available in the flattened clusters
    const availableFields = {
        institution: false,
        creator: false,
        course_name: false
    };
    
    // Check all sources for available fields
    flattened.forEach(cluster => {
        cluster.goalsWithSource.forEach(goalData => {
            const { source } = goalData;
            if (source.institution && source.institution.trim() !== '') {
                availableFields.institution = true;
            }
            if (source.creator && source.creator.trim() !== '') {
                availableFields.creator = true;
            }
            if (source.course_name && source.course_name.trim() !== '') {
                availableFields.course_name = true;
            }
        });
    });
    
    // Update dropdown options
    const dropdown = $('#download-column-type');
    const currentValue = dropdown.val();
    dropdown.empty();
    
    if (availableFields.institution) {
        dropdown.append('<option value="institution">by Institution</option>');
    }
    if (availableFields.creator) {
        dropdown.append('<option value="creator">by Creator</option>');
    }
    if (availableFields.course_name) {
        dropdown.append('<option value="course_name">by Course</option>');
    }
    
    // If no fields are available, show a default option
    if (!availableFields.institution && !availableFields.creator && !availableFields.course_name) {
        dropdown.append('<option value="creator">by Creator (Limited Data)</option>');
    }
    
    // Try to restore previous selection if still available
    if (dropdown.find(`option[value="${currentValue}"]`).length > 0) {
        dropdown.val(currentValue);
    }
}

function downloadFlattenedCSV(levelLabel) {
    if (!currentArtifact || flattenedAtLevel === null) {
        alert('No flattened view available to download');
        return;
    }
    
    const columnType = $('#download-column-type').val();
    
    // Get flattened data for the current level
    const flattened = flattenTreeAtLevel(currentArtifact.tree_structure, flattenedAtLevel);
    
    if (!flattened || flattened.length === 0) {
        alert('No data available to download');
        return;
    }
    
    // Helper function to properly escape CSV values
    function escapeCSVField(field) {
        // Convert to string and handle null/undefined
        const str = String(field || '');
        
        // If the field contains commas, quotes, or newlines, wrap in quotes and escape internal quotes
        if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
            return '"' + str.replace(/"/g, '""') + '"';
        }
        return str;
    }
    
    // Collect all unique values for the selected column type
    const allUniqueValues = new Set();
    const clusterData = {};
    
    // Process each cluster
    flattened.forEach(cluster => {
        const clusterName = cluster.representative || cluster.originalNode.representative_goal || cluster.label;
        clusterData[clusterName] = {};
        
        cluster.goalsWithSource.forEach(goalData => {
            const { source } = goalData;
            let columnValue = source[columnType];
            
            // Handle missing data
            if (!columnValue || columnValue.trim() === '') {
                columnValue = `Unknown ${columnType.replace('_', ' ')}`;
            }
            
            allUniqueValues.add(columnValue);
            
            // Count goals for this column value in this cluster
            if (!clusterData[clusterName][columnValue]) {
                clusterData[clusterName][columnValue] = 0;
            }
            clusterData[clusterName][columnValue]++;
        });
    });
    
    // Convert to sorted array and escape column headers
    const sortedColumnValues = Array.from(allUniqueValues).sort();
    const escapedColumnHeaders = sortedColumnValues.map(escapeCSVField);
    
    // Generate CSV content with proper escaping
    let csvContent = escapeCSVField("Cluster Name") + "," + escapedColumnHeaders.join(',') + "\n";
    
    // Add data rows
    Object.keys(clusterData).forEach(clusterName => {
        const row = [escapeCSVField(clusterName)];
        sortedColumnValues.forEach(columnValue => {
            const count = clusterData[clusterName][columnValue] || 0;
            row.push(count); // Numbers don't need escaping
        });
        csvContent += row.join(',') + "\n";
    });
    
    // Create and download the file
    const columnTypeLabel = columnType.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
    const filename = `LG_Hierarchy_Level_${levelLabel}_by_${columnTypeLabel.replace(' ', '_')}.csv`;
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    if (link.download !== undefined) {
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', filename);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    } else {
        alert('Browser does not support file download');
    }
}
</script>
{% endblock %}