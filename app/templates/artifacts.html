{% extends "base.html" %}

{% block title %}Tree Artifacts{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
    .clustering-controls {
        background-color: #f8f9fa;
        padding: 10px;
        border-radius: 6px;
        margin-bottom: 5px;
    }
    
    /* Tree Structure Styling - updated for new layout */
    .tree-container {
        font-family: 'Monaco', 'Consolas', monospace;
        background-color: #f8f9fa;
        border-radius: 8px;
        padding: 12px;
        margin-top: 0px;
        margin-bottom: 15px;
    }
    
    .tree-node {
        margin: 2px 0;
        border-left: 2px solid transparent;
        transition: all 0.2s ease;
    }
    
    .tree-node:hover {
        background-color: rgba(0, 123, 255, 0.05);
        border-left-color: #007bff;
    }
    
    /* Smart indentation - consistent small increments */
    .tree-level-0 { margin-left: 0px; }
    .tree-level-1,
    .tree-level-2,
    .tree-level-3,
    .tree-level-4,
    .tree-level-5,
    .tree-level-6,
    .tree-level-7,
    .tree-level-8,
    .tree-level-9,
    .tree-level-10,
    .tree-level-deep { /* All non-root levels get the same single-step indent */
        margin-left: 12px;
    }
    
    /* Beyond level 10, use a different visual cue */
    .tree-level-deep {
        /* margin-left: 12px; is handled above */
        border-left: 3px dotted #6c757d; /* This border is part of the node itself */
        padding-left: 10px; /* This will indent the *content* of tree-level-deep nodes further */
    }
    
    .cluster-header {
        display: flex;
        align-items: center;
        padding: 8px 12px;
        cursor: pointer;
        background-color: white;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        margin-bottom: 3px;
        transition: all 0.2s ease;
    }
    
    .cluster-header:hover {
        background-color: #e3f2fd;
        border-color: #007bff;
        transform: translateX(2px);
    }
    
    .cluster-header.expanded {
        background-color: #e8f5e9;
        border-color: #28a745;
    }
    
    /* Style for nodes that don't subdivide (single child) */
    .cluster-header.no-subdivision {
        background-color: #f8f9fa;
        border-style: dashed;
        opacity: 0.8;
    }
    
    .cluster-header.no-subdivision:hover {
        background-color: #e9ecef;
        opacity: 1;
    }
    
    /* NEW: Representative text styling - now the main editable element */
    .cluster-representative {
        font-size: 1em;
        font-weight: bold;
        color: #212529;
        background-color: transparent;
        border: 1px solid transparent;
        border-radius: 4px;
        padding: 4px 8px;
        margin-right: 8px;
        flex: 1;
        min-height: 24px;
        cursor: text;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 6px;
    }
    
    .cluster-representative:hover {
        border-color: #007bff;
        background-color: rgba(255, 255, 255, 0.8);
    }
    
    .cluster-representative.editing {
        border-color: #28a745;
        background-color: white;
        outline: none;
        box-shadow: 0 0 0 0.2rem rgba(40, 167, 69, 0.25);
    }
    
    /* FontAwesome state icons */
    .text-state-icon {
        font-size: 0.8em;
        opacity: 0.7;
        margin-right: 4px;
        flex-shrink: 0;
    }
    
    .text-state-icon.fa-quote-left {
        color: #6c757d;
    }
    
    .text-state-icon.fa-pencil {
        color: #228B22; /* Green for manual edit */
    }
    
    .text-state-icon.fa-wand-magic-sparkles {
        color: #6f42c1;
    }
    
    /* State-based text coloring for representative text */
    .cluster-representative[data-state="default"] .representative-text,
    .cluster-representative:not([data-state]) .representative-text {
        color: #495057; /* Dark grey for default/representative */
    }
    
    .cluster-representative[data-state="manual"] .representative-text {
        color: #228B22; /* Green for manually edited */
    }
    
    .cluster-representative[data-state="ai"] .representative-text {
        color: #6f42c1; /* Purple for AI generated */
    }
    
    /* Auto-generate button */
    .auto-generate-btn {
        background: linear-gradient(135deg, #f8f9fa, #e9ecef);
        border: 1px solid #6f42c1;
        border-radius: 6px;
        padding: 6px 10px;
        margin-right: 12px;
        cursor: pointer;
        color: #6f42c1;
        font-size: 0.75em;
        transition: all 0.2s ease;
        flex-shrink: 0;
        box-shadow: 0 1px 2px rgba(111, 66, 193, 0.1);
    }
    
    .auto-generate-btn:hover {
        background: linear-gradient(135deg, #6f42c1, #8a5cf5);
        border-color: #6f42c1;
        color: white;
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(111, 66, 193, 0.2);
    }
    
    /* NEW: Small gray label - now secondary with more spacing */
    .cluster-label {
        font-size: 0.75em;
        color: #6c757d;
        font-weight: normal;
        margin-right: 15px;
        margin-left: 5px;
        padding: 2px 6px;
        background-color: #f8f9fa;
        border-radius: 3px;
        flex-shrink: 0;
    }
    
    .cluster-size {
        background-color: #007bff;
        color: white;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.8em;
        margin-left: auto;
        flex-shrink: 0;
    }
    
    .cluster-actions {
        margin-left: 8px;
        display: flex;
        gap: 5px;
    }
    
    .collapse-icon {
        transition: transform 0.2s ease;
        margin-right: 8px;
        color: #6c757d;
        flex-shrink: 0;
    }
    
    .collapse-icon.expanded {
        transform: rotate(90deg);
    }
    
    .cluster-content {
        padding: 15px 8px 15px 0px;
        background-color: #f8f9fa;
        border: 1px solid #dee2e6;
        border-top: none;
        border-radius: 0 0 6px 6px;
        margin-bottom: 10px;
    }
    
    .goal-item {
        padding: 8px 12px;
        margin: 5px 0;
        background-color: white;
        border-left: 3px solid #007bff;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    
    .goal-text {
        font-size: 0.9em;
        line-height: 1.4;
        margin-bottom: 4px;
        color: #343a40;
    }
    
    .goal-source {
        font-size: 0.6em;
        color: #6c757d;
        font-style: italic;
    }
    
    .document-link {
        color: #007bff;
        cursor: pointer;
        text-decoration: none;
        transition: color 0.2s ease;
    }
    
    .document-link:hover {
        color: #0056b3;
        text-decoration: underline;
    }
    
    .clustering-stats {
        background-color: #e3f2fd;
        border: 1px solid #90caf9;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
    }
    
    /* Subtle artifact info styling - much cleaner than clustering-stats */
    .artifact-info {
        color: #6c757d;
        font-size: 0.9em;
        margin-bottom: 5px;
        padding: 4px 0;
        border-bottom: 1px solid #e9ecef;
    }
    
    .artifact-info .artifact-name {
        font-weight: 600;
        color: #495057;
        margin-right: 12px;
    }
    
    .artifact-info .artifact-details {
        display: inline;
        font-size: 0.85em;
    }
    
    .artifact-info .artifact-details span {
        margin-right: 20px;
        white-space: nowrap;
    }
    
    .artifact-info .artifact-details span:last-child {
        margin-right: 0;
    }
    
    /* Level Controls - matching cluster_tree */
    .level-button {
        font-weight: bold;
        min-width: 80px;
        min-height: 60px;
        text-align: center;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding: 8px 12px;
        line-height: 1.2;
    }
    
    .level-button.active {
        background-color: #28a745;
        border-color: #28a745;
        color: white;
    }
    
    /* Flattened Content */
    .flattened-cluster {
        margin-bottom: 20px;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        overflow: hidden;
    }
    
    .flattened-cluster-header {
        background-color: #f8f9fa;
        padding: 12px 15px;
        border-bottom: 1px solid #dee2e6;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .flattened-cluster-title {
        font-weight: bold;
        color: #495057;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .flattened-cluster-content {
        padding: 15px;
        background-color: white;
    }
    
    .artifact-badge {
        background: linear-gradient(45deg, #6f42c1, #e83e8c);
        color: white;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 0.7em;
        font-weight: bold;
    }

    /* AI Generation Modal */
    .goal-preview {
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        padding: 10px;
        background-color: #f8f9fa;
        font-size: 0.85em;
    }
    
    .goal-preview-item {
        padding: 4px 0;
        border-bottom: 1px solid #e9ecef;
    }
    
    .goal-preview-item:last-child {
        border-bottom: none;
    }
    
    .goal-preview-text {
        font-weight: 500;
        color: #495057;
    }
    
    .goal-preview-source {
        font-size: 0.75em;
        color: #6c757d;
        margin-top: 2px;
    }
    
    /* Collapsible artifact selection styling */
    .artifact-selection-container {
        margin-bottom: 5px;
    }
    
    .collapsed-title {
        padding: 5px 0;
        margin-bottom: 5px;
    }
    
    .collapsed-title .btn {
        font-size: 0.85em;
        color: #6c757d !important;
        transition: all 0.2s ease;
    }
    
    .collapsed-title .btn:hover {
        color: #6f42c1 !important;
    }
    
    .collapsed-title .btn i {
        transition: transform 0.2s ease;
    }
    
    /* Show collapsed title only when section is collapsed */
    .artifact-selection-container:has(#artifact-selection.show) .collapsed-title,
    .artifact-selection-container:has(#artifact-selection.collapsing) .collapsed-title {
        display: none;
    }
    
    /* Alternative approach for broader browser support */
    .collapsed-title.hidden {
        display: none;
    }
    
    /* Chevron rotation */
    .collapsed-title .btn[aria-expanded="true"] i {
        transform: rotate(90deg);
    }

    /* Move/Delete Action Buttons */
    .action-buttons {
        display: flex;
        gap: 5px;
        margin-left: 8px;
        flex-shrink: 0;
    }
    
    .move-btn, .delete-btn {
        padding: 4px 6px;
        border-radius: 4px;
        border: 1px solid;
        cursor: pointer;
        font-size: 0.7em;
        transition: all 0.2s ease;
        background-color: white;
        opacity: 0.7;
        min-width: 24px;
        text-align: center;
    }
    
    .move-btn {
        border-color: #17a2b8;
        color: #17a2b8;
    }
    
    .move-btn:hover {
        background-color: #17a2b8;
        color: white;
        opacity: 1;
        transform: scale(1.1);
    }
    
    .delete-btn {
        border-color: #dc3545;
        color: #dc3545;
    }
    
    .delete-btn:hover {
        background-color: #dc3545;
        color: white;
        opacity: 1;
        transform: scale(1.1);
    }
    
    .delete-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
        border-color: #6c757d;
        color: #6c757d;
    }
    
    .delete-btn:disabled:hover {
        background-color: white;
        color: #6c757d;
        transform: none;
    }

    /* Individual Goal Move/Delete Buttons */
    .goal-actions {
        display: flex;
        gap: 4px;
        margin-top: 4px;
        margin-left: auto;
        opacity: 0;
        transition: opacity 0.2s ease;
    }
    
    .goal-item:hover .goal-actions {
        opacity: 1;
    }
    
    .goal-move-btn, .goal-delete-btn {
        padding: 2px 4px;
        border-radius: 3px;
        border: 1px solid;
        cursor: pointer;
        font-size: 0.6em;
        transition: all 0.2s ease;
        background-color: white;
        min-width: 20px;
        text-align: center;
    }
    
    .goal-move-btn {
        border-color: #17a2b8;
        color: #17a2b8;
    }
    
    .goal-move-btn:hover {
        background-color: #17a2b8;
        color: white;
    }
    
    .goal-delete-btn {
        border-color: #dc3545;
        color: #dc3545;
    }
    
    .goal-delete-btn:hover {
        background-color: #dc3545;
        color: white;
    }

    /* Archive Button */
    .archive-btn {
        background-color: #f8f9fa;
        border: 1px solid #6c757d;
        color: #6c757d;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.7em;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .archive-btn:hover {
        background-color: #6c757d;
        color: white;
    }

    /* Move Modal Styles */
    .move-modal .modal-dialog {
        max-width: 700px;
    }
    
    .move-destination-tree {
        max-height: 400px;
        overflow-y: auto;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 10px;
        background-color: #f8f9fa;
    }
    
    .destination-node {
        margin: 2px 0;
        padding: 4px 8px;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .destination-node:hover {
        background-color: #e3f2fd;
    }
    
    .destination-node.current-location {
        background-color: #fff3e0;
        border: 1px solid #ff9800;
    }
    
    .destination-node.invalid-destination {
        background-color: #ffebee;
        opacity: 0.6;
        cursor: not-allowed;
    }
    
    .destination-node-content {
        flex: 1;
        display: flex;
        align-items: center;
    }
    
    .destination-node-text {
        font-weight: 500;
        flex-grow: 1;
    }
    
    .destination-path-info {
        flex-shrink: 0;
        opacity: 0.7;
        transition: opacity 0.2s ease;
    }
    
    .destination-path-info:hover {
        opacity: 1;
        color: #007bff !important;
    }
    
    .move-here-btn {
        padding: 2px 8px;
        font-size: 0.7em;
        border-radius: 3px;
        background-color: #28a745;
        border: 1px solid #28a745;
        color: white;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .move-here-btn:hover {
        background-color: #218838;
        transform: scale(1.05);
    }
    
    .move-search-input {
        margin-bottom: 15px;
        padding: 8px 12px;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        font-size: 0.9em;
        width: 100%;
    }
    
    .move-search-input:focus {
        outline: none;
        border-color: #007bff;
        box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
    }
    
    .destination-node.search-match {
        background-color: #fff9c4;
        border: 1px solid #fbc02d;
    }
    
    .destination-node.search-match .destination-node-text {
        font-weight: bold;
    }

    /* New Group Creation Styles */
    .new-group-tree-selector {
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 10px;
        background-color: #f8f9fa;
    }
    
    .tree-level-item {
        margin: 3px 0;
        padding: 6px 10px;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 8px;
        border: 1px solid transparent;
    }
    
    .tree-level-item:hover {
        background-color: #e3f2fd;
        border-color: #2196f3;
    }
    
    .tree-level-item.selected {
        background-color: #c8e6c9;
        border-color: #4caf50;
        font-weight: 500;
    }
    
    .tree-level-item .expand-icon {
        transition: transform 0.2s ease;
        color: #6c757d;
        font-size: 0.8em;
        width: 12px;
        text-align: center;
    }
    
    .tree-level-item.expanded .expand-icon {
        transform: rotate(90deg);
    }
    
    .tree-level-item.leaf .expand-icon {
        opacity: 0.3;
    }
    
    .tree-level-text {
        flex-grow: 1;
    }
    
    .select-location-btn {
        padding: 2px 8px;
        font-size: 0.7em;
        border-radius: 3px;
        background-color: #28a745;
        border: 1px solid #28a745;
        color: white;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .select-location-btn:hover {
        background-color: #218838;
        transform: scale(1.05);
    }
    
    .tree-children {
        margin-left: 20px;
        margin-top: 5px;
        border-left: 1px dashed #dee2e6;
        padding-left: 10px;
    }

    /* Archive Modal Styles */
    .archived-goals-container {
        max-height: 400px;
        overflow-y: auto;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 15px;
        background-color: #f8f9fa;
    }

    /* Search Functionality Styles */
    .search-container {
        margin-bottom: 15px;
        position: relative;
    }
    
    .search-input {
        width: 100%;
        padding: 10px 40px 10px 35px;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        font-size: 0.9em;
        transition: all 0.2s ease;
        line-height: 1.2;
        height: 40px;
        box-sizing: border-box;
    }
    
    .search-input:focus {
        outline: none;
        border-color: #007bff;
        box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
    }
    
    .search-icon {
        position: absolute;
        left: 12px;
        top: 50%;
        transform: translateY(-50%);
        color: #6c757d;
        font-size: 14px;
        pointer-events: none;
        z-index: 2;
        line-height: 1;
        display: flex;
        align-items: center;
        height: 16px;
        margin-top: -8px;
    }
    
    .search-clear {
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        background: none;
        border: none;
        color: #6c757d;
        cursor: pointer;
        padding: 2px;
        border-radius: 3px;
        display: none;
        z-index: 2;
        line-height: 1;
        font-size: 14px;
        width: 20px;
        height: 20px;
        margin-top: -10px;
        align-items: center;
        justify-content: center;
    }
    
    .search-clear:not([style*="display: none"]) {
        display: flex;
    }
    
    .search-clear:hover {
        background-color: #f8f9fa;
        color: #495057;
    }
    
    .search-results-info {
        font-size: 0.8em;
        color: #6c757d;
        margin-top: 5px;
        min-height: 1rem;
    }
    
    /* Search highlighting */
    .search-highlight {
        background-color: #fff3cd;
        border: 1px solid #fbc02d;
        border-radius: 2px;
        padding: 1px 2px;
        font-weight: 500;
    }
    
    /* Search match indicators */
    .search-match-cluster {
        border-left: 3px solid #28a745 !important;
        background-color: rgba(40, 167, 69, 0.05);
    }
    
    .search-match-goal {
        border-left: 3px solid #007bff !important;
        background-color: rgba(0, 123, 255, 0.05);
    }
    
    .search-hidden {
        display: none !important;
    }

    /* Subtle Download Controls */
    .download-controls {
        display: flex;
        align-items: center;
        gap: 8px;
        opacity: 0.7;
        transition: opacity 0.2s ease;
    }
    
    .download-controls:hover {
        opacity: 1;
    }
    
    .download-controls .form-select {
        font-size: 0.75em;
        padding: 4px 24px 4px 8px;
        border-color: #dee2e6;
        color: #6c757d;
        width: auto;
        min-width: 120px;
        background-position: right 6px center;
        background-size: 12px;
    }
    
    .download-controls .btn {
        font-size: 0.75em;
        padding: 4px 8px;
        border-color: #dee2e6;
        color: #6c757d;
    }
    
    .download-controls .btn:hover {
        background-color: #f8f9fa;
        border-color: #007bff;
        color: #007bff;
    }
    
    .archived-goal-item {
        padding: 10px;
        margin: 8px 0;
        background-color: white;
        border-left: 3px solid #6c757d;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    
    .archived-goal-text {
        font-size: 0.9em;
        color: #495057;
        margin-bottom: 5px;
    }
    
    .archived-goal-meta {
        font-size: 0.7em;
        color: #6c757d;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .restore-btn {
        padding: 2px 6px;
        font-size: 0.6em;
        background-color: #28a745;
        border: 1px solid #28a745;
        color: white;
        border-radius: 3px;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .restore-btn:hover {
        background-color: #218838;
    }

    /* Progress Animation Styles */
    .operation-progress {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        border: 2px solid #007bff;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        z-index: 9999;
        min-width: 300px;
        text-align: center;
    }
    
    .operation-progress .spinner-border {
        margin-bottom: 10px;
    }
    
    .operation-progress-text {
        margin-bottom: 10px;
        font-weight: 500;
    }
    
    .operation-progress-details {
        font-size: 0.8em;
        color: #6c757d;
    }

    /* Dendrogram Styles */
    .dendrogram-controls {
        background-color: #f8f9fa !important;
    }
    
    #dendrogram-container {
        background-color: #ffffff;
        border: 1px solid #dee2e6;
    }
    
    .dendrogram-node {
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .dendrogram-node circle {
        fill: #fff;
        stroke: #007bff;
        stroke-width: 2px;
        transition: all 0.2s ease;
    }
    
    .dendrogram-node.leaf circle {
        fill: #28a745;
        stroke: #1e7e34;
    }
    
    .dendrogram-node:hover circle {
        stroke-width: 3px;
        r: 6;
    }
    
    .dendrogram-node.leaf:hover circle {
        fill: #34ce57;
    }
    
    .dendrogram-link {
        fill: none;
        stroke: #6c757d;
        stroke-width: 1.5px;
        transition: stroke-width 0.2s ease;
    }
    
    .dendrogram-link:hover {
        stroke: #007bff;
        stroke-width: 2.5px;
    }
    
    .dendrogram-text {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        font-size: 11px;
        fill: #495057;
        text-anchor: start;
        dominant-baseline: middle;
        pointer-events: none;
        transition: opacity 0.2s ease;
    }
    
    .dendrogram-text.cluster-label {
        font-weight: 600;
        fill: #007bff;
    }
    
    .dendrogram-text.representative-text {
        font-size: 10px;
        fill: #6c757d;
        font-style: italic;
    }
    
    /* Representative text color coding in dendrogram */
    .dendrogram-text.representative-text.state-default {
        fill: #495057; /* Dark grey for default/representative */
    }
    
    .dendrogram-text.representative-text.state-manual {
        fill: #228B22; /* Green for manually edited */
    }
    
    .dendrogram-text.representative-text.state-ai {
        fill: #6f42c1; /* Purple for AI generated */
    }
    
    .dendrogram-text.leaf-text {
        fill: #28a745;
        font-weight: 500;
    }
    
    /* Radial layout specific styles */
    .radial-layout .dendrogram-text {
        text-anchor: middle;
    }
    
    /* Zoom and pan styles */

    
    /* Selection styles */
    .dendrogram-node.selected circle {
        stroke: #dc3545;
        stroke-width: 3px;
        fill: #fff5f5;
    }
    
    .dendrogram-node.highlighted circle {
        stroke: #ffc107;
        stroke-width: 3px;
        fill: #fffbf0;
    }
    
    /* Focus mode styles */
    .dendrogram-node.focused circle {
        stroke: #dc3545;
        stroke-width: 4px;
        fill: #fff5f5;
        filter: drop-shadow(0 0 6px rgba(220, 53, 69, 0.5));
    }
    
    .dendrogram-node.dimmed {
        opacity: 0.3;
        transition: opacity 0.3s ease;
    }
    
    .dendrogram-node.focus-child circle {
        stroke: #28a745;
        stroke-width: 2px;
    }
    
    /* Breadcrumb styles */
    .breadcrumb-item {
        background-color: #e9ecef;
        border-radius: 12px;
        padding: 2px 8px;
        font-size: 0.75em;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .breadcrumb-item:hover {
        background-color: #007bff;
        color: white;
    }
    
    .breadcrumb-separator {
        color: #6c757d;
        font-size: 0.7em;
    }
    
    /* Collapsible node styles */
    .dendrogram-node.collapsed .dendrogram-children {
        display: none;
    }
    
    .dendrogram-node.has-hidden-children circle {
        stroke-dasharray: 3,3;
    }
    
    /* Smart label positioning */
    .dendrogram-text.smart-positioned {
        opacity: 0.9;
    }
    
    .dendrogram-text.priority-high {
        font-weight: 600;
        opacity: 1;
    }
    
    .dendrogram-text.priority-medium {
        opacity: 0.8;
    }
    
    .dendrogram-text.priority-low {
        opacity: 0.6;
    }
    
    /* Hide text for very deep nodes */
    .dendrogram-text.depth-hidden {
        display: none;
    }
    

    
    /* Progressive text sizing by depth */
    .dendrogram-text.depth-0 { font-size: 12px; }
    .dendrogram-text.depth-1 { font-size: 11px; }
    .dendrogram-text.depth-2 { font-size: 10px; }
    .dendrogram-text.depth-3 { font-size: 9px; }
    .dendrogram-text.depth-4 { font-size: 8px; }
    .dendrogram-text.depth-5 { font-size: 7px; }
    
    /* High priority nodes get slightly larger text at each depth */
    .dendrogram-text.priority-high.depth-0 { font-size: 14px; }
    .dendrogram-text.priority-high.depth-1 { font-size: 12px; }
    .dendrogram-text.priority-high.depth-2 { font-size: 11px; }
    .dendrogram-text.priority-high.depth-3 { font-size: 10px; }
    .dendrogram-text.priority-high.depth-4 { font-size: 9px; }
    .dendrogram-text.priority-high.depth-5 { font-size: 8px; }
</style>
{% endblock %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-12">
        <div class="card">
            <div class="card-header bg-purple text-white" style="background: linear-gradient(45deg, #6f42c1, #e83e8c);">
                <h2 class="card-title h4 mb-0">
                    <i class="bi bi-archive"></i> Tree Artifacts Explorer
                    <span class="artifact-badge">SAVED TREES</span>
                </h2>
                <small>View and edit saved hierarchical clustering trees from cluster analysis</small>
            </div>
            <div class="card-body">
                
                <!-- Artifact Selection -->
                <div class="artifact-selection-container">
                    <!-- Collapsed Title (visible when collapsed) -->
                    <div class="collapsed-title" id="collapsed-title">
                        <button class="btn btn-link p-0 text-decoration-none" type="button" data-bs-toggle="collapse" data-bs-target="#artifact-selection" aria-expanded="false" aria-controls="artifact-selection">
                            <small class="text-muted">
                                <i class="bi bi-chevron-right me-1"></i>
                                📂 Saved Artifacts
                            </small>
                        </button>
                    </div>
                    
                    <!-- Expanded Content (collapsed by default) -->
                    <div class="collapse" id="artifact-selection">
                        <div class="clustering-controls">
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <h4 class="text-purple mb-0" style="color: #6f42c1;">📂 Saved Artifacts</h4>
                                <button class="btn btn-link p-0 text-decoration-none" type="button" data-bs-toggle="collapse" data-bs-target="#artifact-selection" aria-expanded="true" aria-controls="artifact-selection">
                                    <i class="bi bi-chevron-up text-muted"></i>
                                </button>
                            </div>
                            <div class="row align-items-center">
                                <div class="col-md-6">
                                    <div class="mb-3">
                                        <label for="artifact-selector" class="form-label"><strong>Select Artifact:</strong></label>
                                        <select class="form-select form-select-lg" id="artifact-selector">
                                            <option value="">Loading artifacts...</option>
                                        </select>
                                        <div class="form-text">
                                            Choose a saved tree to view and edit
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="col-md-3">
                                    <div class="mb-3">
                                        <label class="form-label d-block">&nbsp;</label>
                                        <button id="load-artifact-btn" class="btn btn-purple btn-lg w-100" style="background: linear-gradient(45deg, #6f42c1, #e83e8c); border: none;" disabled>
                                            📂 Load Artifact
                                        </button>
                                    </div>
                                </div>
                                
                                <div class="col-md-3">
                                    <div class="mb-3">
                                        <label class="form-label d-block">&nbsp;</label>
                                        <button id="delete-artifact-btn" class="btn btn-outline-danger btn-lg w-100" disabled>
                                            <i class="bi bi-trash"></i> Delete
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Artifact Display -->
                <div id="artifact-section" style="display: none;">
                    <!-- Stats Section -->
                    <div id="artifact-stats" class="artifact-info">
                        <!-- Stats will be populated here -->
                    </div>
                    
                    <!-- Hierarchical Tree Container -->
                    <div class="tree-container">
                        <div class="d-flex justify-content-between align-items-center mb-1">
                            <h5 class="mb-0"><i class="bi bi-diagram-2"></i> Hierarchical Tree (Editable)</h5>
                            <div>
                                <button id="expand-all-btn" class="btn btn-outline-secondary btn-sm me-2">
                                    <i class="bi bi-arrows-expand"></i> Expand All
                                </button>
                                <button id="collapse-all-btn" class="btn btn-outline-secondary btn-sm me-2">
                                    <i class="bi bi-arrows-collapse"></i> Collapse All
                                </button>
                                <button id="view-dendrogram-btn" class="btn btn-outline-primary btn-sm me-2">
                                    <i class="bi bi-diagram-3"></i> View Dendrogram
                                </button>
                                <button id="view-archived-btn" class="archive-btn me-2" title="View archived learning goals">
                                    <i class="bi bi-archive"></i> Archived
                                </button>
                                <button id="save-changes-btn" class="btn btn-success btn-sm">
                                    <i class="bi bi-save"></i> Save Changes
                                </button>
                            </div>
                        </div>
                        
                        <!-- Search Container -->
                        <div class="search-container">
                            <i class="bi bi-search search-icon"></i>
                            <input type="text" class="search-input" id="tree-search" placeholder="Search clusters and learning goals..." autocomplete="off">
                            <button class="search-clear" id="search-clear" title="Clear search">
                                <i class="bi bi-x"></i>
                            </button>
                            <div class="search-results-info" id="search-results-info"></div>
                        </div>
                        
                        <!-- Level Flattening Controls -->
                        <div id="level-controls" class="mb-3">
                            <div class="d-flex align-items-center gap-2 flex-wrap">
                                <span class="fw-bold text-muted">Flatten at Level:</span>
                                <div id="level-buttons" class="btn-group" role="group">
                                    <!-- Level buttons will be populated here -->
                                </div>
                                <button id="show-tree-btn" class="btn btn-outline-primary btn-sm ms-2" style="display: none;">
                                    <i class="bi bi-diagram-2"></i> Show Tree View
                                </button>
                            </div>
                        </div>
                        
                        <div id="tree-content">
                            <!-- Tree will be populated here -->
                        </div>
                        
                        <!-- Flattened Content (shown when level is selected) -->
                        <div id="flattened-content" style="display: none;">
                            <!-- Flattened view will be populated here -->
                        </div>
                    </div>
                </div>

                <!-- Loading Spinner -->
                <div id="loading-section" class="text-center" style="display: none; padding: 50px;">
                    <div class="spinner-border text-purple" role="status" style="width: 3rem; height: 3rem;">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <h5 class="mt-3">Loading artifact...</h5>
                    <p class="text-muted">Please wait while we load your tree data.</p>
                </div>

                <!-- No Artifacts -->
                <div id="no-artifacts" class="text-center" style="display: none;">
                    <i class="bi bi-archive" style="font-size: 3rem; color: #6c757d;"></i>
                    <h3 class="mt-3">No Artifacts Found</h3>
                    <p class="text-muted">Create some tree artifacts from the <a href="{{ url_for('main.cluster_tree') }}">Cluster Tree</a> page first.</p>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- AI Generation Modal -->
<div class="modal fade" id="aiGenerationModal" tabindex="-1" aria-labelledby="aiGenerationModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="aiGenerationModalLabel">
                    <i class="fa fa-wand-magic-sparkles text-purple"></i> AI Generate Representative Text
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <!-- Model Selection -->
                <div class="mb-3">
                    <label for="ai-model-select" class="form-label"><strong>AI Model:</strong></label>
                    <select class="form-select" id="ai-model-select">
                        <option value="gpt-4o">GPT-4o (Recommended)</option>
                        <option value="gpt-4o-mini">GPT-4o Mini (Faster)</option>
                        <option value="gpt-4o-2024-11-20">GPT-4.1 (Latest)</option>
                    </select>
                </div>
                
                <!-- Prompt Input -->
                <div class="mb-3">
                    <label for="ai-prompt" class="form-label"><strong>Prompt:</strong></label>
                    <textarea class="form-control" id="ai-prompt" rows="3" placeholder="Enter your prompt..."></textarea>
                    <div class="form-text">
                        This prompt will be sent along with all learning goals from the selected region.
                    </div>
                </div>
                
                <!-- Recursive Generation Option -->
                <div class="mb-3">
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="recursive-generation" onchange="updateRecursivePreview()">
                        <label class="form-check-label" for="recursive-generation">
                            <strong>Apply to all nested groups recursively</strong>
                        </label>
                    </div>
                    <div class="form-text">
                        When checked, generates representative text for every collapsible region nested under the selected one.
                    </div>
                    <div id="recursive-warning" class="alert alert-warning mt-2" style="display: none;">
                        <i class="fa fa-exclamation-triangle"></i> 
                        <strong>Warning:</strong> This will run <span id="recursive-count">0</span> AI generation queries.
                        This may take several minutes and consume significant AI credits.
                    </div>
                </div>
                
                <!-- Learning Goals Preview -->
                <div class="mb-3">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <label class="form-label mb-0"><strong>Learning Goals Context:</strong></label>
                        <button type="button" class="btn btn-sm btn-outline-secondary" id="toggle-goals-preview">
                            <i class="bi bi-chevron-down"></i> Show Goals
                        </button>
                    </div>
                    <div id="goals-preview" class="goal-preview" style="display: none;">
                        <!-- Goals will be populated here -->
                    </div>
                    <div class="form-text">
                        <span id="goals-count">0</span> learning goals will be included as context<span id="recursive-context-info"></span>.
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-purple" id="generate-ai-text" style="background: linear-gradient(45deg, #6f42c1, #e83e8c); border: none;">
                    <i class="fa fa-wand-magic-sparkles"></i> Generate
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Move Modal -->
<div class="modal fade move-modal" id="moveModal" tabindex="-1" aria-labelledby="moveModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="moveModalLabel">
                    <i class="bi bi-arrow-left-right text-info"></i> Move Learning Goal
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <!-- Move Description -->
                <div class="mb-3" id="move-description">
                    <!-- Description will be populated here -->
                </div>
                
                <!-- Search Box -->
                <div class="mb-3" id="existing-destinations-section">
                    <div class="d-flex align-items-center mb-2">
                        <strong>Move to existing group:</strong>
                    </div>
                    <input type="text" class="move-search-input" id="move-search" placeholder="Search destination groups by name..." autocomplete="off">
                    <div class="form-text">
                        Type to search group names. Click the <i class="bi bi-info-circle" style="font-size: 0.8em;"></i> icon next to any group to see its full path.
                    </div>
                </div>
                
                <!-- Destination Tree -->
                <div class="move-destination-tree" id="move-destination-tree">
                    <!-- Tree will be populated here -->
                </div>
                
                <!-- Create New Group Option (at bottom) -->
                <div class="mt-4 pt-3 border-top">
                    <div class="d-flex align-items-center justify-content-center gap-2">
                        <button type="button" class="btn btn-link btn-sm text-muted" id="create-new-group-btn" onclick="toggleCreateNewGroup()" style="text-decoration: none; font-size: 0.85em;">
                            <i class="bi bi-plus-circle-dotted"></i> Create new group instead
                        </button>
                        <button type="button" class="btn btn-link btn-sm text-muted p-0" onclick="showCreateGroupInfo()" title="Learn more about creating new groups">
                            <i class="bi bi-info-circle" style="font-size: 0.8em;"></i>
                        </button>
                    </div>
                </div>
                
                <!-- New Group Creation Panel (hidden by default) -->
                <div id="create-new-group-panel" style="display: none;">
                    <hr class="my-3">
                    <div class="alert alert-info">
                        <strong>Creating new group:</strong> "<em id="new-group-name-preview"></em>"<br>
                        <small>Navigate to the group that contains existing groups, then select where to add the new group:</small>
                    </div>
                    
                    <!-- Hierarchical Tree Selector -->
                    <div class="new-group-tree-selector mb-3" id="new-group-tree-selector">
                        <!-- Hierarchical tree will be populated here -->
                    </div>
                    
                    <div class="text-center mb-3">
                        <button type="button" class="btn btn-success btn-sm" id="create-and-move-btn" onclick="createNewGroupAndMove()" disabled>
                            <i class="bi bi-plus-circle"></i> Create Group & Move Goal
                        </button>
                        <button type="button" class="btn btn-outline-secondary btn-sm ms-2" onclick="toggleCreateNewGroup()">
                            Cancel
                        </button>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
            </div>
        </div>
    </div>
</div>

<!-- Archive Modal -->
<div class="modal fade" id="archiveModal" tabindex="-1" aria-labelledby="archiveModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="archiveModalLabel">
                    <i class="bi bi-archive text-secondary"></i> Archived Learning Goals
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <small class="text-muted">
                        These learning goals have been deleted but are preserved for reference. You can restore them if needed.
                    </small>
                </div>
                
                <div class="archived-goals-container" id="archived-goals-container">
                    <!-- Archived goals will be populated here -->
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Dendrogram Modal -->
<div class="modal fade" id="dendrogramModal" tabindex="-1" aria-labelledby="dendrogramModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-fullscreen">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="dendrogramModalLabel">
                    <i class="bi bi-diagram-3 text-primary"></i> Interactive Dendrogram View
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body p-0">
                <!-- Dendrogram Controls -->
                <div class="dendrogram-controls bg-light border-bottom p-3">
                    <div class="row align-items-center">

                        <div class="col-md-4">
                            <label for="dendrogram-layout" class="form-label mb-1"><strong>Layout:</strong></label>
                            <select class="form-select form-select-sm" id="dendrogram-layout">
                                <option value="horizontal">Horizontal</option>
                                <option value="vertical" selected>Vertical</option>
                                <option value="radial">Radial</option>
                            </select>
                        </div>
                        <div class="col-md-4">
                            <label for="dendrogram-labels" class="form-label mb-1"><strong>Labels:</strong></label>
                            <select class="form-select form-select-sm" id="dendrogram-labels">
                                <option value="cluster">Cluster Names</option>
                                <option value="representative" selected>Representative Text</option>
                                <option value="both">Both</option>
                                <option value="smart">Smart (Adaptive)</option>
                                <option value="none">None</option>
                            </select>
                        </div>
                        <div class="col-md-4">
                            <div class="d-flex gap-2 align-items-end">
                                <button id="dendrogram-focus-home" class="btn btn-outline-info btn-sm">
                                    <i class="bi bi-house"></i> Focus Home
                                </button>
                                <button id="dendrogram-reset" class="btn btn-outline-secondary btn-sm">
                                    <i class="bi bi-arrow-clockwise"></i> Reset View
                                </button>
                                <button id="dendrogram-export" class="btn btn-outline-primary btn-sm">
                                    <i class="bi bi-download"></i> Export SVG
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Focus Breadcrumb -->
                <div id="dendrogram-breadcrumb" class="bg-white border-bottom p-2" style="display: none;">
                    <div class="d-flex align-items-center gap-2">
                        <small class="text-muted">Focus:</small>
                        <div id="breadcrumb-path" class="d-flex align-items-center gap-1">
                            <!-- Breadcrumb items will be populated here -->
                        </div>
                    </div>
                </div>
                
                <!-- Dendrogram Container -->
                <div id="dendrogram-container" class="position-relative" style="height: calc(100vh - 230px); overflow: hidden;">
                    <div id="dendrogram-svg-container" style="width: 100%; height: 100%;"></div>
                    
                    <!-- Loading Overlay -->
                    <div id="dendrogram-loading" class="position-absolute top-50 start-50 translate-middle text-center" style="display: none;">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <div class="mt-2">Building dendrogram...</div>
                    </div>
                    
                    <!-- Node Details Tooltip -->
                    <div id="dendrogram-tooltip" class="position-absolute bg-dark text-white p-2 rounded shadow" style="display: none; pointer-events: none; z-index: 1000; max-width: 300px; font-size: 0.8em;">
                        <div id="tooltip-content"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Progress Overlay -->
<div id="operation-progress" class="operation-progress" style="display: none;">
    <div class="spinner-border text-primary" role="status">
        <span class="visually-hidden">Loading...</span>
    </div>
    <div class="operation-progress-text" id="progress-text">
        Processing...
    </div>
    <div class="operation-progress-details" id="progress-details">
        Please wait while we update the tree structure.
    </div>
</div>

{% endblock %}

{% block scripts %}
<script src="{{ url_for('static', filename='lock-manager.js') }}"></script>
<script>
// Global variables
let currentArtifact = null;
let currentArtifactId = null;
let availableArtifacts = [];
let flattenedAtLevel = null;
let currentAINodeId = null;

// Performance optimization - cache flattened views
let flattenedCache = {};

// NEW: store flattened cluster data for current view
let currentFlattenedData = [];

// Move/Delete variables
let currentMoveNodeId = null;
let currentMoveType = null; // 'node' or 'goal'
let currentMoveGoalIndex = null;
let searchTimeout = null;

// New group creation variables
let selectedNewGroupLocation = null;
let currentNewGroupName = null;

// Fix for total goals display issue - detects and corrects extra trailing zeros
function fixTotalGoals(totalGoalsValue, treeStructure = null) {
    let fixed = 0;
    
    // Convert to string first to handle both string and number inputs
    let totalStr = String(totalGoalsValue || '0');
    
    // Remove any non-digit characters
    totalStr = totalStr.replace(/\D/g, '');
    
    if (totalStr === '') return 0;
    
    // Parse as integer
    let total = parseInt(totalStr);
    
    // If we have tree structure, count the actual goals to validate
    if (treeStructure && Array.isArray(treeStructure)) {
        const actualCount = countTotalGoalsInTree(treeStructure);
        
        // If the parsed total ends with 0 and removing it gives us the actual count
        if (totalStr.endsWith('0')) {
            const withoutLastZero = parseInt(totalStr.slice(0, -1));
            if (withoutLastZero === actualCount) {
                console.log(`🔧 Fixed total goals: ${total} → ${withoutLastZero} (matched actual count)`);
                return withoutLastZero;
            }
        }
        
        // If the actual count matches exactly, use it
        if (total !== actualCount && actualCount > 0) {
            console.log(`🔧 Using actual goal count: ${total} → ${actualCount}`);
            return actualCount;
        }
    }
    
    // Fallback pattern detection: if number ends with 0 and is suspiciously round
    if (totalStr.endsWith('0') && total > 100) {
        const withoutLastZero = parseInt(totalStr.slice(0, -1));
        // Check if removing the last zero gives a more reasonable number
        // (This is a heuristic for the specific "6485" -> "64850" issue)
        if (withoutLastZero > 0 && withoutLastZero < total * 0.5) {
            console.log(`🔧 Detected extra trailing zero: ${total} → ${withoutLastZero}`);
            return withoutLastZero;
        }
    }
    
    return total;
}

// Helper function to count actual goals in tree structure
function countTotalGoalsInTree(nodes) {
    let count = 0;
    
    function countInNode(node) {
        if (node.goals && Array.isArray(node.goals)) {
            count += node.goals.length;
        }
        if (node.children && node.children.length > 0) {
            node.children.forEach(child => countInNode(child));
        }
    }
    
    if (Array.isArray(nodes)) {
        nodes.forEach(node => countInNode(node));
    }
    
    return count;
}

$(document).ready(function() {
    // Load available artifacts on page load
    loadAvailableArtifacts();
    
    // Handle collapse/expand of artifact selection
    $('#artifact-selection').on('show.bs.collapse', function() {
        $('#collapsed-title').addClass('hidden');
    });
    
    $('#artifact-selection').on('hide.bs.collapse', function() {
        $('#collapsed-title').removeClass('hidden');
    });
    
    // Artifact selector change handler
    $('#artifact-selector').change(function() {
        const selectedId = $(this).val();
        $('#load-artifact-btn').prop('disabled', !selectedId);
        $('#delete-artifact-btn').prop('disabled', !selectedId);
    });
    
    // Load artifact button handler
    $('#load-artifact-btn').click(function() {
        const selectedId = $('#artifact-selector').val();
        if (selectedId) {
            loadArtifact(selectedId);
        }
    });
    
    // Delete artifact button handler
    $('#delete-artifact-btn').click(function() {
        const selectedId = $('#artifact-selector').val();
        if (selectedId && confirm('Are you sure you want to delete this artifact? This action cannot be undone.')) {
            deleteArtifact(selectedId);
        }
    });
    
    // Tree control buttons
    $('#expand-all-btn').click(expandAll);
    $('#collapse-all-btn').click(collapseAll);
    $('#save-changes-btn').click(saveChanges);
    $('#show-tree-btn').click(showTreeView);
    
    // AI Generation Modal handlers
    $('#toggle-goals-preview').click(function() {
        const preview = $('#goals-preview');
        const btn = $(this);
        const icon = btn.find('i');
        
        if (preview.is(':visible')) {
            preview.slideUp();
            icon.removeClass('bi-chevron-up').addClass('bi-chevron-down');
            btn.html('<i class="bi bi-chevron-down"></i> Show Goals');
        } else {
            preview.slideDown();
            icon.removeClass('bi-chevron-down').addClass('bi-chevron-up');
            btn.html('<i class="bi bi-chevron-up"></i> Hide Goals');
        }
    });
    
    $('#generate-ai-text').click(function() {
        generateAIText();
    });
    
    // Move/Delete/Archive handlers
    $('#view-archived-btn').click(function() {
        loadArchivedGoals();
    });
    
    // View dendrogram handler
    $('#view-dendrogram-btn').click(function() {
        if (currentArtifact && currentArtifact.tree_structure) {
            showDendrogram();
        } else {
            alert('No tree data available for dendrogram view.');
        }
    });
    
    // Move modal search functionality with debouncing
    $('#move-search').on('input', function() {
        const searchTerm = $(this).val();
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
            filterMoveDestinations(searchTerm);
        }, 300); // 300ms debounce
    });
    
    // Tree search functionality
    let treeSearchTimeout = null;
    $('#tree-search').on('input', function() {
        const searchTerm = $(this).val();
        clearTimeout(treeSearchTimeout);
        
        // Show/hide clear button
        if (searchTerm.trim()) {
            $('#search-clear').show();
        } else {
            $('#search-clear').hide();
        }
        
        treeSearchTimeout = setTimeout(() => {
            performTreeSearch(searchTerm);
        }, 300); // 300ms debounce
    });
    
    // Clear search button
    $('#search-clear').click(function() {
        $('#tree-search').val('');
        $('#search-clear').hide();
        clearTreeSearch();
    });
    
    // Hide tooltips when clicking elsewhere
    $(document).on('click', function() {
        $('.path-tooltip').fadeOut(200, function() {
            $(this).remove();
        });
    });
});

function loadAvailableArtifacts() {
    // Show loading spinner with better messaging
    $('#loading-section').show();
    $('#artifact-section').hide();
    $('#no-artifacts').hide();
    $('#loading-section h5').text('Loading artifacts list...');
    
    $.get('/api/get-artifacts')
        .done(function(response) {
            if (response.success && response.artifacts.length > 0) {
                availableArtifacts = response.artifacts;
                
                // Populate artifact selector
                let optionsHtml = '<option value="">Select an artifact...</option>';
                response.artifacts.forEach(artifact => {
                    const date = new Date(artifact.created_at).toLocaleDateString();
                    const fixedGoals = fixTotalGoals(artifact.total_goals);
                    optionsHtml += `<option value="${artifact.id}">${artifact.name} (${fixedGoals} goals, ${date})</option>`;
                });
                
                $('#artifact-selector').html(optionsHtml);
                
                // Auto-load the first artifact
                const firstArtifactId = response.artifacts[0].id;
                $('#artifact-selector').val(firstArtifactId);
                $('#load-artifact-btn').prop('disabled', false);
                $('#delete-artifact-btn').prop('disabled', false);
                
                // Load the first artifact automatically
                loadArtifact(firstArtifactId);
                
            } else {
                $('#loading-section').hide();
                $('#artifact-selector').html('<option value="">No artifacts found</option>');
                $('#no-artifacts').show();
            }
        })
        .fail(function() {
            $('#loading-section').hide();
            $('#artifact-selector').html('<option value="">Error loading artifacts</option>');
            $('#no-artifacts').show();
        });
}

function loadArtifact(artifactId) {
    currentArtifactId = artifactId;
    
    // Clear cache when loading a new artifact
    flattenedCache = {};
    
    // Update loading message
    $('#loading-section h5').text('Loading artifact data...');
    $('#loading-section p').text('Downloading tree structure and goals...');
    
    $.get(`/api/get-artifact/${artifactId}`)
        .done(function(response) {
            if (response.success) {
                currentArtifact = response.artifact;
                
                // Update loading message for tree building
                $('#loading-section h5').text('Building tree display...');
                $('#loading-section p').text('Preparing interactive tree view...');
                
                // Use setTimeout to let the loading message update before heavy work
                setTimeout(() => {
                    try {
                        displayArtifact(currentArtifact);
                        $('#loading-section').hide();
                    } catch (error) {
                        console.error('Error displaying artifact:', error);
                        $('#loading-section').hide();
                        alert('Error loading artifact display. Please try again.');
                    }
                }, 10);
            } else {
                $('#loading-section').hide();
                alert('Failed to load artifact: ' + response.message);
            }
        })
        .fail(function() {
            $('#loading-section').hide();
            alert('Failed to load artifact: Network error');
        });
}

function displayArtifact(artifact) {
    $('#no-artifacts').hide();
    $('#artifact-section').show();
    
    // Clear any previous search state
    $('#tree-search').val('');
    $('#search-clear').hide();
    clearTreeSearch();
    
    // Display stats
    displayStats(artifact);
    
    // Display tree using the updated functions
    displayTree(artifact.tree_structure);
    
    console.log('Artifact loaded:', artifact.name);
}

function displayStats(artifact) {
    // Use the new fixTotalGoals function to handle the extra "0" issue
    const totalGoals = fixTotalGoals(artifact.total_goals, artifact.tree_structure);
    
    console.log('🔍 DEBUG - Original artifact.total_goals:', artifact.total_goals, typeof artifact.total_goals);
    console.log('🔍 DEBUG - Fixed totalGoals:', totalGoals);
    
    const statsHtml = `
        <span class="artifact-name">Artifact: ${artifact.name}</span>
        <span class="artifact-details">
            <span>Total Goals: ${totalGoals}</span>
            <span>Parameters: ${artifact.parameter_summary}</span>
            <span>Created: ${new Date(artifact.created_at).toLocaleDateString()}</span>
            <span>Modified: ${new Date(artifact.modified_at).toLocaleDateString()}</span>
        </span>
    `;
    $('#artifact-stats').html(statsHtml);
}

function displayTree(treeStructure) {
    // Clear any flattened level selection when showing tree view
    flattenedAtLevel = null;
    
    // For large trees, show progress during tree building
    const totalNodes = countTotalNodes(treeStructure);
    const isLargeTree = totalNodes > 100; // Threshold for showing progress
    
    if (isLargeTree) {
        showProgress('Building Tree...', `Processing ${totalNodes} groups and goals...`);
        
        // Use setTimeout to let progress show before heavy work
        setTimeout(() => {
            try {
                buildAndDisplayTree(treeStructure);
            } catch (error) {
                console.error('Error building tree:', error);
                alert('Error building tree display. Please try again.');
            } finally {
                hideProgress();
            }
        }, 10);
    } else {
        // Small trees can be built immediately
        buildAndDisplayTree(treeStructure);
    }
}

function buildAndDisplayTree(treeStructure) {
    // Generate level buttons
    generateLevelButtons(treeStructure);

    // Build skeleton for root nodes only
    const skeletonHtml = treeStructure.map(node => buildTreeNodeSkeleton(node, 0)).join('');
    $('#tree-content').html(skeletonHtml);

    // Show tree view
    $('#tree-content').show();
    $('#flattened-content').hide();
    $('#show-tree-btn').hide();
    
    // Reapply lock state to newly created elements
    if (window.lockManager) {
        window.lockManager.forceReapplyLockState();
    }
}



function countTotalNodes(nodes) {
    let count = 0;
    
    function countInNode(node) {
        count += 1;
        if (node.children && node.children.length > 0) {
            node.children.forEach(child => countInNode(child));
        }
    }
    
    if (Array.isArray(nodes)) {
        nodes.forEach(node => countInNode(node));
    }
    
    return count;
}

function generateLevelButtons(nodes) {
    const maxDepth = findMaxDepth(nodes);
    let buttonsHtml = '';
    
    for (let level = 0; level <= maxDepth; level++) {
        const levelLabel = String.fromCharCode(65 + level); // A, B, C, etc.
        const groupCount = countGroupsAtLevel(nodes, level);
        const totalGoals = countGoalsAtLevel(nodes, level);
        const avgGoalsPerGroup = groupCount > 0 ? Math.round(totalGoals / groupCount) : 0;
        
        buttonsHtml += `
            <button class="btn btn-outline-secondary level-button" data-level="${level}">
                <strong>${levelLabel}</strong>
                <small>${groupCount} groups</small>
                <small style="font-size: 0.65em; opacity: 0.8;">${avgGoalsPerGroup} avg goals</small>
            </button>
        `;
    }
    
    $('#level-buttons').html(buttonsHtml);
    
    // Add click handlers
    $('.level-button').click(function() {
        const level = parseInt($(this).data('level'));
        flattenAtLevel(level);
    });
}

function countGroupsAtLevel(nodes, targetLevel, currentLevel = 0) {
    let count = 0;
    nodes.forEach(node => {
        if (currentLevel === targetLevel) {
            count += 1; // Count this group
        } else if (node.children && node.children.length > 0 && currentLevel < targetLevel) {
            count += countGroupsAtLevel(node.children, targetLevel, currentLevel + 1);
        }
    });
    return count;
}

function findMaxDepth(nodes, currentDepth = 0) {
    let maxDepth = currentDepth;
    nodes.forEach(node => {
        if (node.children && node.children.length > 0) {
            maxDepth = Math.max(maxDepth, findMaxDepth(node.children, currentDepth + 1));
        }
    });
    return maxDepth;
}

function countGoalsAtLevel(nodes, targetLevel, currentLevel = 0) {
    let count = 0;
    nodes.forEach(node => {
        if (currentLevel === targetLevel) {
            count += countAllGoalsInSubtree(node);
        } else if (node.children && node.children.length > 0 && currentLevel < targetLevel) {
            count += countGoalsAtLevel(node.children, targetLevel, currentLevel + 1);
        }
    });
    return count;
}

function countAllGoalsInSubtree(node) {
    let count = (node.goals || []).length;
    if (node.children) {
        node.children.forEach(child => {
            count += countAllGoalsInSubtree(child);
        });
    }
    return count;
}

function buildTreeNode(node, level = 0) {
    const levelClass = level <= 10 ? `tree-level-${level}` : 'tree-level-deep';
    const hasChildren = node.children && node.children.length > 0;
    const hasGoals = node.goals && node.goals.length > 0;
    
    // Get representative text and determine state
    let representativeText = node.representative_goal || '';
    let textState = node.text_state || 'default';
    let aiPrompt = node.ai_prompt || '';
    
    // Get appropriate icon based on state
    let stateIcon = 'fa-quote-left'; // default
    if (textState === 'manual') {
        stateIcon = 'fa-pencil';
    } else if (textState === 'ai') {
        stateIcon = 'fa-wand-magic-sparkles';
    }
    
    // If no representative text, create one from goals
    if (!representativeText && hasGoals) {
        representativeText = node.goals.reduce((longest, current) => 
            current.length > longest.length ? current : longest
        );
    } else if (!representativeText && hasChildren) {
        representativeText = findRepresentativeGoal(node);
    }
    
    let nodeHtml = `<div class="tree-node ${levelClass}" data-level="${level}" data-node-id="${node.id}">`;
    
    // Check if this node represents no subdivision
    const isNoSubdivision = hasChildren && node.children.length === 1 && 
                           node.children[0].size === node.size;
    const subdivisionClass = isNoSubdivision ? ' no-subdivision' : '';
    
    // NEW LAYOUT: [Large Black Text][Icon][Auto-Gen Button][Small Gray Label][Size]
    nodeHtml += `
        <div class="cluster-header${subdivisionClass}" onclick="toggleCluster('${node.id}')">
            ${hasChildren ? '<i class="bi bi-chevron-right collapse-icon"></i>' : '<i class="bi bi-circle-fill collapse-icon" style="font-size: 0.5em;"></i>'}
            
            <div class="cluster-representative" 
                 contenteditable="true"
                 data-state="${textState}"
                 onclick="event.stopPropagation(); startEditing(this)"
                 onblur="saveRepresentativeText(this, '${node.id}')"
                 onkeydown="handleRepresentativeKeydown(event, this, '${node.id}')">
                <i class="fa ${stateIcon} text-state-icon"></i>
                <span class="representative-text">${representativeText}</span>
            </div>
            
            <button class="auto-generate-btn" onclick="event.stopPropagation(); openAIGenerationModal('${node.id}')" title="Generate with AI">
                <i class="fa fa-wand-magic-sparkles"></i>
            </button>
            
            <span class="cluster-label">${node.label}</span>
            <span class="cluster-size">${node.size || 0}</span>
        </div>
    `;
    
    // Cluster content (goals for leaf nodes, children for branch nodes)
    if ((hasGoals || hasChildren) && (hasGoals || node.size > 0)) {
        nodeHtml += `<div class="cluster-content" id="content-${node.id}" style="display: none;">`;
        
        if (hasGoals) {
            node.goals.forEach(function(goal, index) {
                const source = node.sources ? node.sources[index] : {};
                nodeHtml += `
                    <div class="goal-item" data-goal-index="${index}">
                        <div class="d-flex justify-content-between align-items-start">
                            <div class="flex-grow-1">
                                <div class="goal-text">"${goal}"</div>
                                                        <div class="goal-source">
                            📄 <span class="document-link" onclick="openDocumentModal('${source.document_name || 'Unknown'}', '${source.creator || 'Unknown'}')" title="Click to view document">${truncateText(source.document_name || 'Unknown', 25)}</span> | 
                            👤 ${truncateText(source.creator || 'Unknown', 15)}
                            ${source.course_name ? ` | 📚 ${truncateText(source.course_name, 20)}` : ''}
                            ${source.institution ? ` | 🏛️ ${truncateText(source.institution, 20)}` : ''}
                        </div>
                            </div>
                            <div class="goal-actions">
                                <button class="goal-move-btn" onclick="openMoveModal('${node.id}', 'goal', ${index})" title="Move this learning goal">
                                    ↔
                                </button>
                                <button class="goal-delete-btn" onclick="deleteGoal('${node.id}', ${index})" title="Delete this learning goal">
                                    🗑
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            });
        }
        
        if (hasChildren) {
            node.children.forEach(child => {
                nodeHtml += buildTreeNode(child, level + 1);
            });
        }
        
        nodeHtml += `</div>`;
    }
    
    nodeHtml += `</div>`;
    return nodeHtml;
}

function findRepresentativeGoal(node) {
    // Recursively find a representative goal from children
    if (node.goals && node.goals.length > 0) {
        return node.goals.reduce((longest, current) => 
            current.length > longest.length ? current : longest
        );
    }
    
    if (node.children) {
        for (let child of node.children) {
            const childRep = findRepresentativeGoal(child);
            if (childRep) return childRep;
        }
    }
    
    return '';
}

function truncateText(text, maxLength) {
    if (!text) return '';
    return text.length <= maxLength ? text : text.substring(0, maxLength - 3) + '...';
}

function startEditing(element) {
    $(element).addClass('editing');
    // Don't interfere with the browser's natural cursor placement
    // The contenteditable element will handle cursor positioning automatically
}

function editRepresentativeText(element) {
    $(element).addClass('editing');
    
    // Don't auto-select all text - let the user click where they want to edit
    // Just ensure the element is focused
    element.focus();
    
    // If the user wants to select all, they can use Ctrl+A
    // For now, just place the cursor at the end if no selection is made
    setTimeout(() => {
        if (window.getSelection().toString() === '') {
            // No text is selected, place cursor at click position
            // The browser will naturally handle this when we don't interfere
        }
    }, 10);
}

function saveRepresentativeText(element, nodeId) {
    $(element).removeClass('editing');
    const textSpan = $(element).find('.representative-text');
    const newText = textSpan.text().trim();
    
    if (!newText) {
        alert('Representative text cannot be empty');
        return;
    }
    
    // Update the state to manual and change icon
    const icon = $(element).find('.text-state-icon');
    icon.removeClass('fa-quote-left fa-wand-magic-sparkles').addClass('fa-pencil');
    
    // Set data-state attribute to manual
    $(element).attr('data-state', 'manual');
    
    // Mark as changed for saving later
    element.setAttribute('data-changed', 'true');
    element.style.backgroundColor = '#fff3cd'; // Light yellow to indicate unsaved changes
}

function handleRepresentativeKeydown(event, element, nodeId) {
    if (event.key === 'Enter') {
        event.preventDefault();
        element.blur();
    } else if (event.key === 'Escape') {
        // Restore original text (would need to be stored)
        element.blur();
    }
}

function openAIGenerationModal(nodeId) {
    currentAINodeId = nodeId;
    
    // Find the node in the current artifact
    const node = findNodeById(currentArtifact.tree_structure, nodeId);
    if (!node) {
        alert('Node not found');
        return;
    }
    
    // Set default prompt or use saved prompt
    const defaultPrompt = "Please provide a brief overarching learning goal (or skill) that encapsulates, specifically all of the learning goals or skills in the list below.";
    const savedPrompt = node.ai_prompt || defaultPrompt;
    $('#ai-prompt').val(savedPrompt);
    
    // Reset recursive checkbox
    $('#recursive-generation').prop('checked', false);
    
    // Collect all goals from this region
    const allGoals = collectAllGoalsFromNode(node);
    
    // Populate goals preview
    let goalsHtml = '';
    allGoals.forEach((goalData, index) => {
        goalsHtml += `
            <div class="goal-preview-item">
                <div class="goal-preview-text">"${goalData.goal}"</div>
                <div class="goal-preview-source">
                    📄 ${goalData.source.document_name || 'Unknown'} | 
                    👤 ${goalData.source.creator || 'Unknown'}
                    ${goalData.source.course_name ? ` | 📚 ${goalData.source.course_name}` : ''}
                </div>
            </div>
        `;
    });
    
    $('#goals-preview').html(goalsHtml);
    $('#goals-count').text(allGoals.length);
    
    // Update recursive preview
    updateRecursivePreview();
    
    // Show the modal
    $('#aiGenerationModal').modal('show');
}

function findNodeById(nodes, targetId) {
    for (let node of nodes) {
        if (node.id === targetId) {
            return node;
        }
        if (node.children) {
            const found = findNodeById(node.children, targetId);
            if (found) return found;
        }
    }
    return null;
}

function collectAllGoalsFromNode(node) {
    let allGoals = [];
    
    // Add goals from this node
    if (node.goals) {
        node.goals.forEach((goal, index) => {
            const source = node.sources ? node.sources[index] : {};
            allGoals.push({
                goal: goal,
                source: source
            });
        });
    }
    
    // Add goals from children recursively
    if (node.children) {
        node.children.forEach(child => {
            allGoals = allGoals.concat(collectAllGoalsFromNode(child));
        });
    }
    
    return allGoals;
}

function generateAIText() {
    const model = $('#ai-model-select').val();
    const prompt = $('#ai-prompt').val().trim();
    const isRecursive = $('#recursive-generation').is(':checked');
    
    if (!prompt) {
        alert('Please enter a prompt');
        return;
    }
    
    if (!currentAINodeId) {
        alert('No node selected');
        return;
    }
    
    // Find the node
    const node = findNodeById(currentArtifact.tree_structure, currentAINodeId);
    if (!node) {
        alert('Node not found');
        return;
    }
    
    if (isRecursive) {
        // Get user confirmation for recursive generation
        const recursiveNodes = collectRecursiveNodes(node);
        const confirmMessage = `This will generate AI text for ${recursiveNodes.length} groups. This may take several minutes and consume significant AI credits. Continue?`;
        
        if (!confirm(confirmMessage)) {
            return;
        }
        
        generateRecursiveAIText(recursiveNodes, model, prompt);
    } else {
        generateSingleAIText(node, model, prompt);
    }
}

function generateSingleAIText(node, model, prompt) {
    const generateBtn = $('#generate-ai-text');
    generateBtn.prop('disabled', true).html('<i class="fa fa-spinner fa-spin"></i> Generating...');
    
    // Collect goals for this node only
    const allGoals = collectAllGoalsFromNode(node);
    const goalsList = allGoals.map(g => `"${g.goal}"`).join('\n');
    const fullPrompt = `${prompt}\n\nLearning goals:\n${goalsList}`;
    
    // Send to API
    $.ajax({
        url: '/api/generate-representative-text',
        method: 'POST',
        contentType: 'application/json',
        data: JSON.stringify({
            artifact_id: currentArtifactId,
            node_id: currentAINodeId,
            prompt: prompt,
            full_prompt: fullPrompt,
            model: model
        })
    })
    .done(function(response) {
        if (response.success) {
            // Update the in-memory artifact data with the saved prompt and generated text
            const node = findNodeById(currentArtifact.tree_structure, currentAINodeId);
            if (node) {
                node.ai_prompt = prompt;
                node.representative_goal = response.generated_text;
                node.text_state = 'ai';
            }
            
            updateNodeUI(currentAINodeId, response.generated_text, 'ai');
            $('#aiGenerationModal').modal('hide');
        } else {
            alert('Failed to generate text: ' + response.message);
        }
    })
    .fail(function() {
        alert('Failed to generate text: Network error');
    })
    .always(function() {
        generateBtn.prop('disabled', false).html('<i class="fa fa-wand-magic-sparkles"></i> Generate');
    });
}

function generateRecursiveAIText(recursiveNodes, model, prompt) {
    const generateBtn = $('#generate-ai-text');
    generateBtn.prop('disabled', true);
    
    let completed = 0;
    let successful = 0;
    let errors = 0;
    const total = recursiveNodes.length;
    
    // Collect all results in memory - NO database saves during generation
    const generatedResults = [];
    const failedNodes = [];
    
    // Add progress indicator to the modal title
    const modalTitle = $('#aiGenerationModalLabel');
    const originalTitle = modalTitle.html();
    
    // Process each node
    recursiveNodes.forEach((nodeData, index) => {
        const goalsList = nodeData.goals.map(g => `"${g.goal}"`).join('\n');
        const fullPrompt = `${prompt}\n\nLearning goals:\n${goalsList}`;
        
        // Update progress in button and modal title
        const progressText = `Generating ${index + 1}/${total}`;
        generateBtn.html(`<i class="fa fa-spinner fa-spin"></i> ${progressText}...`);
        modalTitle.html(`<i class="fa fa-wand-magic-sparkles text-purple"></i> AI Generate - ${progressText}`);
        
        // Small delay between requests to avoid overwhelming the API
        setTimeout(() => {
            $.ajax({
                url: '/api/generate-representative-text',
                method: 'POST',
                contentType: 'application/json',
                data: JSON.stringify({
                    artifact_id: currentArtifactId,
                    node_id: nodeData.id,
                    prompt: prompt,
                    full_prompt: fullPrompt,
                    model: model,
                    skip_save: true  // NEW: Skip individual saves during batch operations
                })
            })
            .done(function(response) {
                if (response.success) {
                    // Store result in memory and update UI immediately
                    generatedResults.push({
                        node_id: nodeData.id,
                        representative_text: response.generated_text,
                        text_state: 'ai',
                        ai_prompt: prompt  // Store the prompt for batch saving
                    });
                    
                    // Update UI immediately for visual feedback
                    updateNodeUI(nodeData.id, response.generated_text, 'ai');
                    successful++;
                } else {
                    failedNodes.push({
                        node_id: nodeData.id,
                        error: response.message
                    });
                    errors++;
                    console.error(`Failed to generate for node ${nodeData.id}:`, response.message);
                }
            })
            .fail(function() {
                failedNodes.push({
                    node_id: nodeData.id,
                    error: 'Network error'
                });
                errors++;
                console.error(`Network error for node ${nodeData.id}`);
            })
            .always(function() {
                completed++;
                
                // Update progress with completion status
                const completedText = `Completed ${completed}/${total} (${successful} successful, ${errors} failed)`;
                generateBtn.html(`<i class="fa fa-spinner fa-spin"></i> ${completedText}`);
                modalTitle.html(`<i class="fa fa-wand-magic-sparkles text-purple"></i> AI Generate - ${completedText}`);
                
                if (completed === total) {
                    // All generations complete - now save everything in one batch
                    if (generatedResults.length > 0) {
                        batchSaveAIResults(generatedResults, originalTitle, modalTitle, generateBtn, successful, errors, total);
                    } else {
                        // No successful results to save
                        setTimeout(() => {
                            modalTitle.html(originalTitle);
                            generateBtn.prop('disabled', false).html('<i class="fa fa-wand-magic-sparkles"></i> Generate');
                            alert(`❌ All generations failed. No changes to save.`);
                        }, 1000);
                    }
                }
            });
        }, index * 500); // 500ms delay between requests
    });
}

function batchSaveAIResults(generatedResults, originalTitle, modalTitle, generateBtn, successful, errors, total) {
    // For recursive generation, individual saves were skipped, so we need to save everything now
    // including the prompts that were used for generation
    
    // Show finalizing progress
    const finalizingText = `Saving ${generatedResults.length} changes...`;
    generateBtn.html(`<i class="fa fa-spinner fa-spin"></i> ${finalizingText}`);
    modalTitle.html(`<i class="fa fa-check-circle text-purple"></i> AI Generate - ${finalizingText}`);
    
    // Prepare updates for batch save (including prompts)
    const updates = generatedResults.map(result => ({
        node_id: result.node_id,
        representative_text: result.representative_text,
        text_state: result.text_state,
        ai_prompt: result.ai_prompt  // Include the prompt that was used
    }));
    
    // Send batch update to save everything including prompts
    $.ajax({
        url: '/api/batch-update-artifact-representative-texts',
        method: 'POST',
        contentType: 'application/json',
        data: JSON.stringify({
            artifact_id: currentArtifactId,
            updates: updates
        })
    })
    .done(function(response) {
        if (response.success) {
            // Update the in-memory artifact data with the saved prompts
            generatedResults.forEach(result => {
                const node = findNodeById(currentArtifact.tree_structure, result.node_id);
                if (node) {
                    node.ai_prompt = result.ai_prompt;
                    node.representative_goal = result.representative_text;
                    node.text_state = result.text_state;
                }
            });
            
            // Clear all change indicators after successful save
            generatedResults.forEach(result => {
                const nodeElements = $(`[data-changed="true"]`).filter(function() {
                    // Check if this element itself has data-node-id (flattened view)
                    // or find it in the closest parent (tree view)
                    let nodeId = $(this).data('node-id');
                    if (!nodeId) {
                        nodeId = $(this).closest('[data-node-id]').data('node-id');
                    }
                    return nodeId === result.node_id;
                });
                nodeElements.each(function() {
                    $(this).removeAttr('data-changed');
                    $(this).css('backgroundColor', '');
                });
            });
            
            // Show final success
            generateBtn.html(`<i class="fa fa-check text-success"></i> All saved successfully!`);
            modalTitle.html(`<i class="fa fa-check text-success"></i> Generation Complete!`);
            
            setTimeout(() => {
                modalTitle.html(originalTitle);
                generateBtn.prop('disabled', false).html('<i class="fa fa-wand-magic-sparkles"></i> Generate');
                $('#aiGenerationModal').modal('hide');
                
                if (errors === 0) {
                    alert(`🎉 Successfully generated and saved text for all ${total} groups!\n\n💾 All results including prompts were saved.`);
                } else {
                    alert(`📊 Generation completed!\n✅ Generated & Saved: ${successful}\n❌ Failed: ${errors}\n📝 Total: ${total}\n\n💾 All successful results including prompts were saved.`);
                }
            }, 1500);
        } else {
            // Save failed
            generateBtn.html(`<i class="fa fa-exclamation-triangle text-warning"></i> Save Failed`);
            modalTitle.html(`<i class="fa fa-exclamation-triangle text-warning"></i> Save Failed`);
            alert('Generated text successfully but failed to save to database: ' + response.message);
            
            setTimeout(() => {
                modalTitle.html(originalTitle);
                generateBtn.prop('disabled', false).html('<i class="fa fa-wand-magic-sparkles"></i> Generate');
            }, 3000);
        }
    })
    .fail(function() {
        // Network error
        generateBtn.html(`<i class="fa fa-times text-danger"></i> Network Error`);
        modalTitle.html(`<i class="fa fa-times text-danger"></i> Network Error`);
        alert('Generated text successfully but failed to save: Network error');
        
        setTimeout(() => {
            modalTitle.html(originalTitle);
            generateBtn.prop('disabled', false).html('<i class="fa fa-wand-magic-sparkles"></i> Generate');
        }, 3000);
    });
}

function updateNodeUI(nodeId, generatedText, state) {
    let nodeElement, textSpan, icon;
    
    if ($('#flattened-content').is(':visible')) {
        // Flattened view is active - find the representative element by node ID
        // We need to find which flattened cluster contains this node ID
        nodeElement = $(`#flattened-content .cluster-representative`).filter(function() {
            // Check if the onblur attribute contains this nodeId
            const onblurAttr = $(this).attr('onblur');
            return onblurAttr && onblurAttr.includes(`'${nodeId}'`);
        });
    } else {
        // Tree view is active - use the existing selector
        nodeElement = $(`.tree-node[data-node-id="${nodeId}"] > .cluster-header > .cluster-representative`);
    }
    
    if (nodeElement.length === 0) {
        console.error(`Could not find node element for ID: ${nodeId}`);
        return;
    }
    
    textSpan = nodeElement.find('.representative-text');
    icon = nodeElement.find('.text-state-icon');
    
    textSpan.text(generatedText);
    icon.removeClass('fa-quote-left fa-pencil').addClass('fa-wand-magic-sparkles');
    
    // Set data-state attribute
    nodeElement.attr('data-state', state);
    
    // Mark as changed for saving
    nodeElement[0].setAttribute('data-changed', 'true');
    nodeElement[0].style.backgroundColor = '#e1f5fe'; // Light blue for AI
}

function collectRecursiveNodes(rootNode) {
    const nodes = [];
    
    function collectNode(node) {
        // Add this node if it has goals or children (any collapsible region)
        const hasChildren = node.children && node.children.length > 0;
        const hasGoals = node.goals && node.goals.length > 0;
        
        if (hasChildren || hasGoals) {
            const allGoals = collectAllGoalsFromNode(node);
            // Only include groups with more than 1 goal (no point generating for single goals)
            if (allGoals.length > 1) {
                nodes.push({
                    id: node.id,
                    label: node.label,
                    goals: allGoals
                });
            }
        }
        
        // Recursively collect from children
        if (hasChildren) {
            node.children.forEach(child => {
                collectNode(child);
            });
        }
    }
    
    collectNode(rootNode);
    return nodes;
}

function updateRecursivePreview() {
    const isRecursive = $('#recursive-generation').is(':checked');
    const warning = $('#recursive-warning');
    const recursiveInfo = $('#recursive-context-info');
    
    if (isRecursive && currentAINodeId) {
        const node = findNodeById(currentArtifact.tree_structure, currentAINodeId);
        if (node) {
            const recursiveNodes = collectRecursiveNodes(node);
            $('#recursive-count').text(recursiveNodes.length);
            warning.show();
            
            // Update context info
            if (recursiveNodes.length > 1) {
                recursiveInfo.text(` (${recursiveNodes.length} total queries)`);
            } else {
                recursiveInfo.text('');
            }
        }
    } else {
        warning.hide();
        recursiveInfo.text('');
    }
}

function flattenAtLevel(level) {
    // Show progress immediately for user feedback
    showProgress('Processing...', `Flattening tree at level ${String.fromCharCode(65 + level)}...`);
    
    // Update button states immediately
    $('.level-button').removeClass('active');
    $(`.level-button[data-level="${level}"]`).addClass('active');
    
    // Use setTimeout to let progress overlay render first
    setTimeout(() => {
        try {
            flattenedAtLevel = level;
            
            // Check cache first
            const cacheKey = `${currentArtifactId}_${level}`;
            if (flattenedCache[cacheKey]) {
                // Use cached version
                $('#flattened-content').html(flattenedCache[cacheKey].html);
                updateDownloadOptions(flattenedCache[cacheKey].flattened);
            } else {
                // Generate flattened view and cache it
                const flattened = flattenTreeAtLevel(currentArtifact.tree_structure, level);
                const html = generateFlattenedHTML(flattened, level);
                
                // Cache the results
                flattenedCache[cacheKey] = { html: html, flattened: flattened };
                
                $('#flattened-content').html(html);
                updateDownloadOptions(flattened);
            }
            
            // Show flattened content, hide tree
            $('#tree-content').hide();
            $('#flattened-content').show();
            $('#show-tree-btn').show();
            
            // Preserve search if active
            const searchTerm = $('#tree-search').val();
            if (searchTerm.trim()) {
                setTimeout(() => {
                    performTreeSearch(searchTerm);
                }, 100); // Small delay to let flattened view render
            }
            
        } catch (error) {
            console.error('Error flattening tree:', error);
            alert('Error processing tree data. Please try again.');
        } finally {
            hideProgress();
        }
    }, 10); // Small delay to let UI update
}

function flattenTreeAtLevel(nodes, targetLevel, currentLevel = 0) {
    let flattened = [];
    
    nodes.forEach(node => {
        if (currentLevel === targetLevel) {
            // Collect all goals from this node and its children, preserving source node info
            const allGoalsWithSource = collectAllGoalsWithSourceFromNode(node);
            if (allGoalsWithSource.length > 0) {
                flattened.push({
                    label: node.label,
                    representative: node.representative_goal || '',
                    goalsWithSource: allGoalsWithSource,
                    size: allGoalsWithSource.length,
                    originalNode: node
                });
            }
        } else if (node.children && node.children.length > 0 && currentLevel < targetLevel) {
            flattened = flattened.concat(flattenTreeAtLevel(node.children, targetLevel, currentLevel + 1));
        }
    });
    
    return flattened;
}

function collectAllGoalsWithSourceFromNode(node) {
    // Collect all goals from this node and its children, preserving which node each goal came from
    let allGoals = [];
    
    // Add goals from this node
    if (node.goals) {
        node.goals.forEach((goal, index) => {
            const source = node.sources ? node.sources[index] : {};
            allGoals.push({
                goal: goal,
                source: source,
                sourceNodeId: node.id,
                originalIndex: index
            });
        });
    }
    
    // Add goals from children recursively
    if (node.children) {
        node.children.forEach(child => {
            allGoals = allGoals.concat(collectAllGoalsWithSourceFromNode(child));
        });
    }
    
    return allGoals;
}

function generateFlattenedHTML(flattened, level) {
    // store globally for lazy loading
    currentFlattenedData = flattened;
    const levelLabel = String.fromCharCode(65 + level);
    const totalGoals = flattened.reduce((sum, cluster) => sum + cluster.size, 0);
    
    let flattenedHtml = `
        <div class="mb-3 d-flex justify-content-between align-items-center">
            <div>
                <h5><i class="bi bi-list-ul"></i> Flattened View - Level ${levelLabel}</h5>
                <small class="text-muted">${flattened.length} clusters, ${totalGoals} total goals</small>
            </div>
            <div class="download-controls">
                <button id="download-csv-btn" class="btn btn-outline-secondary" onclick="downloadFlattenedCSV('${levelLabel}')">
                    <i class="bi bi-download"></i> CSV
                </button>
                <select id="download-column-type" class="form-select">
                    <option value="institution">by Institution</option>
                    <option value="creator">by Creator</option>
                    <option value="course_name">by Course</option>
                </select>
            </div>
        </div>
    `;
    
    flattened.forEach((cluster, index) => {
        const originalNode = cluster.originalNode;
        const representativeText = originalNode.representative_goal || '';
        const textState = originalNode.text_state || 'default';
        let stateIcon = 'fa-quote-left';
        if (textState === 'manual') stateIcon = 'fa-pencil';
        else if (textState === 'ai') stateIcon = 'fa-wand-magic-sparkles';

        flattenedHtml += `
            <div class="flattened-cluster">
                <div class="cluster-header" onclick="toggleFlattenedCluster('flattened-${index}')">
                    <i class="bi bi-chevron-right collapse-icon"></i>
                    <div class="cluster-representative" contenteditable="true" data-state="${textState}" data-node-id="${originalNode.id}" onclick="event.stopPropagation(); startEditing(this)" onblur="saveRepresentativeText(this, '${originalNode.id}')" onkeydown="handleRepresentativeKeydown(event, this, '${originalNode.id}')">
                        <i class="fa ${stateIcon} text-state-icon"></i>
                        <span class="representative-text">${representativeText}</span>
                    </div>
                    <button class="auto-generate-btn" onclick="event.stopPropagation(); openAIGenerationModal('${originalNode.id}')" title="Generate with AI"><i class="fa fa-wand-magic-sparkles"></i></button>
                    <span class="cluster-label">${cluster.label}</span>
                    <span class="cluster-size">${cluster.size}</span>
                </div>
                <!-- Empty content for lazy load -->
                <div class="cluster-content" id="flattened-content-${index}" data-loaded="false" style="display:none;"></div>
            </div>`;
    });

    return flattenedHtml;
}

// Keep the original function as a simple wrapper for backward compatibility
function displayFlattenedView(flattened, level) {
    const html = generateFlattenedHTML(flattened, level);
    $('#flattened-content').html(html);
    updateDownloadOptions(flattened);
    
    // Immediately apply lock state to newly created elements
    if (window.lockManager) {
        window.lockManager.applyLockToNewContent();
        
        // Also apply with multiple quick intervals for large content
        setTimeout(() => {
            window.lockManager.applyLockToNewContent();
        }, 1);
        
        setTimeout(() => {
            window.lockManager.applyLockToNewContent();
        }, 10);
    }
}

function showTreeView() {
    if (currentArtifact && currentArtifact.tree_structure) {
        displayTree(currentArtifact.tree_structure);
        
        // Preserve search if active
        const searchTerm = $('#tree-search').val();
        if (searchTerm.trim()) {
            setTimeout(() => {
                performTreeSearch(searchTerm);
            }, 100); // Small delay to let tree render
        }
    } else {
        // Fallback to simple view switching if no tree data
        flattenedAtLevel = null;
        $('.level-button').removeClass('active');
        $('#tree-content').show();
        $('#flattened-content').hide();
        $('#show-tree-btn').hide();
    }
}

function toggleCluster(nodeId) {
    const content = $(`#content-${nodeId}`);
    const icon = $(`.tree-node[data-node-id="${nodeId}"] > .cluster-header > .collapse-icon`);
    const header = $(`.tree-node[data-node-id="${nodeId}"] > .cluster-header`);

    if (content.is(':visible')) {
        content.slideUp(200);
        icon.removeClass('expanded');
        header.removeClass('expanded');
    } else {
        // Lazy-load content if empty
        if (content.is(':empty')) {
            const node = findNodeById(currentArtifact.tree_structure, nodeId);
            if (node) {
                const parentLevel = parseInt($(header).closest('.tree-node').attr('data-level')) || 0;
                const innerHtml = buildClusterContent(node, parentLevel + 1);
                content.html(innerHtml);
            }
        }
        content.slideDown(200);
        icon.addClass('expanded');
        header.addClass('expanded');
    }
}

function toggleFlattenedCluster(clusterId) {
    const index = parseInt(clusterId.replace('flattened-', ''));
    const content = $(`#flattened-content-${index}`);
    const clusterElement = content.closest('.flattened-cluster');
    const icon = clusterElement.find('.cluster-header .collapse-icon');
    const header = clusterElement.find('.cluster-header');

    if (content.is(':visible')) {
        content.slideUp(200);
        icon.removeClass('expanded');
        header.removeClass('expanded');
    } else {
        // First time expansion – build content lazily
        if (content.attr('data-loaded') === 'false') {
            // Show spinner
            const spinnerHtml = '<div class="text-center p-3"><div class="spinner-border spinner-border-sm"></div> Loading goals...</div>';
            content.html(spinnerHtml);
            content.attr('data-loaded', 'loading');

            // Build goals in chunks to avoid blocking
            const clusterData = currentFlattenedData[index];
            if (!clusterData) {
                content.html('<div class="text-muted p-2">No data available</div>');
                content.attr('data-loaded', 'true');
            } else {
                buildFlattenedGoalsAsync(clusterData, content, () => {
                    content.attr('data-loaded', 'true');
                });
            }
        }
        content.slideDown(200);
        icon.addClass('expanded');
        header.addClass('expanded');
    }
}

// Build goals HTML for a flattened cluster asynchronously
function buildFlattenedGoalsAsync(clusterData, contentElem, doneCallback) {
    const goals = clusterData.goalsWithSource;
    let html = '';
    let i = 0;
    const chunkSize = 100;

    function processChunk() {
        const end = Math.min(i + chunkSize, goals.length);
        for (; i < end; i++) {
            const goalData = goals[i];
            const { goal, source, sourceNodeId, originalIndex } = goalData;
            html += `<div class=\"goal-item\" data-goal-index=\"${i}\"><div class=\"d-flex justify-content-between align-items-start\"><div class=\"flex-grow-1\"><div class=\"goal-text\">\"${goal}\"</div><div class=\"goal-source\">📄 <span class=\"document-link\" onclick=\"openDocumentModal('${source.document_name || 'Unknown'}', '${source.creator || 'Unknown'}')\" title=\"Click to view document\">${truncateText(source.document_name || 'Unknown',25)}</span> | 👤 ${truncateText(source.creator || 'Unknown',15)}${source.course_name?` | 📚 ${truncateText(source.course_name,20)}`:''}${source.institution?` | 🏛️ ${truncateText(source.institution,20)}`:''}</div></div><div class=\"goal-actions\"><button class=\"goal-move-btn\" onclick=\"openMoveModal('${sourceNodeId}','goal',${originalIndex})\" title=\"Move this learning goal\">↔</button><button class=\"goal-delete-btn\" onclick=\"deleteGoal('${sourceNodeId}',${originalIndex})\" title=\"Delete this learning goal\">🗑</button></div></div></div>`;
        }
        if (i < goals.length) {
            requestAnimationFrame(processChunk);
        } else {
            // Replace spinner with built html
            contentElem.html(html);
            
            // Immediately apply lock state to newly created elements
            if (window.lockManager) {
                window.lockManager.applyLockToNewContent();
                
                // Also apply with a tiny delay for any remaining async content
                setTimeout(() => {
                    window.lockManager.applyLockToNewContent();
                }, 1);
            }
            
            if (doneCallback) doneCallback();
        }
    }

    // Start processing
    requestAnimationFrame(processChunk);
}

function expandAll() {
    if ($('#flattened-content').is(':visible')) {
        // Flattened view is active - use fast show() instead of slideDown for performance
        $('#flattened-content .cluster-content').show();
        $('#flattened-content .collapse-icon').addClass('expanded');
        $('#flattened-content .cluster-header').addClass('expanded');
    } else {
        // Tree view is active - use fast show() instead of slideDown for performance
        $('.cluster-content').show();
        $('.collapse-icon').addClass('expanded');
        $('.cluster-header').addClass('expanded');
    }
}

function collapseAll() {
    if ($('#flattened-content').is(':visible')) {
        // Flattened view is active - use fast hide() instead of slideUp for performance
        $('#flattened-content .cluster-content').hide();
        $('#flattened-content .collapse-icon').removeClass('expanded');
        $('#flattened-content .cluster-header').removeClass('expanded');
    } else {
        // Tree view is active - use fast hide() instead of slideUp for performance
        $('.cluster-content').hide();
        $('.collapse-icon').removeClass('expanded');
        $('.cluster-header').removeClass('expanded');
    }
}

function saveChanges() {
    if (!currentArtifactId) {
        alert('No artifact loaded');
        return;
    }
    
    const saveBtn = $('#save-changes-btn');
    
    // Find all changed representative texts
    const changedTexts = [];
    $('[data-changed="true"]').each(function() {
        // Check if this element itself has data-node-id (flattened view)
        // or find it in the closest parent (tree view)
        let nodeId = $(this).data('node-id');
        if (!nodeId) {
            nodeId = $(this).closest('[data-node-id]').data('node-id');
        }
        
        const newText = $(this).find('.representative-text').text().trim();
        const state = $(this).attr('data-state') || 'manual';
        
        // Only add if we have all required fields
        if (nodeId && newText && state) {
            changedTexts.push({
                node_id: nodeId,
                representative_text: newText,
                text_state: state
            });
        } else {
            console.warn('Skipping element with missing data:', {
                nodeId: nodeId,
                newText: newText,
                state: state,
                element: this
            });
        }
    });
    
    if (changedTexts.length === 0) {
        alert('No changes to save');
        return;
    }
    
    // Show progress overlay for large saves (more than 10 changes)
    if (changedTexts.length > 10) {
        showProgress('Saving Changes...', `Updating ${changedTexts.length} representative texts...`);
    }
    
    // Show progress - start with spinner and count
    saveBtn.prop('disabled', true).html(`<i class="fa fa-spinner fa-spin"></i> Saving ${changedTexts.length} changes...`);
    
    // Use batch update API for much better performance
    $.ajax({
        url: '/api/batch-update-artifact-representative-texts',
        method: 'POST',
        contentType: 'application/json',
        data: JSON.stringify({
            artifact_id: currentArtifactId,
            updates: changedTexts
        })
    })
    .done(function(response) {
        if (response.success) {
            // Show success animation
            saveBtn.html('<i class="fa fa-check text-success"></i> Saved Successfully!');
            
            // All successful - clear change indicators
            $('[data-changed="true"]').each(function() {
                $(this).removeAttr('data-changed');
                $(this).css('backgroundColor', '');
            });
            
            // Clear cache since data changed
            flattenedCache = {};
            
            // Brief success message then return to normal
            setTimeout(() => {
                saveBtn.html('<i class="bi bi-save"></i> Save Changes');
            }, 2500);
        } else {
            saveBtn.html('<i class="fa fa-exclamation-triangle text-warning"></i> Save Failed');
            alert('Failed to save changes: ' + response.message);
            
            setTimeout(() => {
                saveBtn.html('<i class="bi bi-save"></i> Save Changes');
            }, 3000);
        }
    })
    .fail(function() {
        saveBtn.html('<i class="fa fa-times text-danger"></i> Network Error');
        alert('Failed to save changes: Network error');
        
        setTimeout(() => {
            saveBtn.html('<i class="bi bi-save"></i> Save Changes');
        }, 3000);
    })
    .always(function() {
        // Hide progress overlay if it was shown
        if (changedTexts.length > 10) {
            hideProgress();
        }
        
        // Always re-enable the button after the operation completes
        setTimeout(() => {
            saveBtn.prop('disabled', false);
        }, 2500);
    });
}

function deleteArtifact(artifactId) {
    $.post(`/api/delete-artifact/${artifactId}`)
        .done(function(response) {
            if (response.success) {
                // Reset everything
                currentArtifact = null;
                currentArtifactId = null;
                $('#artifact-section').hide();
                
                // Reload artifacts list
                loadAvailableArtifacts();
                
                alert('Artifact deleted successfully');
            } else {
                alert('Failed to delete artifact: ' + response.message);
            }
        })
        .fail(function() {
            alert('Failed to delete artifact: Network error');
        });
}

// =====================================
// MOVE AND DELETE FUNCTIONALITY
// =====================================

function openMoveModal(nodeId, moveType, goalIndex = null) {
    // Validate inputs first
    if (!currentArtifact || !currentArtifact.tree_structure) {
        alert('Error: No artifact loaded. Please load an artifact first.');
        return;
    }
    
    currentMoveNodeId = nodeId;
    currentMoveType = moveType;
    currentMoveGoalIndex = goalIndex;
    
    // Find the source node
    const sourceNode = findNodeById(currentArtifact.tree_structure, nodeId);
    
    if (!sourceNode) {
        console.error('Source node not found:', { nodeId, moveType, goalIndex });
        alert(`Error: Source node not found (ID: ${nodeId}). The tree structure may have changed.`);
        return;
    }
    
    // Update modal title and description (only for goal moves now)
    let description = '';
    if (moveType === 'goal' && goalIndex !== null) {
        if (!sourceNode.goals || goalIndex >= sourceNode.goals.length) {
            console.error('Goal not found:', { nodeId, goalIndex, availableGoals: sourceNode.goals ? sourceNode.goals.length : 0 });
            alert(`Error: Learning goal not found (index: ${goalIndex}). The goal may have been moved or deleted.`);
            return;
        }
        
        const goalText = sourceNode.goals[goalIndex];
        description = `<strong>Moving Learning Goal:</strong><br/><em>"${truncateText(goalText, 100)}"</em><br/><br/>Select where you want to move this learning goal:`;
        $('#moveModalLabel').html('<i class="bi bi-arrow-left-right text-info"></i> Move Learning Goal');
    } else {
        // This should not happen anymore since we only allow goal moves
        alert('Invalid move operation. Only individual learning goals can be moved.');
        return;
    }
    
    $('#move-description').html(description);
    
    // Reset new group panel
    resetNewGroupPanel();
    
    // Build destination tree
    buildMoveDestinationTree();
    
    // Clear search
    $('#move-search').val('');
    
    // Show modal
    $('#moveModal').modal('show');
}

function buildMoveDestinationTree() {
    // Only show leaf nodes (deepest level groups that can contain goals)
    const leafNodes = collectLeafNodes(currentArtifact.tree_structure);
    const treeHtml = buildMoveDestinationLeafNodes(leafNodes);
    $('#move-destination-tree').html(treeHtml);
    
    // Reapply lock state to newly created elements
    if (window.lockManager) {
        window.lockManager.forceReapplyLockState();
    }
}

function collectLeafNodes(nodes, path = []) {
    // Collect all leaf nodes (deepest level groups that can contain goals)
    let leafNodes = [];
    
    if (!nodes || !Array.isArray(nodes)) return leafNodes;
    
    nodes.forEach((node, index) => {
        if (!node || typeof node !== 'object') return;
        
        // Use representative text instead of labels (A2B3C1...) for meaningful paths
        const nodeName = node.representative_goal || `Group ${index + 1}`;
        const nodePath = [...path, nodeName];
        const hasChildren = node.children && node.children.length > 0;
        
        if (!hasChildren) {
            // This is a leaf node - can accept learning goals
            leafNodes.push({
                ...node,
                fullPath: nodePath.join(' > ')
            });
        } else {
            // Recursively collect leaf nodes from children
            leafNodes = leafNodes.concat(collectLeafNodes(node.children, nodePath));
        }
    });
    
    return leafNodes;
}

function buildMoveDestinationLeafNodes(leafNodes) {
    // Build a simple list of leaf nodes as move destinations
    let html = '';
    
    if (!leafNodes || leafNodes.length === 0) {
        return '<div class="text-center p-3 text-muted">No valid destinations found</div>';
    }
    
    leafNodes.forEach((node, index) => {
        const isCurrentLocation = node.id === currentMoveNodeId;
        const nodeTitle = node.representative_goal || `Group ${node.label}`;
        
        const nodeClasses = [
            'destination-node',
            isCurrentLocation ? 'current-location' : ''
        ].filter(Boolean).join(' ');
        
        html += `
            <div class="${nodeClasses}" data-node-id="${node.id}" data-node-name="${nodeTitle.toLowerCase()}">
                <div class="destination-node-content">
                    <div class="destination-node-text" title="${nodeTitle}">
                        ${truncateText(nodeTitle, 70)}
                    </div>
                    <i class="bi bi-info-circle destination-path-info" 
                       title="${node.fullPath}" 
                       onclick="event.stopPropagation(); showPathTooltip(this, '${node.fullPath.replace(/'/g, "&apos;")}')"
                       style="color: #6c757d; cursor: help; margin-left: 8px; font-size: 0.8em;">
                    </i>
                </div>
                ${!isCurrentLocation ? `
                    <button class="move-here-btn" onclick="performMove('${node.id}')">
                        Move Here
                    </button>
                ` : '<small class="text-warning">(Current Location)</small>'}
            </div>
        `;
    });
    
    return html;
}

function filterMoveDestinations(searchTerm) {
    const destinations = $('.destination-node');
    
    if (!searchTerm.trim()) {
        // Clear search - show all destinations
        destinations.removeClass('search-match').show();
        $('#no-matches').remove();
        return;
    }
    
    const lowerSearchTerm = searchTerm.toLowerCase();
    let hasMatches = false;
    
    destinations.each(function() {
        // Only search on the node name (not the full path)
        const nodeName = $(this).data('node-name') || $(this).find('.destination-node-text').text().toLowerCase();
        const isMatch = nodeName.includes(lowerSearchTerm);
        
        if (isMatch) {
            $(this).addClass('search-match').show();
            hasMatches = true;
        } else {
            $(this).removeClass('search-match').hide();
        }
    });
    
    if (!hasMatches) {
        $('#move-destination-tree').prepend('<div class="text-muted text-center p-3" id="no-matches">No matching destinations found</div>');
    } else {
        $('#no-matches').remove();
    }
}

function showPathTooltip(element, fullPath) {
    // Remove any existing tooltips
    $('.path-tooltip').remove();
    
    // Create and show a temporary tooltip
    const tooltip = $(`
        <div class="path-tooltip" style="
            position: absolute;
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.8em;
            z-index: 10000;
            max-width: 300px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            pointer-events: none;
        ">
            <strong>Full Path:</strong><br/>${fullPath}
        </div>
    `);
    
    $('body').append(tooltip);
    
    // Position the tooltip near the icon
    const iconOffset = $(element).offset();
    tooltip.css({
        top: iconOffset.top - tooltip.outerHeight() - 5,
        left: Math.max(10, iconOffset.left - tooltip.outerWidth() / 2)
    });
    
    // Auto-hide after 3 seconds
    setTimeout(() => {
        tooltip.fadeOut(200, () => tooltip.remove());
    }, 3000);
}

// Node-level validation functions removed - no longer needed for goal-only operations

function performMove(destinationNodeId) {
    if (!currentMoveNodeId || !currentMoveType) {
        alert('Invalid move operation');
        return;
    }
    
    // Show progress
    showProgress('Moving...', 'Updating tree structure...');
    
    const moveData = {
        artifact_id: currentArtifactId,
        source_node_id: currentMoveNodeId,
        destination_node_id: destinationNodeId,
        move_type: currentMoveType,
        goal_index: currentMoveGoalIndex
    };
    
    $.ajax({
        url: '/api/move-learning-goal',
        method: 'POST',
        contentType: 'application/json',
        data: JSON.stringify(moveData)
    })
    .done(function(response) {
        hideProgress();
        
        if (response.success) {
            // Update the current artifact with the new structure
            currentArtifact.tree_structure = response.updated_tree_structure;
            
            // Clear cache since tree structure changed
            flattenedCache = {};
            
            // Refresh the display
            if (flattenedAtLevel !== null) {
                flattenAtLevel(flattenedAtLevel);
            } else {
                displayTree(currentArtifact.tree_structure);
            }
            
            // Close modal
            $('#moveModal').modal('hide');
            
            // Show success message
            const moveTypeText = currentMoveType === 'goal' ? 'learning goal' : 'group';
            alert(`✅ Successfully moved ${moveTypeText}!`);
        } else {
            alert('Failed to move: ' + response.message);
        }
    })
    .fail(function() {
        hideProgress();
        alert('Failed to move: Network error');
    });
}

// deleteNode function removed - we only delete individual learning goals now

function deleteGoal(nodeId, goalIndex) {
    // Validate inputs first
    if (!currentArtifact || !currentArtifact.tree_structure) {
        alert('Error: No artifact loaded. Please load an artifact first.');
        return;
    }
    
    const node = findNodeById(currentArtifact.tree_structure, nodeId);
    
    if (!node || !node.goals || goalIndex >= node.goals.length) {
        console.error('Goal not found for deletion:', { nodeId, goalIndex, availableGoals: node ? (node.goals ? node.goals.length : 0) : 'node not found' });
        alert(`Error: Learning goal not found (index: ${goalIndex}). The goal may have been moved or deleted.`);
        return;
    }
    
    const goalText = node.goals[goalIndex];
    const confirmMessage = `Are you sure you want to delete this learning goal?\n\n"${truncateText(goalText, 100)}"\n\nIt will be moved to the archive.`;
    
    if (!confirm(confirmMessage)) return;
    
    // Show progress
    showProgress('Deleting...', 'Moving to archive...');
    
    $.ajax({
        url: '/api/delete-goal',
        method: 'POST',
        contentType: 'application/json',
        data: JSON.stringify({
            artifact_id: currentArtifactId,
            node_id: nodeId,
            goal_index: goalIndex
        })
    })
    .done(function(response) {
        hideProgress();
        
        if (response.success) {
            // Update the current artifact with the new structure
            currentArtifact.tree_structure = response.updated_tree_structure;
            
            // Clear cache since tree structure changed
            flattenedCache = {};
            
            // Refresh the display
            if (flattenedAtLevel !== null) {
                flattenAtLevel(flattenedAtLevel);
            } else {
                displayTree(currentArtifact.tree_structure);
            }
            
            alert('✅ Learning goal deleted successfully and moved to archive.');
        } else {
            alert('Failed to delete: ' + response.message);
        }
    })
    .fail(function() {
        hideProgress();
        alert('Failed to delete: Network error');
    });
}

function loadArchivedGoals() {
    $('#archived-goals-container').html('<div class="text-center p-3"><div class="spinner-border spinner-border-sm"></div> Loading archived goals...</div>');
    $('#archiveModal').modal('show');
    
    $.get(`/api/get-archived-goals/${currentArtifactId}`)
        .done(function(response) {
            if (response.success) {
                displayArchivedGoals(response.archived_goals);
            } else {
                $('#archived-goals-container').html('<div class="text-center p-3 text-muted">Failed to load archived goals</div>');
            }
        })
        .fail(function() {
            $('#archived-goals-container').html('<div class="text-center p-3 text-muted">Network error loading archived goals</div>');
        });
}

function displayArchivedGoals(archivedGoals) {
    if (!archivedGoals || archivedGoals.length === 0) {
        $('#archived-goals-container').html('<div class="text-center p-3 text-muted">No archived learning goals found</div>');
        return;
    }
    
    let html = '';
    archivedGoals.forEach((archivedGoal, index) => {
        const archivedDate = new Date(archivedGoal.archived_at).toLocaleDateString();
        html += `
            <div class="archived-goal-item">
                <div class="archived-goal-text">"${archivedGoal.goal_text}"</div>
                <div class="archived-goal-meta">
                    <div>
                        <small>📄 ${archivedGoal.document_name || 'Unknown'} | 👤 ${archivedGoal.creator || 'Unknown'}</small><br/>
                        <small>🗓️ Archived: ${archivedDate} | Original path: ${archivedGoal.original_path || 'Unknown'}</small>
                    </div>
                    <button class="restore-btn" onclick="restoreGoal('${archivedGoal.id}', ${index})" title="Restore this learning goal">
                        ↩️ Restore
                    </button>
                </div>
            </div>
        `;
    });
    
    $('#archived-goals-container').html(html);
}

function restoreGoal(archivedGoalId, index) {
    if (!confirm('Restore this learning goal to its original location?')) return;
    
    $.ajax({
        url: '/api/restore-goal',
        method: 'POST',
        contentType: 'application/json',
        data: JSON.stringify({
            artifact_id: currentArtifactId,
            archived_goal_id: archivedGoalId
        })
    })
    .done(function(response) {
        if (response.success) {
            // Update the current artifact with the new structure
            currentArtifact.tree_structure = response.updated_tree_structure;
            
            // Clear cache since tree structure changed
            flattenedCache = {};
            
            // Refresh the display
            if (flattenedAtLevel !== null) {
                flattenAtLevel(flattenedAtLevel);
            } else {
                displayTree(currentArtifact.tree_structure);
            }
            
            // Remove the restored item from the archive display
            $(`.archived-goal-item:eq(${index})`).fadeOut();
            
            alert('✅ Learning goal restored successfully!');
        } else {
            alert('Failed to restore: ' + response.message);
        }
    })
    .fail(function() {
        alert('Failed to restore: Network error');
    });
}

function showProgress(title, details) {
    $('#progress-text').text(title);
    $('#progress-details').text(details);
    $('#operation-progress').show();
}

function hideProgress() {
    $('#operation-progress').hide();
}

// =====================================
// NEW GROUP CREATION FUNCTIONALITY
// =====================================

function resetNewGroupPanel() {
    const panel = $('#create-new-group-panel');
    const btn = $('#create-new-group-btn');
    
    // Reset to initial state
    panel.hide();
    btn.html('<i class="bi bi-plus-circle-dotted"></i> Create new group instead');
    selectedNewGroupLocation = null;
    currentNewGroupName = null;
    $('#create-and-move-btn').prop('disabled', true);
    $('#new-group-tree-selector').empty();
    $('.tree-level-item').removeClass('selected');
}

function showCreateGroupInfo() {
    alert(`About Creating New Groups:\n\n• Use this option if none of the existing groups above are suitable for your learning goal\n• A new group will be created with your learning goal as its name\n• You'll choose where in the hierarchy to place this new group\n• You can only create new groups at the level that contains other groups (not deeper levels)`);
}

function toggleCreateNewGroup() {
    const panel = $('#create-new-group-panel');
    const btn = $('#create-new-group-btn');
    
    if (panel.is(':visible')) {
        // Hide the panel
        panel.slideUp();
        btn.html('<i class="bi bi-plus-circle-dotted"></i> Create new group instead');
        selectedNewGroupLocation = null;
        $('#create-and-move-btn').prop('disabled', true);
    } else {
        // Show the panel and set up the goal name
        if (currentMoveType === 'goal' && currentMoveGoalIndex !== null) {
            const sourceNode = findNodeById(currentArtifact.tree_structure, currentMoveNodeId);
            if (sourceNode && sourceNode.goals && sourceNode.goals[currentMoveGoalIndex]) {
                currentNewGroupName = sourceNode.goals[currentMoveGoalIndex];
                $('#new-group-name-preview').text(truncateText(currentNewGroupName, 100));
                
                // Build the hierarchical tree selector
                buildNewGroupTreeSelector();
                
                panel.slideDown();
                btn.html('<i class="bi bi-x-circle text-muted"></i> Cancel');
            }
        }
    }
}

function buildNewGroupTreeSelector() {
    // Start with top-level nodes - no "Select Here" buttons at top level
    const topLevelHtml = buildTreeLevel(currentArtifact.tree_structure, [], 'top');
    
    $('#new-group-tree-selector').html(topLevelHtml);
}

function isSecondToLastLevel(node) {
    // A node is at second-to-last level if:
    // 1. It has children (not a leaf group itself)
    // 2. All its children are leaf groups (have no children of their own)
    if (!node.children || node.children.length === 0) {
        return false; // This is a leaf group
    }
    
    // Check if all children are leaf groups
    return node.children.every(child => !child.children || child.children.length === 0);
}

function buildTreeLevel(nodes, path = [], containerId = null) {
    let html = '';
    
    nodes.forEach((node, index) => {
        const hasChildren = node.children && node.children.length > 0;
        const nodeTitle = node.representative_goal || `Group ${node.label}`;
        const currentPath = [...path, { id: node.id, title: nodeTitle }];
        const pathStr = JSON.stringify(currentPath).replace(/"/g, '&quot;');
        
        const itemId = containerId ? `${containerId}-${index}` : `item-${index}`;
        const canSelectHere = isSecondToLastLevel(node);
        
        html += `
            <div class="tree-level-item ${hasChildren ? '' : 'leaf'}" data-node-id="${node.id}" data-item-id="${itemId}">
                ${hasChildren ? 
                    `<i class="bi bi-chevron-right expand-icon" onclick="event.stopPropagation(); toggleTreeLevel('${itemId}', '${node.id}', '${pathStr}')"></i>` :
                    `<i class="bi bi-circle-fill expand-icon"></i>`
                }
                <div class="tree-level-text" title="${nodeTitle}">
                    ${truncateText(nodeTitle, 60)}
                    ${canSelectHere ? ' <small class="text-success">(can add groups here)</small>' : ''}
                </div>
                ${canSelectHere ? `
                    <button class="select-location-btn" onclick="event.stopPropagation(); selectNewGroupLocation('${node.id}', '${pathStr}')">
                        Select Here
                    </button>
                ` : hasChildren ? '<small class="text-muted">Navigate deeper ↓</small>' : '<small class="text-muted">Group</small>'}
            </div>
            ${hasChildren ? `<div class="tree-children" id="children-${itemId}" style="display: none;"></div>` : ''}
        `;
    });
    
    return html;
}

function toggleTreeLevel(itemId, nodeId, pathStr) {
    const item = $(`[data-item-id="${itemId}"]`);
    const childrenContainer = $(`#children-${itemId}`);
    const icon = item.find('.expand-icon');
    
    if (childrenContainer.is(':visible')) {
        // Collapse
        childrenContainer.slideUp();
        icon.removeClass('bi-chevron-down').addClass('bi-chevron-right');
        item.removeClass('expanded');
    } else {
        // Expand - load children if not already loaded
        if (childrenContainer.is(':empty')) {
            const node = findNodeById(currentArtifact.tree_structure, nodeId);
            if (node && node.children) {
                const path = JSON.parse(pathStr.replace(/&quot;/g, '"'));
                const childrenHtml = buildTreeLevel(node.children, path, itemId);
                childrenContainer.html(childrenHtml);
            }
        }
        
        childrenContainer.slideDown();
        icon.removeClass('bi-chevron-right').addClass('bi-chevron-down');
        item.addClass('expanded');
    }
}

function selectNewGroupLocation(locationId, pathStr) {
    // Clear previous selection
    $('.tree-level-item').removeClass('selected');
    
    // Set new selection - only "under" type since we removed top-level creation
    const path = JSON.parse(pathStr.replace(/&quot;/g, '"'));
    selectedNewGroupLocation = { type: 'under', parentId: locationId, path: path };
    $(`[data-node-id="${locationId}"]`).addClass('selected');
    
    // Enable the create button
    $('#create-and-move-btn').prop('disabled', false);
}

function createNewGroupAndMove() {
    if (!selectedNewGroupLocation || !currentNewGroupName) {
        alert('Please select a location for the new group');
        return;
    }
    
    // Show progress
    showProgress('Creating new group...', 'Creating group and moving goal...');
    
    // Prepare the data for the backend
    const createData = {
        artifact_id: currentArtifactId,
        source_node_id: currentMoveNodeId,
        goal_index: currentMoveGoalIndex,
        new_group_name: currentNewGroupName,
        location: selectedNewGroupLocation
    };
    
    $.ajax({
        url: '/api/create-group-and-move-goal',
        method: 'POST',
        contentType: 'application/json',
        data: JSON.stringify(createData)
    })
    .done(function(response) {
        hideProgress();
        
        if (response.success) {
            // Update the current artifact with the new structure
            currentArtifact.tree_structure = response.updated_tree_structure;
            
            // Clear cache since tree structure changed
            flattenedCache = {};
            
            // Refresh the display
            if (flattenedAtLevel !== null) {
                flattenAtLevel(flattenedAtLevel);
            } else {
                displayTree(currentArtifact.tree_structure);
            }
            
            // Close modal
            $('#moveModal').modal('hide');
            
            // Show success message
            alert(`✅ Successfully created new group "${truncateText(currentNewGroupName, 50)}" and moved the learning goal!`);
        } else {
            alert('Failed to create group and move goal: ' + response.message);
        }
    })
    .fail(function() {
        hideProgress();
        alert('Failed to create group and move goal: Network error');
    });
}

// =====================================
// CSV DOWNLOAD FUNCTIONALITY
// =====================================

function updateDownloadOptions(flattened) {
    // Check what data is available in the flattened clusters
    const availableFields = {
        institution: false,
        creator: false,
        course_name: false
    };
    
    // Check all sources for available fields
    flattened.forEach(cluster => {
        cluster.goalsWithSource.forEach(goalData => {
            const { source } = goalData;
            if (source.institution && source.institution.trim() !== '') {
                availableFields.institution = true;
            }
            if (source.creator && source.creator.trim() !== '') {
                availableFields.creator = true;
            }
            if (source.course_name && source.course_name.trim() !== '') {
                availableFields.course_name = true;
            }
        });
    });
    
    // Update dropdown options
    const dropdown = $('#download-column-type');
    const currentValue = dropdown.val();
    dropdown.empty();
    
    if (availableFields.institution) {
        dropdown.append('<option value="institution">by Institution</option>');
    }
    if (availableFields.creator) {
        dropdown.append('<option value="creator">by Creator</option>');
    }
    if (availableFields.course_name) {
        dropdown.append('<option value="course_name">by Course</option>');
    }
    
    // If no fields are available, show a default option
    if (!availableFields.institution && !availableFields.creator && !availableFields.course_name) {
        dropdown.append('<option value="creator">by Creator (Limited Data)</option>');
    }
    
    // Try to restore previous selection if still available
    if (dropdown.find(`option[value="${currentValue}"]`).length > 0) {
        dropdown.val(currentValue);
    }
}

function downloadFlattenedCSV(levelLabel) {
    if (!currentArtifact || flattenedAtLevel === null) {
        alert('No flattened view available to download');
        return;
    }
    
    const columnType = $('#download-column-type').val();
    
    // Get flattened data for the current level
    const flattened = flattenTreeAtLevel(currentArtifact.tree_structure, flattenedAtLevel);
    
    if (!flattened || flattened.length === 0) {
        alert('No data available to download');
        return;
    }
    
    // Helper function to properly escape CSV values
    function escapeCSVField(field) {
        // Convert to string and handle null/undefined
        const str = String(field || '');
        
        // If the field contains commas, quotes, or newlines, wrap in quotes and escape internal quotes
        if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
            return '"' + str.replace(/"/g, '""') + '"';
        }
        return str;
    }
    
    // Collect all unique values for the selected column type
    const allUniqueValues = new Set();
    const clusterData = {};
    
    // Process each cluster
    flattened.forEach(cluster => {
        const clusterName = cluster.representative || cluster.originalNode.representative_goal || cluster.label;
        clusterData[clusterName] = {};
        
        cluster.goalsWithSource.forEach(goalData => {
            const { source } = goalData;
            let columnValue = source[columnType];
            
            // Handle missing data
            if (!columnValue || columnValue.trim() === '') {
                columnValue = `Unknown ${columnType.replace('_', ' ')}`;
            }
            
            allUniqueValues.add(columnValue);
            
            // Count goals for this column value in this cluster
            if (!clusterData[clusterName][columnValue]) {
                clusterData[clusterName][columnValue] = 0;
            }
            clusterData[clusterName][columnValue]++;
        });
    });
    
    // Convert to sorted array and escape column headers
    const sortedColumnValues = Array.from(allUniqueValues).sort();
    const escapedColumnHeaders = sortedColumnValues.map(escapeCSVField);
    
    // Generate CSV content with proper escaping
    let csvContent = escapeCSVField("Cluster Name") + "," + escapedColumnHeaders.join(',') + "\n";
    
    // Add data rows
    Object.keys(clusterData).forEach(clusterName => {
        const row = [escapeCSVField(clusterName)];
        sortedColumnValues.forEach(columnValue => {
            const count = clusterData[clusterName][columnValue] || 0;
            row.push(count); // Numbers don't need escaping
        });
        csvContent += row.join(',') + "\n";
    });
    
    // Create and download the file
    const columnTypeLabel = columnType.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
    const filename = `LG_Hierarchy_Level_${levelLabel}_by_${columnTypeLabel.replace(' ', '_')}.csv`;
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    if (link.download !== undefined) {
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', filename);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    } else {
        alert('Browser does not support file download');
    }
}

// ===== NEW: Lazy-load skeleton builder =====
function buildTreeNodeSkeleton(node, level = 0) {
    const levelClass = level <= 10 ? `tree-level-${level}` : 'tree-level-deep';
    const hasChildren = node.children && node.children.length > 0;
    const hasGoals = node.goals && node.goals.length > 0;

    // Representative text & state/icon (same as full builder)
    let representativeText = node.representative_goal || '';
    let textState = node.text_state || 'default';
    let stateIcon = 'fa-quote-left';
    if (textState === 'manual') stateIcon = 'fa-pencil';
    else if (textState === 'ai') stateIcon = 'fa-wand-magic-sparkles';

    if (!representativeText && hasGoals) {
        representativeText = node.goals.reduce((longest, current) => current.length > longest.length ? current : longest);
    } else if (!representativeText && hasChildren) {
        representativeText = findRepresentativeGoal(node);
    }

    let html = `<div class="tree-node ${levelClass}" data-level="${level}" data-node-id="${node.id}">`;

    // header (identical)
    html += `
        <div class="cluster-header" onclick="toggleCluster('${node.id}')">
            ${hasChildren ? '<i class="bi bi-chevron-right collapse-icon"></i>' : '<i class="bi bi-circle-fill collapse-icon" style="font-size: 0.5em;"></i>'}
            <div class="cluster-representative" contenteditable="true" data-state="${textState}" onclick="event.stopPropagation(); startEditing(this)" onblur="saveRepresentativeText(this, '${node.id}')" onkeydown="handleRepresentativeKeydown(event, this, '${node.id}')">
                <i class="fa ${stateIcon} text-state-icon"></i>
                <span class="representative-text">${representativeText}</span>
            </div>
            <button class="auto-generate-btn" onclick="event.stopPropagation(); openAIGenerationModal('${node.id}')" title="Generate with AI"><i class="fa fa-wand-magic-sparkles"></i></button>
            <span class="cluster-label">${node.label}</span>
            <span class="cluster-size">${node.size || 0}</span>
        </div>`;

    // Empty content container – populated lazily when expanded
    if (hasGoals || hasChildren) {
        html += `<div class="cluster-content" id="content-${node.id}" style="display:none;"></div>`;
    }

    html += '</div>';
    return html;
}

// ===== NEW: Build content for a node lazily =====
function buildClusterContent(node, level) {
    let innerHtml = '';

    // Goals first (if any)
    if (node.goals && node.goals.length > 0) {
        node.goals.forEach((goal, idx) => {
            const source = node.sources ? node.sources[idx] : {};
            innerHtml += `
                <div class="goal-item" data-goal-index="${idx}">
                    <div class="d-flex justify-content-between align-items-start">
                        <div class="flex-grow-1">
                            <div class="goal-text">"${goal}"</div>
                            <div class="goal-source">📄 <span class="document-link" onclick="openDocumentModal('${source.document_name || 'Unknown'}', '${source.creator || 'Unknown'}')" title="Click to view document">${truncateText(source.document_name || 'Unknown',25)}</span> | 👤 ${truncateText(source.creator || 'Unknown',15)}${source.course_name?` | 📚 ${truncateText(source.course_name,20)}`:''}${source.institution?` | 🏛️ ${truncateText(source.institution,20)}`:''}</div>
                        </div>
                        <div class="goal-actions">
                            <button class="goal-move-btn" onclick="openMoveModal('${node.id}','goal',${idx})" title="Move this learning goal">↔</button>
                            <button class="goal-delete-btn" onclick="deleteGoal('${node.id}',${idx})" title="Delete this learning goal">🗑</button>
                        </div>
                    </div>
                </div>`;
        });
    }

    // Children skeletons
    if (node.children && node.children.length > 0) {
        node.children.forEach(child => {
            innerHtml += buildTreeNodeSkeleton(child, level + 1);
        });
    }

    return innerHtml;
}

// ===== MODIFY: buildAndDisplayTree uses skeleton =====
// ... existing code ...

// =====================================
// SEARCH FUNCTIONALITY
// =====================================

let searchResults = {
    clusterMatches: 0,
    goalMatches: 0,
    totalVisible: 0
};

function performTreeSearch(searchTerm) {
    const term = searchTerm.trim().toLowerCase();
    
    if (!term) {
        clearTreeSearch();
        return;
    }
    
    // Reset search results
    searchResults = { clusterMatches: 0, goalMatches: 0, totalVisible: 0 };
    
    if ($('#flattened-content').is(':visible')) {
        // Search in flattened view
        searchFlattenedView(term);
    } else {
        // Search in tree view
        searchTreeView(term);
    }
    
    // Update search results info
    updateSearchResultsInfo(term);
}

function searchTreeView(term) {
    // Remove previous search classes
    $('.search-match-cluster, .search-match-goal, .search-hidden').removeClass('search-match-cluster search-match-goal search-hidden');
    $('.search-highlight').contents().unwrap();
    
    // STEP 1: Recursively load ALL content deep for comprehensive search
    recursivelyLoadAllTreeContent();
    
    // STEP 2: Identify all matches (clusters and individual goals)
    const matchingElements = new Set();
    const pathToMatches = new Set(); // Nodes that need to be shown because they're on path to matches
    
    $('.tree-node').each(function() {
        const $node = $(this);
        const nodeId = $node.data('node-id');
        let nodeHasDirectMatch = false;
        
        // Check cluster name match
        const $representative = $node.find('> .cluster-header .representative-text');
        if ($representative.length) {
            const representativeText = $representative.text().toLowerCase();
            if (representativeText.includes(term)) {
                nodeHasDirectMatch = true;
                matchingElements.add(nodeId);
                $node.find('> .cluster-header').addClass('search-match-cluster');
                highlightText($representative, term);
                searchResults.clusterMatches++;
            }
        }
        
        // Check individual goals
        $node.find('> .cluster-content .goal-item').each(function() {
            const $goalItem = $(this);
            const $goalText = $goalItem.find('.goal-text');
            const goalText = $goalText.text().toLowerCase();
            
            if (goalText.includes(term)) {
                $goalItem.addClass('search-match-goal');
                highlightText($goalText, term);
                matchingElements.add(nodeId); // Mark parent node as having matches
                searchResults.goalMatches++;
            }
        });
        
        // If this node has matches, mark all its ancestors as needed
        if (matchingElements.has(nodeId)) {
            $node.parents('.tree-node').each(function() {
                const ancestorId = $(this).data('node-id');
                pathToMatches.add(ancestorId);
            });
        }
    });
    
    // STEP 3: Show/hide based on matches and expand all matching paths
    $('.tree-node').each(function() {
        const $node = $(this);
        const nodeId = $node.data('node-id');
        
        if (matchingElements.has(nodeId) || pathToMatches.has(nodeId)) {
            $node.show();
            searchResults.totalVisible++;
            
            // Force expand all content for search view
            const $content = $node.find('> .cluster-content');
            if ($content.length) {
                $content.show();
                $node.find('> .cluster-header .collapse-icon').addClass('expanded');
                $node.find('> .cluster-header').addClass('expanded');
            }
            
            // ALWAYS hide non-matching goals, regardless of whether cluster name matches
            $node.find('> .cluster-content .goal-item').each(function() {
                if (!$(this).hasClass('search-match-goal')) {
                    $(this).addClass('search-hidden');
                }
            });
        } else {
            $node.addClass('search-hidden');
        }
    });
}

function searchFlattenedView(term) {
    // Remove previous search classes
    $('.search-match-cluster, .search-match-goal, .search-hidden').removeClass('search-match-cluster search-match-goal search-hidden');
    $('.search-highlight').contents().unwrap();
    
    // Force load and expand all clusters first for comprehensive search
    $('.flattened-cluster').each(function() {
        const $cluster = $(this);
        const $content = $cluster.find('.cluster-content');
        
        if ($content.length && $content.attr('data-loaded') === 'false') {
            const clusterId = $content.attr('id').replace('flattened-content-', '');
            const index = parseInt(clusterId);
            if (currentFlattenedData[index]) {
                // Synchronously build content for search
                const clusterData = currentFlattenedData[index];
                let goalsHtml = '';
                clusterData.goalsWithSource.forEach((goalData, goalIndex) => {
                    const { goal, source, sourceNodeId, originalIndex } = goalData;
                    goalsHtml += `<div class="goal-item" data-goal-index="${goalIndex}"><div class="d-flex justify-content-between align-items-start"><div class="flex-grow-1"><div class="goal-text">"${goal}"</div><div class="goal-source">📄 <span class="document-link" onclick="openDocumentModal('${source.document_name || 'Unknown'}', '${source.creator || 'Unknown'}')" title="Click to view document">${truncateText(source.document_name || 'Unknown',25)}</span> | 👤 ${truncateText(source.creator || 'Unknown',15)}${source.course_name ? ` | 📚 ${truncateText(source.course_name,20)}` : ''}${source.institution ? ` | 🏛️ ${truncateText(source.institution,20)}` : ''}</div></div><div class="goal-actions"><button class="goal-move-btn" onclick="openMoveModal('${sourceNodeId}','goal',${originalIndex})" title="Move this learning goal">↔</button><button class="goal-delete-btn" onclick="deleteGoal('${sourceNodeId}',${originalIndex})" title="Delete this learning goal">🗑</button></div></div></div>`;
                });
                $content.html(goalsHtml);
                $content.attr('data-loaded', 'true');
            }
        }
        
        // Force expand all clusters
        if ($content.length) {
            $content.show();
            $cluster.find('.cluster-header .collapse-icon').addClass('expanded');
            $cluster.find('.cluster-header').addClass('expanded');
        }
    });
    
    // Now search through everything and filter
    $('.flattened-cluster').each(function() {
        const $cluster = $(this);
        let clusterNameMatches = false;
        let hasMatchingGoals = false;
        
        // Check cluster name match
        const $representative = $cluster.find('.cluster-header .representative-text');
        if ($representative.length) {
            const representativeText = $representative.text().toLowerCase();
            if (representativeText.includes(term)) {
                $cluster.find('.cluster-header').addClass('search-match-cluster');
                highlightText($representative, term);
                clusterNameMatches = true;
                searchResults.clusterMatches++;
            }
        }
        
        // Check individual goals and mark/hide them
        const $content = $cluster.find('.cluster-content');
        if ($content.length) {
            $content.find('.goal-item').each(function() {
                const $goalItem = $(this);
                const $goalText = $goalItem.find('.goal-text');
                const goalText = $goalText.text().toLowerCase();
                
                if (goalText.includes(term)) {
                    $goalItem.addClass('search-match-goal');
                    highlightText($goalText, term);
                    hasMatchingGoals = true;
                    searchResults.goalMatches++;
                } else {
                    // ALWAYS hide goals that don't match, regardless of cluster name match
                    $goalItem.addClass('search-hidden');
                }
            });
        }
        
        // Show/hide entire cluster based on matches
        if (clusterNameMatches || hasMatchingGoals) {
            $cluster.show();
            searchResults.totalVisible++;
        } else {
            $cluster.addClass('search-hidden');
        }
    });
}

// =====================================
// DEEP TREE LOADING FOR SEARCH
// =====================================

function recursivelyLoadAllTreeContent() {
    // We need to keep loading until no more empty content containers exist
    let moreToLoad = true;
    let iterations = 0;
    const maxIterations = 20; // Safety limit to prevent infinite loops
    
    while (moreToLoad && iterations < maxIterations) {
        moreToLoad = false;
        iterations++;
        
        $('.tree-node').each(function() {
            const $node = $(this);
            const nodeId = $node.data('node-id');
            const $content = $node.find('> .cluster-content');
            
            // If content is empty, load it with FULL content (not skeletons)
            if ($content.length && $content.is(':empty')) {
                const node = findNodeById(currentArtifact.tree_structure, nodeId);
                if (node) {
                    const parentLevel = parseInt($node.attr('data-level')) || 0;
                    const innerHtml = buildFullClusterContent(node, parentLevel + 1);
                    $content.html(innerHtml);
                    moreToLoad = true; // Continue iterating since we added new content
                }
            }
        });
    }
    
    if (iterations >= maxIterations) {
        console.warn('Tree loading reached maximum iterations. Some deep content might not be loaded.');
    }
}

function buildFullClusterContent(node, level) {
    // This is like buildClusterContent but builds FULL content, not skeletons
    let innerHtml = '';

    // Goals first (if any)
    if (node.goals && node.goals.length > 0) {
        node.goals.forEach((goal, idx) => {
            const source = node.sources ? node.sources[idx] : {};
            innerHtml += `
                <div class="goal-item" data-goal-index="${idx}">
                    <div class="d-flex justify-content-between align-items-start">
                        <div class="flex-grow-1">
                            <div class="goal-text">"${goal}"</div>
                            <div class="goal-source">📄 <span class="document-link" onclick="openDocumentModal('${source.document_name || 'Unknown'}', '${source.creator || 'Unknown'}')" title="Click to view document">${truncateText(source.document_name || 'Unknown',25)}</span> | 👤 ${truncateText(source.creator || 'Unknown',15)}${source.course_name?` | 📚 ${truncateText(source.course_name,20)}`:''}${source.institution?` | 🏛️ ${truncateText(source.institution,20)}`:''}</div>
                        </div>
                        <div class="goal-actions">
                            <button class="goal-move-btn" onclick="openMoveModal('${node.id}','goal',${idx})" title="Move this learning goal">↔</button>
                            <button class="goal-delete-btn" onclick="deleteGoal('${node.id}',${idx})" title="Delete this learning goal">🗑</button>
                        </div>
                    </div>
                </div>`;
        });
    }

    // FULL children trees (not skeletons) - this is the key difference
    if (node.children && node.children.length > 0) {
        node.children.forEach(child => {
            innerHtml += buildFullTreeNode(child, level + 1);
        });
    }

    return innerHtml;
}

function buildFullTreeNode(node, level = 0) {
    // This builds a complete tree node with all content loaded (not skeleton)
    const levelClass = level <= 10 ? `tree-level-${level}` : 'tree-level-deep';
    const hasChildren = node.children && node.children.length > 0;
    const hasGoals = node.goals && node.goals.length > 0;
    
    // Get representative text and determine state
    let representativeText = node.representative_goal || '';
    let textState = node.text_state || 'default';
    let stateIcon = 'fa-quote-left';
    if (textState === 'manual') stateIcon = 'fa-pencil';
    else if (textState === 'ai') stateIcon = 'fa-wand-magic-sparkles';
    
    if (!representativeText && hasGoals) {
        representativeText = node.goals.reduce((longest, current) => 
            current.length > longest.length ? current : longest
        );
    } else if (!representativeText && hasChildren) {
        representativeText = findRepresentativeGoal(node);
    }
    
    let nodeHtml = `<div class="tree-node ${levelClass}" data-level="${level}" data-node-id="${node.id}">`;
    
    // Node header
    nodeHtml += `
        <div class="cluster-header" onclick="toggleCluster('${node.id}')">
            ${hasChildren ? '<i class="bi bi-chevron-right collapse-icon"></i>' : '<i class="bi bi-circle-fill collapse-icon" style="font-size: 0.5em;"></i>'}
            <div class="cluster-representative" contenteditable="true" data-state="${textState}" onclick="event.stopPropagation(); startEditing(this)" onblur="saveRepresentativeText(this, '${node.id}')" onkeydown="handleRepresentativeKeydown(event, this, '${node.id}')">
                <i class="fa ${stateIcon} text-state-icon"></i>
                <span class="representative-text">${representativeText}</span>
            </div>
            <button class="auto-generate-btn" onclick="event.stopPropagation(); openAIGenerationModal('${node.id}')" title="Generate with AI"><i class="fa fa-wand-magic-sparkles"></i></button>
            <span class="cluster-label">${node.label}</span>
            <span class="cluster-size">${node.size || 0}</span>
        </div>`;
    
    // FULL content (goals and children) - not empty container
    if ((hasGoals || hasChildren) && (hasGoals || node.size > 0)) {
        nodeHtml += `<div class="cluster-content" id="content-${node.id}" style="display: none;">`;
        
        // Add goals if any
        if (hasGoals) {
            node.goals.forEach(function(goal, index) {
                const source = node.sources ? node.sources[index] : {};
                nodeHtml += `
                    <div class="goal-item" data-goal-index="${index}">
                        <div class="d-flex justify-content-between align-items-start">
                            <div class="flex-grow-1">
                                <div class="goal-text">"${goal}"</div>
                                <div class="goal-source">
                                    📄 <span class="document-link" onclick="openDocumentModal('${source.document_name || 'Unknown'}', '${source.creator || 'Unknown'}')" title="Click to view document">${truncateText(source.document_name || 'Unknown', 25)}</span> | 
                                    👤 ${truncateText(source.creator || 'Unknown', 15)}
                                    ${source.course_name ? ` | 📚 ${truncateText(source.course_name, 20)}` : ''}
                                    ${source.institution ? ` | 🏛️ ${truncateText(source.institution, 20)}` : ''}
                                </div>
                            </div>
                            <div class="goal-actions">
                                <button class="goal-move-btn" onclick="openMoveModal('${node.id}', 'goal', ${index})" title="Move this learning goal">↔</button>
                                <button class="goal-delete-btn" onclick="deleteGoal('${node.id}', ${index})" title="Delete this learning goal">🗑</button>
                            </div>
                        </div>
                    </div>
                `;
            });
        }
        
        // Add full children (recursively)
        if (hasChildren) {
            node.children.forEach(child => {
                nodeHtml += buildFullTreeNode(child, level + 1);
            });
        }
        
        nodeHtml += `</div>`;
    }
    
    nodeHtml += `</div>`;
    return nodeHtml;
}

function highlightText($element, term) {
    const text = $element.text();
    const regex = new RegExp(`(${escapeRegExp(term)})`, 'gi');
    const highlightedText = text.replace(regex, '<span class="search-highlight">$1</span>');
    $element.html(highlightedText);
}

function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function clearTreeSearch() {
    // Remove all search classes and highlights
    $('.search-match-cluster, .search-match-goal, .search-hidden').removeClass('search-match-cluster search-match-goal search-hidden');
    $('.search-highlight').contents().unwrap();
    
    // Show all nodes/clusters and goals
    $('.tree-node, .flattened-cluster, .goal-item').show();
    
    // Reset tree view to collapsed state
    if ($('#tree-content').is(':visible')) {
        $('.cluster-content').hide();
        $('.collapse-icon').removeClass('expanded');
        $('.cluster-header').removeClass('expanded');
    }
    
    // Reset flattened view to collapsed state
    if ($('#flattened-content').is(':visible')) {
        $('.flattened-cluster .cluster-content').hide();
        $('.flattened-cluster .collapse-icon').removeClass('expanded');
        $('.flattened-cluster .cluster-header').removeClass('expanded');
    }
    
    // Clear search results info
    $('#search-results-info').text('');
    
    // Reset search results
    searchResults = { clusterMatches: 0, goalMatches: 0, totalVisible: 0 };
}

function updateSearchResultsInfo(term) {
    const info = $('#search-results-info');
    const { clusterMatches, goalMatches, totalVisible } = searchResults;
    const totalMatches = clusterMatches + goalMatches;
    
    if (totalMatches === 0) {
        info.html(`<span class="text-muted">No matches found for "${term}"</span>`);
    } else {
        let infoText = `Found ${totalMatches} matches`;
        if (clusterMatches > 0 && goalMatches > 0) {
            infoText += ` (${clusterMatches} clusters, ${goalMatches} goals)`;
        } else if (clusterMatches > 0) {
            infoText += ` in cluster names`;
        } else {
            infoText += ` in learning goals`;
        }
        infoText += ` for "${term}"`;
        
        info.html(`<span class="text-success">${infoText}</span>`);
    }
}

// =====================================
// DENDROGRAM FUNCTIONALITY
// =====================================

// Global dendrogram variables
let dendrogramSvg = null;
let dendrogramData = null;
let dendrogramZoom = null;
let currentLayout = 'vertical';
let focusedNode = null;
let focusPath = [];
let visibleNodes = new Set();
let collapsedNodes = new Set();

function showDendrogram() {
    // Show the modal
    $('#dendrogramModal').modal('show');
    
    // Initialize dendrogram when modal is shown
    $('#dendrogramModal').on('shown.bs.modal', function() {
        initializeDendrogram();
    });
}

function initializeDendrogram() {
    // Show loading
    $('#dendrogram-loading').show();
    
    // Clear any existing SVG
    $('#dendrogram-svg-container').empty();
    
    // Convert tree structure to D3 hierarchy format
    dendrogramData = convertToD3Hierarchy(currentArtifact.tree_structure);
    
    // Create the dendrogram
    setTimeout(() => {
        createDendrogram();
        $('#dendrogram-loading').hide();
    }, 100);
}

function convertToD3Hierarchy(treeStructure) {
    // Convert our tree structure to D3 hierarchy format
    function convertNode(node) {
        const d3Node = {
            id: node.id,
            name: node.label,
            representativeText: node.representative_goal || '',
            size: node.size || 0,
            goals: node.goals || [],
            level: node.level || 0,
            text_state: node.text_state || 'default'
        };
        
        if (node.children && node.children.length > 0) {
            d3Node.children = node.children.map(child => convertNode(child));
        }
        
        return d3Node;
    }
    
    // Create a root node if we have multiple top-level nodes
    if (treeStructure.length === 1) {
        return convertNode(treeStructure[0]);
    } else {
        return {
            id: 'root',
            name: 'Root',
            representativeText: 'Learning Goals Hierarchy',
            size: treeStructure.reduce((sum, node) => sum + (node.size || 0), 0),
            goals: [],
            level: -1,
            children: treeStructure.map(node => convertNode(node))
        };
    }
}

function createDendrogram() {
    const container = document.getElementById('dendrogram-svg-container');
    const containerRect = container.getBoundingClientRect();
    const width = containerRect.width;
    const height = containerRect.height;
    
    // Clear previous SVG
    d3.select(container).selectAll('*').remove();
    
    // Create SVG
    const svg = d3.select(container)
        .append('svg')
        .attr('width', width)
        .attr('height', height);
    
    // Create zoom behavior
    dendrogramZoom = d3.zoom()
        .scaleExtent([0.1, 5])
        .on('zoom', (event) => {
            g.attr('transform', event.transform);
        });
    
    svg.call(dendrogramZoom);
    
    // Create main group for zooming and panning
    const g = svg.append('g')
        .attr('class', 'dendrogram-zoom-container');
    
    // Determine what data to show (focused subtree or full tree)
    let dataToShow = dendrogramData;
    if (focusedNode) {
        dataToShow = focusedNode.data;
    }
    
    // Create hierarchy
    const root = d3.hierarchy(dataToShow);
    
    // Progressive loading: limit depth for performance
    const maxVisibleDepth = calculateMaxVisibleDepth(root);
    const filteredRoot = filterTreeByDepth(root, maxVisibleDepth);
    
    // Create different layouts based on selection
    let treeLayout;
    let nodeTransform;
    let linkPath;
    
    if (currentLayout === 'radial') {
        treeLayout = d3.tree()
            .size([2 * Math.PI, Math.min(width, height) / 2 - 100])
            .separation((a, b) => (a.parent === b.parent ? 1 : 2) / a.depth);
        
        nodeTransform = d => `rotate(${(d.x * 180 / Math.PI - 90)}) translate(${d.y},0)`;
        
        linkPath = d3.linkRadial()
            .angle(d => d.x)
            .radius(d => d.y);
    } else if (currentLayout === 'vertical') {
        treeLayout = d3.tree()
            .size([width - 200, height - 200])
            .separation((a, b) => (a.parent === b.parent ? 1 : 2) / a.depth);
        
        nodeTransform = d => `translate(${d.x},${d.y})`;
        
        linkPath = d3.linkVertical()
            .x(d => d.x)
            .y(d => d.y);
    } else {
        // Horizontal layout (default)
        treeLayout = d3.tree()
            .size([height - 200, width - 200])
            .separation((a, b) => (a.parent === b.parent ? 1 : 2) / a.depth);
        
        nodeTransform = d => `translate(${d.y},${d.x})`;
        
        linkPath = d3.linkHorizontal()
            .x(d => d.y)
            .y(d => d.x);
    }
    
    // Apply layout
    treeLayout(filteredRoot);
    
    // Position the tree in the center
    if (currentLayout === 'radial') {
        g.attr('transform', `translate(${width / 2},${height / 2})`);
    } else {
        g.attr('transform', `translate(100,100)`);
    }
    
    // Add links with visibility filtering
    const visibleLinks = filteredRoot.links().filter(link => 
        !collapsedNodes.has(link.source.data.id) && 
        !collapsedNodes.has(link.target.data.id)
    );
    
    const links = g.selectAll('.dendrogram-link')
        .data(visibleLinks)
        .enter()
        .append('path')
        .attr('class', 'dendrogram-link')
        .attr('d', linkPath)
        .on('mouseover', function(event, d) {
            d3.select(this).style('stroke', '#007bff').style('stroke-width', '2.5px');
        })
        .on('mouseout', function(event, d) {
            d3.select(this).style('stroke', '#6c757d').style('stroke-width', '1.5px');
        });
    
    // Add nodes with click-to-focus functionality
    const visibleNodeData = filteredRoot.descendants().filter(d => 
        !collapsedNodes.has(d.data.id)
    );
    
    const nodes = g.selectAll('.dendrogram-node')
        .data(visibleNodeData)
        .enter()
        .append('g')
        .attr('class', d => {
            let classes = `dendrogram-node ${d.children ? '' : 'leaf'}`;
            if (focusedNode && d.data.id === focusedNode.data.id) {
                classes += ' focused';
            }
            if (collapsedNodes.has(d.data.id)) {
                classes += ' has-hidden-children';
            }
            return classes;
        })
        .attr('transform', nodeTransform)
        .on('click', function(event, d) {
            event.stopPropagation();
            handleNodeFocus(d);
        })
        .on('dblclick', function(event, d) {
            event.stopPropagation();
            toggleNodeCollapse(d);
        })
        .on('mouseover', function(event, d) {
            showDendrogramTooltip(event, d);
        })
        .on('mouseout', function() {
            hideDendrogramTooltip();
        });
    
    // Add circles to nodes with dynamic sizing
    nodes.append('circle')
        .attr('r', d => {
            const baseSize = d.children ? 5 : 4;
            const focusBonus = (focusedNode && d.data.id === focusedNode.data.id) ? 2 : 0;
            return baseSize + focusBonus;
        })
        .style('fill', d => {
            if (focusedNode && d.data.id === focusedNode.data.id) return '#fff5f5';
            return d.children ? '#fff' : '#28a745';
        })
        .style('stroke', d => {
            if (focusedNode && d.data.id === focusedNode.data.id) return '#dc3545';
            return d.children ? '#007bff' : '#1e7e34';
        })
        .style('stroke-width', d => {
            if (focusedNode && d.data.id === focusedNode.data.id) return 4;
            return 2;
        });
    
    // Add labels with smart positioning
    const labelType = document.getElementById('dendrogram-labels').value;
    
    if (labelType !== 'none') {
        addSmartDendrogramLabels(nodes, labelType, filteredRoot);
    }
    
    // Store reference for later use
    dendrogramSvg = svg;
    
    // Update breadcrumb
    updateBreadcrumb();
}

function addSmartDendrogramLabels(nodes, labelType, root) {
    // Calculate label priorities based on node importance
    const labelPriorities = calculateLabelPriorities(root);
    
    if (labelType === 'smart') {
        // Smart adaptive labeling
        nodes.each(function(d) {
            const priority = labelPriorities.get(d.data.id) || 'low';
            const nodeSelection = d3.select(this);
            
            // Only show labels for high and medium priority nodes to avoid clutter
            if (priority === 'high' || priority === 'medium') {
                const textToShow = d.data.representativeText || d.data.name;
                const maxLength = priority === 'high' ? 40 : 25;
                const isRepresentativeText = d.data.representativeText && textToShow === d.data.representativeText;
                
                const textElement = nodeSelection.append('text')
                    .attr('class', () => {
                        let classes = `dendrogram-text smart-positioned priority-${priority} depth-${Math.min(d.depth, 5)}`;
                        if (isRepresentativeText) {
                            const textState = d.data.text_state || 'default';
                            classes += ` representative-text state-${textState}`;
                        }
                        return classes;
                    })
                    .attr('x', d => d.children ? -6 : 10)
                    .attr('y', -5)
                    .attr('transform', d => `rotate(-19, ${d.children ? -6 : 10}, -5)`)
                    .style('text-anchor', 'start'); // Always start from the node
                
                // Add multi-line text
                addMultiLineText(textElement, textToShow, maxLength);
                
                // Hide text for nodes deeper than 5 levels from current focus root
                if (shouldHideTextForDepth(d)) {
                    textElement.classed('depth-hidden', true);
                }
            }
        });
    } else {
        // Traditional labeling modes
        if (labelType === 'cluster' || labelType === 'both') {
            const clusterTexts = nodes.append('text')
                .attr('class', d => `dendrogram-text cluster-label depth-${Math.min(d.depth, 5)}`)
                .attr('x', d => d.children ? -6 : 10)
                .attr('y', d => d.children ? -13 : -5)
                .attr('transform', d => {
                    const x = d.children ? -6 : 10;
                    const y = d.children ? -13 : -5;
                    return `rotate(-19, ${x}, ${y})`;
                })
                .style('text-anchor', 'start'); // Always start from the node
            
            // Add multi-line text to cluster labels
            clusterTexts.each(function(d) {
                addMultiLineText(d3.select(this), d.data.name, 20);
            });
            
            // Hide text for deep nodes
            clusterTexts.classed('depth-hidden', d => shouldHideTextForDepth(d));
        }
        
        if (labelType === 'representative' || labelType === 'both') {
            const repTexts = nodes.append('text')
                .attr('class', d => {
                    const textState = d.data.text_state || 'default';
                    return `dendrogram-text representative-text state-${textState} depth-${Math.min(d.depth, 5)}`;
                })
                .attr('x', d => d.children ? -6 : 10)
                .attr('y', d => {
                    if (labelType === 'both') {
                        return d.children ? 3 : 10;
                    } else {
                        return d.children ? -13 : -5;
                    }
                })
                .attr('transform', d => {
                    const x = d.children ? -6 : 10;
                    const y = labelType === 'both' 
                        ? (d.children ? 3 : 10)
                        : (d.children ? -13 : -5);
                    return `rotate(-19, ${x}, ${y})`;
                })
                .style('text-anchor', 'start'); // Always start from the node
            
            // Add multi-line text to representative labels
            repTexts.each(function(d) {
                addMultiLineText(d3.select(this), d.data.representativeText, 25);
            });
            
            // Hide text for deep nodes
            repTexts.classed('depth-hidden', d => shouldHideTextForDepth(d));
        }
    }
}

function calculateLabelPriorities(root) {
    const priorities = new Map();
    const totalNodes = root.descendants().length;
    
    root.descendants().forEach(d => {
        let priority = 'low';
        
        // High priority: root, focused node, nodes with many children, leaf nodes with interesting content
        if (d === root || 
            (focusedNode && d.data.id === focusedNode.data.id) ||
            (d.children && d.children.length > 5) ||
            (d.depth <= 2 && totalNodes > 50)) {
            priority = 'high';
        }
        // Medium priority: intermediate nodes with some children
        else if (d.children && d.children.length > 2) {
            priority = 'medium';
        }
        // Low priority: small leaf clusters, deep nodes
        else if (d.depth > 4 || (!d.children && d.data.size < 3)) {
            priority = 'low';
        }
        
        priorities.set(d.data.id, priority);
    });
    
    return priorities;
}

function shouldHideTextForDepth(d) {
    // Hide text for nodes deeper than 5 levels from the current view root
    // d.depth is relative to the current focused subtree root
    return d.depth > 5;
}

function addMultiLineText(textElement, fullText, maxCharsPerLine) {
    if (!fullText) return;
    
    // Split text into words
    const words = fullText.split(' ');
    let line1 = '';
    let line2 = '';
    let currentLine = 1;
    
    // Build lines word by word
    for (let i = 0; i < words.length; i++) {
        const word = words[i];
        const testLine = currentLine === 1 
            ? (line1 ? line1 + ' ' + word : word)
            : (line2 ? line2 + ' ' + word : word);
        
        if (testLine.length <= maxCharsPerLine) {
            // Word fits on current line
            if (currentLine === 1) {
                line1 = testLine;
            } else {
                line2 = testLine;
            }
        } else {
            // Word doesn't fit
            if (currentLine === 1 && line1) {
                // Move to second line
                currentLine = 2;
                line2 = word;
            } else {
                // Second line is full, truncate with ellipsis
                if (currentLine === 1) {
                    line1 = truncateText(line1, maxCharsPerLine - 3) + '...';
                } else {
                    line2 = truncateText(line2, maxCharsPerLine - 3) + '...';
                }
                break;
            }
        }
    }
    
    // Determine if we have two lines
    const hasTwoLines = line1 && line2;
    
    // Add the text lines as tspan elements
    if (line1) {
        textElement.append('tspan')
            .attr('x', textElement.attr('x'))
            .attr('dy', hasTwoLines ? '-0.55em' : 0) // Shift up by half line height if two lines
            .text(line1);
    }
    
    if (line2) {
        textElement.append('tspan')
            .attr('x', textElement.attr('x'))
            .attr('dy', '1.1em') // Move to next line
            .text(line2);
    }
}

function calculateMaxVisibleDepth(root) {
    const totalNodes = root.descendants().length;
    
    // Progressive loading based on tree size
    if (totalNodes > 1000) return 4;
    if (totalNodes > 500) return 5;
    if (totalNodes > 100) return 6;
    return 8; // Show full depth for smaller trees
}

function filterTreeByDepth(root, maxDepth) {
    // Clone the tree structure but limit depth
    function cloneWithDepthLimit(node, currentDepth) {
        const cloned = {
            data: node.data,
            depth: currentDepth,
            children: []
        };
        
        if (currentDepth < maxDepth && node.children) {
            cloned.children = node.children.map(child => 
                cloneWithDepthLimit(child, currentDepth + 1)
            );
        }
        
        return cloned;
    }
    
    return d3.hierarchy(cloneWithDepthLimit(root, 0).data);
}

function handleNodeFocus(d) {
    // Set focus to this node
    focusedNode = d;
    
    // Update focus path for breadcrumb
    updateFocusPath(d);
    
    // Recreate the dendrogram focused on this subtree
    createDendrogram();
    
    // Reset zoom to fit the new focused tree
    setTimeout(() => {
        if (dendrogramSvg && dendrogramZoom) {
            dendrogramSvg.transition().duration(500).call(
                dendrogramZoom.transform,
                d3.zoomIdentity.scale(1)
            );
        }
    }, 100);
}

function updateFocusPath(focusNode) {
    // Build the COMPLETE path from original root to focused node
    focusPath = [];
    
    // We need to find the complete path in the original tree structure
    const completePath = findCompletePathToNode(dendrogramData, focusNode.data.id);
    
    if (completePath) {
        focusPath = completePath.map((nodeData, index) => ({
            id: nodeData.id,
            name: nodeData.name || nodeData.label || `Node ${nodeData.id}`,
            nodeData: nodeData,
            isRoot: index === 0
        }));
    } else {
        // Fallback: just add the current focused node
        focusPath = [{
            id: focusNode.data.id,
            name: focusNode.data.name,
            nodeData: focusNode.data,
            isRoot: false
        }];
    }
    
    // Always ensure we start with root
    if (focusPath.length === 0 || focusPath[0].id !== dendrogramData.id) {
        focusPath.unshift({
            id: dendrogramData.id,
            name: 'Root',
            nodeData: dendrogramData,
            isRoot: true
        });
    }
}

function findCompletePathToNode(rootData, targetNodeId, currentPath = []) {
    // Add current node to path
    const newPath = [...currentPath, rootData];
    
    // If this is our target, return the complete path
    if (rootData.id === targetNodeId) {
        return newPath;
    }
    
    // Search in children
    if (rootData.children) {
        for (const child of rootData.children) {
            const result = findCompletePathToNode(child, targetNodeId, newPath);
            if (result) {
                return result;
            }
        }
    }
    
    // Not found in this branch
    return null;
}

function updateBreadcrumb() {
    const breadcrumbContainer = document.getElementById('breadcrumb-path');
    const breadcrumbSection = document.getElementById('dendrogram-breadcrumb');
    
    if (focusPath.length <= 1) {
        breadcrumbSection.style.display = 'none';
        return;
    }
    
    breadcrumbSection.style.display = 'block';
    breadcrumbContainer.innerHTML = '';
    
    focusPath.forEach((item, index) => {
        if (index > 0) {
            const separator = document.createElement('span');
            separator.className = 'breadcrumb-separator';
            separator.textContent = '>';
            breadcrumbContainer.appendChild(separator);
        }
        
        const breadcrumbItem = document.createElement('span');
        breadcrumbItem.className = 'breadcrumb-item';
        breadcrumbItem.textContent = truncateText(item.name, 15);
        breadcrumbItem.title = item.name;
        
        if (index < focusPath.length - 1) {
            breadcrumbItem.addEventListener('click', () => {
                if (item.isRoot) {
                    // Return to root
                    focusedNode = null;
                    focusPath = [];
                    createDendrogram();
                } else {
                    // Focus on this specific node by recreating its hierarchy node
                    focusToNodeById(item.id);
                }
            });
        } else {
            // Current focused item - highlight it
            breadcrumbItem.style.backgroundColor = '#007bff';
            breadcrumbItem.style.color = 'white';
        }
        
        breadcrumbContainer.appendChild(breadcrumbItem);
    });
}

function focusToNodeById(nodeId) {
    // Find the node in the original tree and focus on it
    const nodeData = findNodeInTree(dendrogramData, nodeId);
    if (nodeData) {
        // Create a D3 hierarchy node for this data
        const hierarchyNode = d3.hierarchy(nodeData);
        handleNodeFocus(hierarchyNode);
    }
}

function findNodeInTree(rootData, targetId) {
    if (rootData.id === targetId) {
        return rootData;
    }
    
    if (rootData.children) {
        for (const child of rootData.children) {
            const result = findNodeInTree(child, targetId);
            if (result) {
                return result;
            }
        }
    }
    
    return null;
}

function toggleNodeCollapse(d) {
    const nodeId = d.data.id;
    
    if (collapsedNodes.has(nodeId)) {
        collapsedNodes.delete(nodeId);
    } else {
        collapsedNodes.add(nodeId);
    }
    
    // Recreate dendrogram with updated collapsed state
    createDendrogram();
}

function returnToRoot() {
    focusedNode = null;
    focusPath = [];
    collapsedNodes.clear();
    createDendrogram();
}

function showDendrogramTooltip(event, d) {
    const tooltip = document.getElementById('dendrogram-tooltip');
    const content = document.getElementById('tooltip-content');
    
    let tooltipHtml = `
        <div><strong>${d.data.name}</strong></div>
        <div>Size: ${d.data.size} goals</div>
    `;
    
    if (d.data.representativeText) {
        tooltipHtml += `<div>Representative: ${d.data.representativeText}</div>`;
    }
    
    if (d.data.goals && d.data.goals.length > 0) {
        tooltipHtml += `<div>Direct goals: ${d.data.goals.length}</div>`;
        if (d.data.goals.length <= 3) {
            tooltipHtml += '<div><strong>Goals:</strong></div>';
            d.data.goals.forEach(goal => {
                tooltipHtml += `<div>• ${truncateText(goal, 60)}</div>`;
            });
        }
    }
    
    // Add interaction hints
    if (d.children) {
        tooltipHtml += '<hr><div><small><strong>Click:</strong> Focus on this subtree</small></div>';
        tooltipHtml += '<div><small><strong>Double-click:</strong> Collapse/expand</small></div>';
    } else {
        tooltipHtml += '<hr><div><small><strong>Click:</strong> Focus on this leaf</small></div>';
    }
    
    content.innerHTML = tooltipHtml;
    
    // Position tooltip
    const rect = document.getElementById('dendrogram-container').getBoundingClientRect();
    tooltip.style.left = (event.clientX - rect.left + 10) + 'px';
    tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
    tooltip.style.display = 'block';
}

function hideDendrogramTooltip() {
    document.getElementById('dendrogram-tooltip').style.display = 'none';
}

// Event handlers for dendrogram controls
$(document).ready(function() {

    
    // Layout change
    $('#dendrogram-layout').on('change', function() {
        currentLayout = $(this).val();
        if (dendrogramData) {
            createDendrogram();
        }
    });
    
    // Labels change
    $('#dendrogram-labels').on('change', function() {
        if (dendrogramData) {
            createDendrogram();
        }
    });
    
    // Focus home
    $('#dendrogram-focus-home').on('click', function() {
        returnToRoot();
    });
    
    // Reset view
    $('#dendrogram-reset').on('click', function() {
        if (dendrogramSvg && dendrogramZoom) {
            dendrogramSvg.transition().duration(500).call(
                dendrogramZoom.transform,
                d3.zoomIdentity
            );
        }
    });
    
    // Export SVG
    $('#dendrogram-export').on('click', function() {
        exportDendrogramSVG();
    });
});

function exportDendrogramSVG() {
    if (!dendrogramSvg) {
        alert('No dendrogram to export');
        return;
    }
    
    // Clone the SVG
    const svgElement = dendrogramSvg.node();
    const svgClone = svgElement.cloneNode(true);
    
    // Add some basic styling to the exported SVG
    const style = document.createElement('style');
    style.textContent = `
        .dendrogram-link { fill: none; stroke: #6c757d; stroke-width: 1.5px; }
        .dendrogram-node circle { fill: #fff; stroke: #007bff; stroke-width: 2px; }
        .dendrogram-node.leaf circle { fill: #28a745; stroke: #1e7e34; }
        .dendrogram-text { font-family: Arial, sans-serif; font-size: 11px; fill: #495057; }
        .dendrogram-text.cluster-label { font-weight: 600; fill: #007bff; }
        .dendrogram-text.representative-text { font-size: 10px; fill: #6c757d; font-style: italic; }
    `;
    svgClone.insertBefore(style, svgClone.firstChild);
    
    // Convert to blob and download
    const svgData = new XMLSerializer().serializeToString(svgClone);
    const blob = new Blob([svgData], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = `dendrogram-${currentArtifact.name || 'tree'}.svg`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    URL.revokeObjectURL(url);
}

// Document Modal Functions
function openDocumentModal(documentName, creator) {
    // Remove quotes and clean up the document name and creator
    const cleanDocumentName = documentName.replace(/['"]/g, '');
    const cleanCreator = creator.replace(/['"]/g, '');
    
    console.log('Opening modal for document:', cleanDocumentName, 'by', cleanCreator);
    
    // Show loading state
    $('#documentModalLabel').text('Loading Document...');
    $('#documentModalBody').html(`
        <div class="text-center p-4">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <p class="mt-2">Loading document details...</p>
        </div>
    `);
    
    // Show the modal
    $('#documentModal').modal('show');
    
    // Make API call to find the document
    $.ajax({
        url: '/api/find-document-by-name',
        method: 'GET',
        data: {
            name: cleanDocumentName,
            creator: cleanCreator
        },
        success: function(document) {
            displayDocumentInModal(document);
        },
        error: function(xhr) {
            let errorMessage = 'Unable to load document';
            if (xhr.responseJSON && xhr.responseJSON.error) {
                errorMessage = xhr.responseJSON.error;
            }
            $('#documentModalBody').html(`
                <div class="alert alert-danger">
                    <i class="bi bi-exclamation-triangle"></i> ${errorMessage}
                </div>
            `);
        }
    });
}

function displayDocumentInModal(document) {
    $('#documentModalLabel').text(`Document: ${document.name}`);
    
    // Build the modal content similar to the view page
    let modalContent = `
        <div class="document-metadata mb-4">
            <div class="row mb-2">
                <div class="col-md-4">
                    <strong>Original Filename:</strong>
                    <p class="mb-1">${document.original_filename || 'N/A'}</p>
                </div>
                <div class="col-md-4">
                    <strong>Creator:</strong>
                    <p class="mb-1">${document.creator || 'N/A'}</p>
                </div>
                <div class="col-md-4">
                    <strong>Course:</strong>
                    <p class="mb-1">${document.course_name || 'N/A'}</p>
                </div>
            </div>
            <div class="row mb-2">
                <div class="col-md-4">
                    <strong>Institution:</strong>
                    <p class="mb-1">${document.institution || 'N/A'}</p>
                </div>
                <div class="col-md-4">
                    <strong>Document Type:</strong>
                    <p class="mb-1">${document.doc_type || 'N/A'}</p>
                </div>
                <div class="col-md-4">
                    <strong>Upload Date:</strong>
                    <p class="mb-1">${document.created_at || 'N/A'}</p>
                </div>
            </div>`;
    
    if (document.notes) {
        modalContent += `
            <div class="row">
                <div class="col-md-12">
                    <strong>Notes:</strong>
                    <div class="notes-box bg-light p-3 border-start border-secondary border-4 rounded">
                        <p class="mb-0">${document.notes}</p>
                    </div>
                </div>
            </div>`;
    }
    
    modalContent += `</div>`;
    
    // Add learning goals section
    modalContent += `
        <h5 class="mb-3">Learning Goals:</h5>
        <div class="learning-goals-container mb-4">`;
    
    if (document.learning_goals && document.learning_goals.length > 0) {
        modalContent += `
            <div class="learning-goals-list" style="max-height: 200px; overflow-y: auto;">
                <ul class="list-group list-group-flush">`;
        
        document.learning_goals.forEach(goal => {
            modalContent += `<li class="list-group-item">${goal}</li>`;
        });
        
        modalContent += `
                </ul>
            </div>`;
    } else {
        modalContent += `<p class="text-muted">No learning goals available for this document.</p>`;
    }
    
    modalContent += `</div>`;
    
    // Add document preview section
    modalContent += `
        <h5 class="mb-3">Document Preview:</h5>
        <div class="pdf-container">
            <div id="modal-pdf-loading" class="text-center p-4">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading document...</span>
                </div>
                <p class="mt-2">Loading document preview...</p>
            </div>
            <iframe id="modal-pdf-iframe" style="width: 100%; height: 400px; border: 1px solid #ddd; border-radius: 4px; display: none;"></iframe>
            <div id="modal-pdf-error" class="alert alert-danger" style="display: none;">
                <i class="bi bi-exclamation-triangle"></i> 
                <span id="modal-error-message">Unable to load document preview.</span>
            </div>
        </div>`;
    
    $('#documentModalBody').html(modalContent);
    
    // Load the document preview
    loadDocumentPreviewInModal(document.id);
}

function loadDocumentPreviewInModal(documentId) {
    $.ajax({
        url: `/document-url/${documentId}`,
        method: 'GET',
        success: function(response) {
            if (response.url) {
                // Hide loading spinner
                $('#modal-pdf-loading').hide();
                
                // Set iframe source and show it
                $('#modal-pdf-iframe').attr('src', response.url).show();
                
                // Show correction message if path was corrected
                if (response.corrected) {
                    console.log('Document storage path was automatically corrected');
                }
            } else {
                showModalPdfError('Invalid response from server');
            }
        },
        error: function(xhr) {
            let errorMessage = 'Unable to load document preview';
            if (xhr.responseJSON && xhr.responseJSON.error) {
                errorMessage = xhr.responseJSON.error;
            }
            showModalPdfError(errorMessage);
        }
    });
}

function showModalPdfError(message) {
    $('#modal-pdf-loading').hide();
    $('#modal-pdf-iframe').hide();
    $('#modal-error-message').text(message);
    $('#modal-pdf-error').show();
}

</script>

<!-- Document Modal -->
<div class="modal fade" id="documentModal" tabindex="-1" aria-labelledby="documentModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="documentModalLabel">Document</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body" id="documentModalBody">
                <!-- Content will be dynamically loaded here -->
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

{% endblock %}