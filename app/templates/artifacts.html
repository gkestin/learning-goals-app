{% extends "base.html" %}

{% block title %}Tree Artifacts{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
    .clustering-controls {
        background-color: #f8f9fa;
        padding: 10px;
        border-radius: 6px;
        margin-bottom: 5px;
    }
    
    /* Tree Structure Styling - updated for new layout */
    .tree-container {
        font-family: 'Monaco', 'Consolas', monospace;
        background-color: #f8f9fa;
        border-radius: 8px;
        padding: 12px;
        margin-top: 0px;
        margin-bottom: 15px;
    }
    
    .tree-node {
        margin: 2px 0;
        border-left: 2px solid transparent;
        transition: all 0.2s ease;
    }
    
    .tree-node:hover {
        background-color: rgba(0, 123, 255, 0.05);
        border-left-color: #007bff;
    }
    
    /* Smart indentation - consistent small increments */
    .tree-level-0 { margin-left: 0px; }
    .tree-level-1,
    .tree-level-2,
    .tree-level-3,
    .tree-level-4,
    .tree-level-5,
    .tree-level-6,
    .tree-level-7,
    .tree-level-8,
    .tree-level-9,
    .tree-level-10,
    .tree-level-deep { /* All non-root levels get the same single-step indent */
        margin-left: 12px;
    }
    
    /* Beyond level 10, use a different visual cue */
    .tree-level-deep {
        /* margin-left: 12px; is handled above */
        border-left: 3px dotted #6c757d; /* This border is part of the node itself */
        padding-left: 10px; /* This will indent the *content* of tree-level-deep nodes further */
    }
    
    .cluster-header {
        display: flex;
        align-items: center;
        padding: 8px 12px;
        cursor: pointer;
        background-color: white;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        margin-bottom: 3px;
        transition: all 0.2s ease;
    }
    
    .cluster-header:hover {
        background-color: #e3f2fd;
        border-color: #007bff;
        transform: translateX(2px);
    }
    
    .cluster-header.expanded {
        background-color: #e8f5e9;
        border-color: #28a745;
    }
    
    /* Style for nodes that don't subdivide (single child) */
    .cluster-header.no-subdivision {
        background-color: #f8f9fa;
        border-style: dashed;
        opacity: 0.8;
    }
    
    .cluster-header.no-subdivision:hover {
        background-color: #e9ecef;
        opacity: 1;
    }
    
    /* NEW: Representative text styling - now the main editable element */
    .cluster-representative {
        font-size: 1em;
        font-weight: bold;
        color: #212529;
        background-color: transparent;
        border: 1px solid transparent;
        border-radius: 4px;
        padding: 4px 8px;
        margin-right: 8px;
        flex: 1;
        min-height: 24px;
        cursor: text;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 6px;
    }
    
    .cluster-representative:hover {
        border-color: #007bff;
        background-color: rgba(255, 255, 255, 0.8);
    }
    
    .cluster-representative.editing {
        border-color: #28a745;
        background-color: white;
        outline: none;
        box-shadow: 0 0 0 0.2rem rgba(40, 167, 69, 0.25);
    }
    
    /* FontAwesome state icons */
    .text-state-icon {
        font-size: 0.8em;
        opacity: 0.7;
        margin-right: 4px;
        flex-shrink: 0;
    }
    
    .text-state-icon.fa-quote-left {
        color: #6c757d;
    }
    
    .text-state-icon.fa-pencil {
        color: #228B22; /* Green for manual edit */
    }
    
    .text-state-icon.fa-wand-magic-sparkles {
        color: #6f42c1;
    }
    
    /* State-based text coloring for representative text */
    .cluster-representative[data-state="default"] .representative-text,
    .cluster-representative:not([data-state]) .representative-text {
        color: #495057; /* Dark grey for default/representative */
    }
    
    .cluster-representative[data-state="manual"] .representative-text {
        color: #228B22; /* Green for manually edited */
    }
    
    .cluster-representative[data-state="ai"] .representative-text {
        color: #6f42c1; /* Purple for AI generated */
    }
    
    /* Auto-generate button */
    .auto-generate-btn {
        background: linear-gradient(135deg, #f8f9fa, #e9ecef);
        border: 1px solid #6f42c1;
        border-radius: 6px;
        padding: 6px 10px;
        margin-right: 12px;
        cursor: pointer;
        color: #6f42c1;
        font-size: 0.75em;
        transition: all 0.2s ease;
        flex-shrink: 0;
        box-shadow: 0 1px 2px rgba(111, 66, 193, 0.1);
    }
    
    .auto-generate-btn:hover {
        background: linear-gradient(135deg, #6f42c1, #8a5cf5);
        border-color: #6f42c1;
        color: white;
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(111, 66, 193, 0.2);
    }
    
    /* NEW: Small gray label - now secondary with more spacing */
    .cluster-label {
        font-size: 0.75em;
        color: #6c757d;
        font-weight: normal;
        margin-right: 15px;
        margin-left: 5px;
        padding: 2px 6px;
        background-color: #f8f9fa;
        border-radius: 3px;
        flex-shrink: 0;
    }
    
    .cluster-size {
        background-color: #007bff;
        color: white;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.8em;
        margin-left: auto;
        flex-shrink: 0;
    }
    
    .cluster-actions {
        margin-left: 8px;
        display: flex;
        gap: 5px;
    }
    
    .collapse-icon {
        transition: transform 0.2s ease;
        margin-right: 8px;
        color: #6c757d;
        flex-shrink: 0;
    }
    
    .collapse-icon.expanded {
        transform: rotate(90deg);
    }
    
    .cluster-content {
        padding: 15px 8px 15px 0px;
        background-color: #f8f9fa;
        border: 1px solid #dee2e6;
        border-top: none;
        border-radius: 0 0 6px 6px;
        margin-bottom: 10px;
    }
    
    .goal-item {
        padding: 8px 12px;
        margin: 5px 0;
        background-color: white;
        border-left: 3px solid #007bff;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    
    .goal-text {
        font-size: 0.9em;
        line-height: 1.4;
        margin-bottom: 4px;
        color: #343a40;
    }
    
    .goal-source {
        font-size: 0.6em;
        color: #6c757d;
        font-style: italic;
    }
    
    .document-link {
        color: #007bff;
        cursor: pointer;
        text-decoration: none;
        transition: color 0.2s ease;
    }
    
    .document-link:hover {
        color: #0056b3;
        text-decoration: underline;
    }
    
    .clustering-stats {
        background-color: #e3f2fd;
        border: 1px solid #90caf9;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
    }
    
    /* Subtle artifact info styling - much cleaner than clustering-stats */
    .artifact-info {
        color: #6c757d;
        font-size: 0.9em;
        margin-bottom: 5px;
        padding: 4px 0;
        border-bottom: 1px solid #e9ecef;
    }
    
    .artifact-info .artifact-name {
        font-weight: 600;
        color: #495057;
        margin-right: 12px;
    }
    
    .artifact-info .artifact-details {
        display: inline;
        font-size: 0.85em;
    }
    
    .artifact-info .artifact-details span {
        margin-right: 20px;
        white-space: nowrap;
    }
    
    .artifact-info .artifact-details span:last-child {
        margin-right: 0;
    }
    
    /* Level Controls - matching cluster_tree */
    .level-button {
        font-weight: bold;
        min-width: 80px;
        min-height: 60px;
        text-align: center;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding: 8px 12px;
        line-height: 1.2;
    }
    
    .level-button.active {
        background-color: #28a745;
        border-color: #28a745;
        color: white;
    }
    
    /* Flattened Content */
    .flattened-cluster {
        margin-bottom: 20px;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        overflow: hidden;
    }
    
    .flattened-cluster-header {
        background-color: #f8f9fa;
        padding: 12px 15px;
        border-bottom: 1px solid #dee2e6;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .flattened-cluster-title {
        font-weight: bold;
        color: #495057;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .flattened-cluster-content {
        padding: 15px;
        background-color: white;
    }
    
    .artifact-badge {
        background: linear-gradient(45deg, #6f42c1, #e83e8c);
        color: white;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 0.7em;
        font-weight: bold;
    }

    /* AI Generation Modal */
    .goal-preview {
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        padding: 10px;
        background-color: #f8f9fa;
        font-size: 0.85em;
    }
    
    .goal-preview-item {
        padding: 4px 0;
        border-bottom: 1px solid #e9ecef;
    }
    
    .goal-preview-item:last-child {
        border-bottom: none;
    }
    
    .goal-preview-text {
        font-weight: 500;
        color: #495057;
    }
    
    .goal-preview-source {
        font-size: 0.75em;
        color: #6c757d;
        margin-top: 2px;
    }
    
    /* Collapsible artifact selection styling */
    .artifact-selection-container {
        margin-bottom: 5px;
    }
    
    .collapsed-title {
        padding: 5px 0;
        margin-bottom: 5px;
    }
    
    .collapsed-title .btn {
        font-size: 0.85em;
        color: #6c757d !important;
        transition: all 0.2s ease;
    }
    
    .collapsed-title .btn:hover {
        color: #6f42c1 !important;
    }
    
    .collapsed-title .btn i {
        transition: transform 0.2s ease;
    }
    
    /* Show collapsed title only when section is collapsed */
    .artifact-selection-container:has(#artifact-selection.show) .collapsed-title,
    .artifact-selection-container:has(#artifact-selection.collapsing) .collapsed-title {
        display: none;
    }
    
    /* Alternative approach for broader browser support */
    .collapsed-title.hidden {
        display: none;
    }
    
    /* Chevron rotation */
    .collapsed-title .btn[aria-expanded="true"] i {
        transform: rotate(90deg);
    }

    /* Move/Delete Action Buttons */
    .action-buttons {
        display: flex;
        gap: 5px;
        margin-left: 8px;
        flex-shrink: 0;
    }
    
    .move-btn, .delete-btn {
        padding: 4px 6px;
        border-radius: 4px;
        border: 1px solid;
        cursor: pointer;
        font-size: 0.7em;
        transition: all 0.2s ease;
        background-color: white;
        opacity: 0.7;
        min-width: 24px;
        text-align: center;
    }
    
    .move-btn {
        border-color: #17a2b8;
        color: #17a2b8;
    }
    
    .move-btn:hover {
        background-color: #17a2b8;
        color: white;
        opacity: 1;
        transform: scale(1.1);
    }
    
    .delete-btn {
        border-color: #dc3545;
        color: #dc3545;
    }
    
    .delete-btn:hover {
        background-color: #dc3545;
        color: white;
        opacity: 1;
        transform: scale(1.1);
    }
    
    .delete-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
        border-color: #6c757d;
        color: #6c757d;
    }
    
    .delete-btn:disabled:hover {
        background-color: white;
        color: #6c757d;
        transform: none;
    }

    /* Individual Goal Move/Delete Buttons */
    .goal-actions {
        display: flex;
        gap: 4px;
        margin-top: 4px;
        margin-left: auto;
        opacity: 0;
        transition: opacity 0.2s ease;
    }
    
    .goal-item:hover .goal-actions {
        opacity: 1;
    }
    
    .goal-move-btn, .goal-delete-btn {
        padding: 2px 4px;
        border-radius: 3px;
        border: 1px solid;
        cursor: pointer;
        font-size: 0.6em;
        transition: all 0.2s ease;
        background-color: white;
        min-width: 20px;
        text-align: center;
    }
    
    .goal-move-btn {
        border-color: #17a2b8;
        color: #17a2b8;
    }
    
    .goal-move-btn:hover {
        background-color: #17a2b8;
        color: white;
    }
    
    .goal-delete-btn {
        border-color: #dc3545;
        color: #dc3545;
    }
    
    .goal-delete-btn:hover {
        background-color: #dc3545;
        color: white;
    }

    /* Archive Button */
    .archive-btn {
        background-color: #f8f9fa;
        border: 1px solid #6c757d;
        color: #6c757d;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.7em;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .archive-btn:hover {
        background-color: #6c757d;
        color: white;
    }

    /* Move Modal Styles */
    .move-modal .modal-dialog {
        max-width: 700px;
    }
    
    .move-destination-tree {
        max-height: 400px;
        overflow-y: auto;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 10px;
        background-color: #f8f9fa;
    }
    
    .destination-node {
        margin: 2px 0;
        padding: 4px 8px;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .destination-node:hover {
        background-color: #e3f2fd;
    }
    
    .destination-node.current-location {
        background-color: #fff3e0;
        border: 1px solid #ff9800;
    }
    
    .destination-node.invalid-destination {
        background-color: #ffebee;
        opacity: 0.6;
        cursor: not-allowed;
    }
    
    .destination-node-content {
        flex: 1;
        display: flex;
        align-items: center;
    }
    
    .destination-node-text {
        font-weight: 500;
        flex-grow: 1;
    }
    
    .destination-path-info {
        flex-shrink: 0;
        opacity: 0.7;
        transition: opacity 0.2s ease;
    }
    
    .destination-path-info:hover {
        opacity: 1;
        color: #007bff !important;
    }
    
    .move-here-btn {
        padding: 2px 8px;
        font-size: 0.7em;
        border-radius: 3px;
        background-color: #28a745;
        border: 1px solid #28a745;
        color: white;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .move-here-btn:hover {
        background-color: #218838;
        transform: scale(1.05);
    }
    
    .move-search-input {
        margin-bottom: 15px;
        padding: 8px 12px;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        font-size: 0.9em;
        width: 100%;
    }
    
    .move-search-input:focus {
        outline: none;
        border-color: #007bff;
        box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
    }
    
    .destination-node.search-match {
        background-color: #fff9c4;
        border: 1px solid #fbc02d;
    }
    
    .destination-node.search-match .destination-node-text {
        font-weight: bold;
    }

    /* New Group Creation Styles */
    .new-group-tree-selector {
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 10px;
        background-color: #f8f9fa;
    }
    
    .tree-level-item {
        margin: 3px 0;
        padding: 6px 10px;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 8px;
        border: 1px solid transparent;
    }
    
    .tree-level-item:hover {
        background-color: #e3f2fd;
        border-color: #2196f3;
    }
    
    .tree-level-item.selected {
        background-color: #c8e6c9;
        border-color: #4caf50;
        font-weight: 500;
    }
    
    .tree-level-item .expand-icon {
        transition: transform 0.2s ease;
        color: #6c757d;
        font-size: 0.8em;
        width: 12px;
        text-align: center;
    }
    
    .tree-level-item.expanded .expand-icon {
        transform: rotate(90deg);
    }
    
    .tree-level-item.leaf .expand-icon {
        opacity: 0.3;
    }
    
    .tree-level-text {
        flex-grow: 1;
    }
    
    .select-location-btn {
        padding: 2px 8px;
        font-size: 0.7em;
        border-radius: 3px;
        background-color: #28a745;
        border: 1px solid #28a745;
        color: white;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .select-location-btn:hover {
        background-color: #218838;
        transform: scale(1.05);
    }
    
    .tree-children {
        margin-left: 20px;
        margin-top: 5px;
        border-left: 1px dashed #dee2e6;
        padding-left: 10px;
    }

    /* Archive Modal Styles */
    .archived-goals-container {
        max-height: 400px;
        overflow-y: auto;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 15px;
        background-color: #f8f9fa;
    }

    /* Search Functionality Styles */
    .search-container {
        margin-bottom: 15px;
        position: relative;
    }
    
    .search-input {
        width: 100%;
        padding: 10px 40px 10px 35px;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        font-size: 0.9em;
        transition: all 0.2s ease;
        line-height: 1.2;
        height: 40px;
        box-sizing: border-box;
    }
    
    .search-input:focus {
        outline: none;
        border-color: #007bff;
        box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
    }
    
    .search-icon {
        position: absolute;
        left: 12px;
        top: 50%;
        transform: translateY(-50%);
        color: #6c757d;
        font-size: 14px;
        pointer-events: none;
        z-index: 2;
        line-height: 1;
        display: flex;
        align-items: center;
        height: 16px;
        margin-top: -8px;
    }
    
    .search-clear {
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        background: none;
        border: none;
        color: #6c757d;
        cursor: pointer;
        padding: 2px;
        border-radius: 3px;
        display: none;
        z-index: 2;
        line-height: 1;
        font-size: 14px;
        width: 20px;
        height: 20px;
        margin-top: -10px;
        align-items: center;
        justify-content: center;
    }
    
    .search-clear:not([style*="display: none"]) {
        display: flex;
    }
    
    .search-clear:hover {
        background-color: #f8f9fa;
        color: #495057;
    }
    
    .search-results-info {
        font-size: 0.8em;
        color: #6c757d;
        margin-top: 5px;
        min-height: 1rem;
    }
    
    /* Search highlighting */
    .search-highlight {
        background-color: #fff3cd;
        border: 1px solid #fbc02d;
        border-radius: 2px;
        padding: 1px 2px;
        font-weight: 500;
    }
    
    /* Search match indicators */
    .search-match-cluster {
        border-left: 3px solid #28a745 !important;
        background-color: rgba(40, 167, 69, 0.05);
    }
    
    .search-match-goal {
        border-left: 3px solid #007bff !important;
        background-color: rgba(0, 123, 255, 0.05);
    }
    
    .search-hidden {
        display: none !important;
    }

    /* Subtle Download Controls */
    .download-controls {
        display: flex;
        align-items: center;
        gap: 8px;
        opacity: 0.7;
        transition: opacity 0.2s ease;
    }
    
    .download-controls:hover {
        opacity: 1;
    }
    
    .download-controls .form-select {
        font-size: 0.75em;
        padding: 4px 24px 4px 8px;
        border-color: #dee2e6;
        color: #6c757d;
        width: auto;
        min-width: 120px;
        background-position: right 6px center;
        background-size: 12px;
    }
    
    .download-controls .btn {
        font-size: 0.75em;
        padding: 4px 8px;
        border-color: #dee2e6;
        color: #6c757d;
    }
    
    .download-controls .btn:hover {
        background-color: #f8f9fa;
        border-color: #007bff;
        color: #007bff;
    }
    
    .archived-goal-item {
        padding: 10px;
        margin: 8px 0;
        background-color: white;
        border-left: 3px solid #6c757d;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    
    .archived-goal-text {
        font-size: 0.9em;
        color: #495057;
        margin-bottom: 5px;
    }
    
    .archived-goal-meta {
        font-size: 0.7em;
        color: #6c757d;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .restore-btn {
        padding: 2px 6px;
        font-size: 0.6em;
        background-color: #28a745;
        border: 1px solid #28a745;
        color: white;
        border-radius: 3px;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .restore-btn:hover {
        background-color: #218838;
    }

    /* Progress Animation Styles */
    .operation-progress {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        border: 2px solid #007bff;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        z-index: 9999;
        min-width: 300px;
        text-align: center;
    }
    
    .operation-progress .spinner-border {
        margin-bottom: 10px;
    }
    
    .operation-progress-text {
        margin-bottom: 10px;
        font-weight: 500;
    }
    
    .operation-progress-details {
        font-size: 0.8em;
        color: #6c757d;
    }

    /* Dendrogram Styles */
    .dendrogram-controls {
        background-color: #f8f9fa !important;
    }
    
    #dendrogram-container {
        background-color: #ffffff;
        border: 1px solid #dee2e6;
    }
    
    .dendrogram-node {
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .dendrogram-node circle {
        fill: #fff;
        stroke: #007bff;
        stroke-width: 2px;
        transition: all 0.2s ease;
    }
    
    .dendrogram-node.leaf circle {
        fill: #28a745;
        stroke: #1e7e34;
    }
    
    .dendrogram-node:hover circle {
        stroke-width: 3px;
        r: 6;
    }
    
    .dendrogram-node.leaf:hover circle {
        fill: #34ce57;
    }
    
    .dendrogram-link {
        fill: none;
        stroke: #6c757d;
        stroke-width: 1.5px;
        transition: stroke-width 0.2s ease;
    }
    
    .dendrogram-link:hover {
        stroke: #007bff;
        stroke-width: 2.5px;
    }
    
    .dendrogram-text {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        font-size: 11px;
        fill: #495057;
        text-anchor: start;
        dominant-baseline: middle;
        pointer-events: none;
        transition: opacity 0.2s ease;
    }
    
    .dendrogram-text.cluster-label {
        font-weight: 600;
        fill: #007bff;
    }
    
    .dendrogram-text.representative-text {
        font-size: 10px;
        fill: #6c757d;
        font-style: italic;
    }
    
    /* Representative text color coding in dendrogram */
    .dendrogram-text.representative-text.state-default {
        fill: #495057; /* Dark grey for default/representative */
    }
    
    .dendrogram-text.representative-text.state-manual {
        fill: #228B22; /* Green for manually edited */
    }
    
    .dendrogram-text.representative-text.state-ai {
        fill: #6f42c1; /* Purple for AI generated */
    }
    
    .dendrogram-text.leaf-text {
        fill: #28a745;
        font-weight: 500;
    }
    
    /* Radial layout specific styles */
    .radial-layout .dendrogram-text {
        text-anchor: middle;
    }
    
    /* Zoom and pan styles */

    
    /* Selection styles */
    .dendrogram-node.selected circle {
        stroke: #dc3545;
        stroke-width: 3px;
        fill: #fff5f5;
    }
    
    .dendrogram-node.highlighted circle {
        stroke: #ffc107;
        stroke-width: 3px;
        fill: #fffbf0;
    }
    
    /* Focus mode styles */
    .dendrogram-node.focused circle {
        stroke: #dc3545;
        stroke-width: 4px;
        fill: #fff5f5;
        filter: drop-shadow(0 0 6px rgba(220, 53, 69, 0.5));
    }
    
    .dendrogram-node.dimmed {
        opacity: 0.3;
        transition: opacity 0.3s ease;
    }
    
    .dendrogram-node.focus-child circle {
        stroke: #28a745;
        stroke-width: 2px;
    }
    
    /* Breadcrumb styles */
    .breadcrumb-item {
        background-color: #e9ecef;
        border-radius: 12px;
        padding: 2px 8px;
        font-size: 0.75em;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .breadcrumb-item:hover {
        background-color: #007bff;
        color: white;
    }
    
    .breadcrumb-separator {
        color: #6c757d;
        font-size: 0.7em;
    }
    
    /* Collapsible node styles */
    .dendrogram-node.collapsed .dendrogram-children {
        display: none;
    }
    
    .dendrogram-node.has-hidden-children circle {
        stroke-dasharray: 3,3;
    }
    
    /* Smart label positioning */
    .dendrogram-text.smart-positioned {
        opacity: 0.9;
    }
    
    .dendrogram-text.priority-high {
        font-weight: 600;
        opacity: 1;
    }
    
    .dendrogram-text.priority-medium {
        opacity: 0.8;
    }
    
    .dendrogram-text.priority-low {
        opacity: 0.6;
    }
    
    /* Hide text for very deep nodes */
    .dendrogram-text.depth-hidden {
        display: none;
    }
    

    
    /* Progressive text sizing by depth */
    .dendrogram-text.depth-0 { font-size: 12px; }
    .dendrogram-text.depth-1 { font-size: 11px; }
    .dendrogram-text.depth-2 { font-size: 10px; }
    .dendrogram-text.depth-3 { font-size: 9px; }
    .dendrogram-text.depth-4 { font-size: 8px; }
    .dendrogram-text.depth-5 { font-size: 7px; }
    
    /* High priority nodes get slightly larger text at each depth */
    .dendrogram-text.priority-high.depth-0 { font-size: 14px; }
    .dendrogram-text.priority-high.depth-1 { font-size: 12px; }
    .dendrogram-text.priority-high.depth-2 { font-size: 11px; }
    .dendrogram-text.priority-high.depth-3 { font-size: 10px; }
    .dendrogram-text.priority-high.depth-4 { font-size: 9px; }
    .dendrogram-text.priority-high.depth-5 { font-size: 8px; }
</style>
{% endblock %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-12">
        <div class="card">
            <div class="card-header bg-purple text-white" style="background: linear-gradient(45deg, #6f42c1, #e83e8c);">
                <h2 class="card-title h4 mb-0">
                    <i class="bi bi-archive"></i> Tree Artifacts Explorer
                    <span class="artifact-badge">SAVED TREES</span>
                </h2>
                <small>View and edit saved hierarchical clustering trees from cluster analysis</small>
            </div>
            <div class="card-body">
                
                <!-- Artifact Selection -->
                <div class="artifact-selection-container">
                    <!-- Collapsed Title (visible when collapsed) -->
                    <div class="collapsed-title" id="collapsed-title">
                        <button class="btn btn-link p-0 text-decoration-none" type="button" data-bs-toggle="collapse" data-bs-target="#artifact-selection" aria-expanded="false" aria-controls="artifact-selection">
                            <small class="text-muted">
                                <i class="bi bi-chevron-right me-1"></i>
                                ðŸ“‚ Saved Artifacts
                            </small>
                        </button>
                    </div>
                    
                    <!-- Expanded Content (collapsed by default) -->
                    <div class="collapse" id="artifact-selection">
                        <div class="clustering-controls">
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <h4 class="text-purple mb-0" style="color: #6f42c1;">ðŸ“‚ Saved Artifacts</h4>
                                <button class="btn btn-link p-0 text-decoration-none" type="button" data-bs-toggle="collapse" data-bs-target="#artifact-selection" aria-expanded="true" aria-controls="artifact-selection">
                                    <i class="bi bi-chevron-up text-muted"></i>
                                </button>
                            </div>
                            <div class="row align-items-center">
                                <div class="col-md-6">
                                    <div class="mb-3">
                                        <label for="artifact-selector" class="form-label"><strong>Select Artifact:</strong></label>
                                        <select class="form-select form-select-lg" id="artifact-selector">
                                            <option value="">Loading artifacts...</option>
                                        </select>
                                        <div class="form-text">
                                            Choose a saved tree to view and edit
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="col-md-3">
                                    <div class="mb-3">
                                        <label class="form-label d-block">&nbsp;</label>
                                        <button id="load-artifact-btn" class="btn btn-purple btn-lg w-100" style="background: linear-gradient(45deg, #6f42c1, #e83e8c); border: none;" disabled>
                                            ðŸ“‚ Load Artifact
                                        </button>
                                    </div>
                                </div>
                                
                                <div class="col-md-3">
                                    <div class="mb-3">
                                        <label class="form-label d-block">&nbsp;</label>
                                        <button id="delete-artifact-btn" class="btn btn-outline-danger btn-lg w-100" disabled>
                                            <i class="bi bi-trash"></i> Delete
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Artifact Display -->
                <div id="artifact-section" style="display: none;">
                    <!-- Stats Section -->
                    <div id="artifact-stats" class="artifact-info">
                        <!-- Stats will be populated here -->
                    </div>
                    
                    <!-- Hierarchical Tree Container -->
                    <div class="tree-container">
                        <div class="d-flex justify-content-between align-items-center mb-1">
                            <h5 class="mb-0"><i class="bi bi-diagram-2"></i> Hierarchical Tree (Editable)</h5>
                            <div>
                                <button id="expand-all-btn" class="btn btn-outline-secondary btn-sm me-2">
                                    <i class="bi bi-arrows-expand"></i> Expand All
                                </button>
                                <button id="collapse-all-btn" class="btn btn-outline-secondary btn-sm me-2">
                                    <i class="bi bi-arrows-collapse"></i> Collapse All
                                </button>
                                <button id="view-dendrogram-btn" class="btn btn-outline-primary btn-sm me-2">
                                    <i class="bi bi-diagram-3"></i> View Dendrogram
                                </button>
                                <button id="view-archived-btn" class="archive-btn me-2" title="View archived learning goals">
                                    <i class="bi bi-archive"></i> Archived
                                </button>
                                <button id="save-changes-btn" class="btn btn-success btn-sm">
                                    <i class="bi bi-save"></i> Save Changes
                                </button>
                            </div>
                        </div>
                        
                        <!-- Search Container -->
                        <div class="search-container">
                            <i class="bi bi-search search-icon"></i>
                            <input type="text" class="search-input" id="tree-search" placeholder="Search clusters and learning goals..." autocomplete="off">
                            <button class="search-clear" id="search-clear" title="Clear search">
                                <i class="bi bi-x"></i>
                            </button>
                            <div class="search-results-info" id="search-results-info"></div>
                        </div>
                        
                        <!-- Level Flattening Controls -->
                        <div id="level-controls" class="mb-3">
                            <div class="d-flex align-items-center gap-2 flex-wrap">
                                <span class="fw-bold text-muted">Flatten at Level:</span>
                                <div id="level-buttons" class="btn-group" role="group">
                                    <!-- Level buttons will be populated here -->
                                </div>
                                <button id="show-tree-btn" class="btn btn-outline-primary btn-sm ms-2" style="display: none;">
                                    <i class="bi bi-diagram-2"></i> Show Tree View
                                </button>
                            </div>
                        </div>
                        
                        <div id="tree-content">
                            <!-- Tree will be populated here -->
                        </div>
                        
                        <!-- Flattened Content (shown when level is selected) -->
                        <div id="flattened-content" style="display: none;">
                            <!-- Flattened view will be populated here -->
                        </div>
                    </div>
                </div>

                <!-- Loading Spinner -->
                <div id="loading-section" class="text-center" style="display: none; padding: 50px;">
                    <div class="spinner-border text-purple" role="status" style="width: 3rem; height: 3rem;">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <h5 class="mt-3">Loading artifact...</h5>
                    <p class="text-muted">Please wait while we load your tree data.</p>
                </div>

                <!-- No Artifacts -->
                <div id="no-artifacts" class="text-center" style="display: none;">
                    <i class="bi bi-archive" style="font-size: 3rem; color: #6c757d;"></i>
                    <h3 class="mt-3">No Artifacts Found</h3>
                    <p class="text-muted">Create some tree artifacts from the <a href="{{ url_for('main.cluster_tree') }}">Cluster Tree</a> page first.</p>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- AI Generation Modal -->
<div class="modal fade" id="aiGenerationModal" tabindex="-1" aria-labelledby="aiGenerationModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="aiGenerationModalLabel">
                    <i class="fa fa-wand-magic-sparkles text-purple"></i> AI Generate Representative Text
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <!-- Model Selection -->
                <div class="mb-3">
                    <label for="ai-model-select" class="form-label"><strong>AI Model:</strong></label>
                    <select class="form-select" id="ai-model-select">
                        <option value="gpt-4o">GPT-4o (Recommended)</option>
                        <option value="gpt-4o-mini">GPT-4o Mini (Faster)</option>
                        <option value="gpt-4o-2024-11-20">GPT-4.1 (Latest)</option>
                    </select>
                </div>
                
                <!-- Prompt Input -->
                <div class="mb-3">
                    <label for="ai-prompt" class="form-label"><strong>Prompt:</strong></label>
                    <textarea class="form-control" id="ai-prompt" rows="3" placeholder="Enter your prompt..."></textarea>
                    <div class="form-text">
                        This prompt will be sent along with all learning goals from the selected region.
                    </div>
                </div>
                
                <!-- Recursive Generation Option -->
                <div class="mb-3">
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="recursive-generation" onchange="updateRecursivePreview()">
                        <label class="form-check-label" for="recursive-generation">
                            <strong>Apply to all nested groups recursively</strong>
                        </label>
                    </div>
                    <div class="form-text">
                        When checked, generates representative text for every collapsible region nested under the selected one.
                    </div>
                    <div id="recursive-warning" class="alert alert-warning mt-2" style="display: none;">
                        <i class="fa fa-exclamation-triangle"></i> 
                        <strong>Warning:</strong> This will run <span id="recursive-count">0</span> AI generation queries.
                        This may take several minutes and consume significant AI credits.
                    </div>
                </div>
                
                <!-- Learning Goals Preview -->
                <div class="mb-3">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <label class="form-label mb-0"><strong>Learning Goals Context:</strong></label>
                        <button type="button" class="btn btn-sm btn-outline-secondary" id="toggle-goals-preview">
                            <i class="bi bi-chevron-down"></i> Show Goals
                        </button>
                    </div>
                    <div id="goals-preview" class="goal-preview" style="display: none;">
                        <!-- Goals will be populated here -->
                    </div>
                    <div class="form-text">
                        <span id="goals-count">0</span> learning goals will be included as context<span id="recursive-context-info"></span>.
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-purple" id="generate-ai-text" style="background: linear-gradient(45deg, #6f42c1, #e83e8c); border: none;">
                    <i class="fa fa-wand-magic-sparkles"></i> Generate
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Move Modal -->
<div class="modal fade move-modal" id="moveModal" tabindex="-1" aria-labelledby="moveModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="moveModalLabel">
                    <i class="bi bi-arrow-left-right text-info"></i> Move Learning Goal
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <!-- Move Description -->
                <div class="mb-3" id="move-description">
                    <!-- Description will be populated here -->
                </div>
                
                <!-- Search Box -->
                <div class="mb-3" id="existing-destinations-section">
                    <div class="d-flex align-items-center mb-2">
                        <strong>Move to existing group:</strong>
                    </div>
                    <input type="text" class="move-search-input" id="move-search" placeholder="Search destination groups by name..." autocomplete="off">
                    <div class="form-text">
                        Type to search group names. Click the <i class="bi bi-info-circle" style="font-size: 0.8em;"></i> icon next to any group to see its full path.
                    </div>
                </div>
                
                <!-- Destination Tree -->
                <div class="move-destination-tree" id="move-destination-tree">
                    <!-- Tree will be populated here -->
                </div>
                
                <!-- Create New Group Option (at bottom) -->
                <div class="mt-4 pt-3 border-top">
                    <div class="d-flex align-items-center justify-content-center gap-2">
                        <button type="button" class="btn btn-link btn-sm text-muted" id="create-new-group-btn" onclick="toggleCreateNewGroup()" style="text-decoration: none; font-size: 0.85em;">
                            <i class="bi bi-plus-circle-dotted"></i> Create new group instead
                        </button>
                        <button type="button" class="btn btn-link btn-sm text-muted p-0" onclick="showCreateGroupInfo()" title="Learn more about creating new groups">
                            <i class="bi bi-info-circle" style="font-size: 0.8em;"></i>
                        </button>
                    </div>
                </div>
                
                <!-- New Group Creation Panel (hidden by default) -->
                <div id="create-new-group-panel" style="display: none;">
                    <hr class="my-3">
                    <div class="alert alert-info">
                        <strong>Creating new group:</strong> "<em id="new-group-name-preview"></em>"<br>
                        <small>Navigate to the group that contains existing groups, then select where to add the new group:</small>
                    </div>
                    
                    <!-- Hierarchical Tree Selector -->
                    <div class="new-group-tree-selector mb-3" id="new-group-tree-selector">
                        <!-- Hierarchical tree will be populated here -->
                    </div>
                    
                    <div class="text-center mb-3">
                        <button type="button" class="btn btn-success btn-sm" id="create-and-move-btn" onclick="createNewGroupAndMove()" disabled>
                            <i class="bi bi-plus-circle"></i> Create Group & Move Goal
                        </button>
                        <button type="button" class="btn btn-outline-secondary btn-sm ms-2" onclick="toggleCreateNewGroup()">
                            Cancel
                        </button>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
            </div>
        </div>
    </div>
</div>

<!-- Archive Modal -->
<div class="modal fade" id="archiveModal" tabindex="-1" aria-labelledby="archiveModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="archiveModalLabel">
                    <i class="bi bi-archive text-secondary"></i> Archived Learning Goals
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <small class="text-muted">
                        These learning goals have been deleted but are preserved for reference. You can restore them if needed.
                    </small>
                </div>
                
                <div class="archived-goals-container" id="archived-goals-container">
                    <!-- Archived goals will be populated here -->
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Dendrogram Modal -->
<div class="modal fade" id="dendrogramModal" tabindex="-1" aria-labelledby="dendrogramModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-fullscreen">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="dendrogramModalLabel">
                    <i class="bi bi-diagram-3 text-primary"></i> Interactive Dendrogram View
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body p-0">
                <!-- Dendrogram Controls -->
                <div class="dendrogram-controls bg-light border-bottom p-3">
                    <div class="row align-items-center">

                        <div class="col-md-4">
                            <label for="dendrogram-layout" class="form-label mb-1"><strong>Layout:</strong></label>
                            <select class="form-select form-select-sm" id="dendrogram-layout">
                                <option value="horizontal">Horizontal</option>
                                <option value="vertical" selected>Vertical</option>
                                <option value="radial">Radial</option>
                            </select>
                        </div>
                        <div class="col-md-4">
                            <label for="dendrogram-labels" class="form-label mb-1"><strong>Labels:</strong></label>
                            <select class="form-select form-select-sm" id="dendrogram-labels">
                                <option value="cluster">Cluster Names</option>
                                <option value="representative" selected>Representative Text</option>
                                <option value="both">Both</option>
                                <option value="smart">Smart (Adaptive)</option>
                                <option value="none">None</option>
                            </select>
                        </div>
                        <div class="col-md-4">
                            <div class="d-flex gap-2 align-items-end">
                                <button id="dendrogram-focus-home" class="btn btn-outline-info btn-sm">
                                    <i class="bi bi-house"></i> Focus Home
                                </button>
                                <button id="dendrogram-reset" class="btn btn-outline-secondary btn-sm">
                                    <i class="bi bi-arrow-clockwise"></i> Reset View
                                </button>
                                <button id="dendrogram-export" class="btn btn-outline-primary btn-sm">
                                    <i class="bi bi-download"></i> Export SVG
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Focus Breadcrumb -->
                <div id="dendrogram-breadcrumb" class="bg-white border-bottom p-2" style="display: none;">
                    <div class="d-flex align-items-center gap-2">
                        <small class="text-muted">Focus:</small>
                        <div id="breadcrumb-path" class="d-flex align-items-center gap-1">
                            <!-- Breadcrumb items will be populated here -->
                        </div>
                    </div>
                </div>
                
                <!-- Dendrogram Container -->
                <div id="dendrogram-container" class="position-relative" style="height: calc(100vh - 230px); overflow: hidden;">
                    <div id="dendrogram-svg-container" style="width: 100%; height: 100%;"></div>
                    
                    <!-- Loading Overlay -->
                    <div id="dendrogram-loading" class="position-absolute top-50 start-50 translate-middle text-center" style="display: none;">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <div class="mt-2">Building dendrogram...</div>
                    </div>
                    
                    <!-- Node Details Tooltip -->
                    <div id="dendrogram-tooltip" class="position-absolute bg-dark text-white p-2 rounded shadow" style="display: none; pointer-events: none; z-index: 1000; max-width: 300px; font-size: 0.8em;">
                        <div id="tooltip-content"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Progress Overlay -->
<div id="operation-progress" class="operation-progress" style="display: none;">
    <div class="spinner-border text-primary" role="status">
        <span class="visually-hidden">Loading...</span>
    </div>
    <div class="operation-progress-text" id="progress-text">
        Processing...
    </div>
    <div class="operation-progress-details" id="progress-details">
        Please wait while we update the tree structure.
    </div>
</div>

{% endblock %}

{% block scripts %}
<script src="{{ url_for('static', filename='lock-manager.js') }}"></script>
<script>
// Global variables
let currentArtifact = null;
let currentArtifactId = null;
let availableArtifacts = [];
let flattenedAtLevel = null;
let currentAINodeId = null;

// Performance optimization - cache flattened views
let flattenedCache = {};

// NEW: store flattened cluster data for current view
let currentFlattenedData = [];

// Move/Delete variables
let currentMoveNodeId = null;
let currentMoveType = null; // 'node' or 'goal'
let currentMoveGoalIndex = null;
let searchTimeout = null;

// New group creation variables
let selectedNewGroupLocation = null;
let currentNewGroupName = null;

// Fix for total goals display issue - detects and corrects extra trailing zeros
function fixTotalGoals(totalGoalsValue, treeStructure = null) {
    let fixed = 0;
    
    // Convert to string first to handle both string and number inputs
    let totalStr = String(totalGoalsValue || '0');
    
    // Remove any non-digit characters
    totalStr = totalStr.replace(/\D/g, '');
    
    if (totalStr === '') return 0;
    
    // Parse as integer
    let total = parseInt(totalStr);
    
    // If we have tree structure, count the actual goals to validate
    if (treeStructure && Array.isArray(treeStructure)) {
        const actualCount = countTotalGoalsInTree(treeStructure);
        
        // If the parsed total ends with 0 and removing it gives us the actual count
        if (totalStr.endsWith('0')) {
            const withoutLastZero = parseInt(totalStr.slice(0, -1));
            if (withoutLastZero === actualCount) {
                console.log(`ðŸ”§ Fixed total goals: ${total} â†’ ${withoutLastZero} (matched actual count)`);
                return withoutLastZero;
            }
        }
        
        // If the actual count matches exactly, use it
        if (total !== actualCount && actualCount > 0) {
            console.log(`ðŸ”§ Using actual goal count: ${total} â†’ ${actualCount}`);
            return actualCount;
        }
    }
    
    // Fallback pattern detection: if number ends with 0 and is suspiciously round
    if (totalStr.endsWith('0') && total > 100) {
        const withoutLastZero = parseInt(totalStr.slice(0, -1));
        // Check if removing the last zero gives a more reasonable number
        // (This is a heuristic for the specific "6485" -> "64850" issue)
        if (withoutLastZero > 0 && withoutLastZero < total * 0.5) {
            console.log(`ðŸ”§ Detected extra trailing zero: ${total} â†’ ${withoutLastZero}`);
            return withoutLastZero;
        }
    }
    
    return total;
}

// Helper function to count actual goals in tree structure
function countTotalGoalsInTree(nodes) {
    let count = 0;
    
    function countInNode(node) {
        if (node.goals && Array.isArray(node.goals)) {
            count += node.goals.length;
        }
        if (node.children && node.children.length > 0) {
            node.children.forEach(child => countInNode(child));
        }
    }
    
    if (Array.isArray(nodes)) {
        nodes.forEach(node => countInNode(node));
    }
    
    return count;
}

$(document).ready(function() {
    // Load available artifacts on page load
    loadAvailableArtifacts();
    
    // Handle collapse/expand of artifact selection
    $('#artifact-selection').on('show.bs.collapse', function() {
        $('#collapsed-title').addClass('hidden');
    });
    
    $('#artifact-selection').on('hide.bs.collapse', function() {
        $('#collapsed-title').removeClass('hidden');
    });
    
    // Artifact selector change handler
    $('#artifact-selector').change(function() {
        const selectedId = $(this).val();
        $('#load-artifact-btn').prop('disabled', !selectedId);
        $('#delete-artifact-btn').prop('disabled', !selectedId);
    });
    
    // Load artifact button handler
    $('#load-artifact-btn').click(function() {
        const selectedId = $('#artifact-selector').val();
        if (selectedId) {
            loadArtifact(selectedId);
        }
    });
    
    // Delete artifact button handler
    $('#delete-artifact-btn').click(function() {
        const selectedId = $('#artifact-selector').val();
        if (selectedId && confirm('Are you sure you want to delete this artifact? This action cannot be undone.')) {
            deleteArtifact(selectedId);
        }
    });
    
    // Tree control buttons
    $('#expand-all-btn').click(expandAll);
    $('#collapse-all-btn').click(collapseAll);
    $('#save-changes-btn').click(saveChanges);
    $('#show-tree-btn').click(showTreeView);
    
    // AI Generation Modal handlers
    $('#toggle-goals-preview').click(function() {
        const preview = $('#goals-preview');
        const btn = $(this);
        const icon = btn.find('i');
        
        if (preview.is(':visible')) {
            preview.slideUp();
            icon.removeClass('bi-chevron-up').addClass('bi-chevron-down');
            btn.html('<i class="bi bi-chevron-down"></i> Show Goals');
        } else {
            preview.slideDown();
            icon.removeClass('bi-chevron-down').addClass('bi-chevron-up');
            btn.html('<i class="bi bi-chevron-up"></i> Hide Goals');
        }
    });
    
    $('#generate-ai-text').click(function() {
        generateAIText();
    });
    
    // Move/Delete/Archive handlers
    $('#view-archived-btn').click(function() {
        loadArchivedGoals();
    });
    
    // View dendrogram handler
    $('#view-dendrogram-btn').click(function() {
        if (currentArtifact && currentArtifact.tree_structure) {
            showDendrogram();
        } else {
            alert('No tree data available for dendrogram view.');
        }
    });
    
    // Move modal search functionality with debouncing
    $('#move-search').on('input', function() {
        const searchTerm = $(this).val();
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
            filterMoveDestinations(searchTerm);
        }, 300); // 300ms debounce
    });
    
    // Tree search functionality
    let treeSearchTimeout = null;
    $('#tree-search').on('input', function() {
        const searchTerm = $(this).val();
        clearTimeout(treeSearchTimeout);
        
        // Show/hide clear button
        if (searchTerm.trim()) {
            $('#search-clear').show();
        } else {
            $('#search-clear').hide();
        }
        
        treeSearchTimeout = setTimeout(() => {
            performTreeSearch(searchTerm);
        }, 300); // 300ms debounce
    });
    
    // Clear search button
    $('#search-clear').click(function() {
        $('#tree-search').val('');
        $('#search-clear').hide();
        clearTreeSearch();
    });
    
    // Hide tooltips when clicking elsewhere
    $(document).on('click', function() {
        $('.path-tooltip').fadeOut(200, function() {
            $(this).remove();
        });
    });
});

function loadAvailableArtifacts() {
    // Show loading spinner with better messaging
    $('#loading-section').show();
    $('#artifact-section').hide();
    $('#no-artifacts').hide();
    $('#loading-section h5').text('Loading artifacts list...');
    
    $.get('/api/get-artifacts')
        .done(function(response) {
            if (response.success && response.artifacts.length > 0) {
                availableArtifacts = response.artifacts;
                
                // Populate artifact selector
                let optionsHtml = '<option value="">Select an artifact...</option>';
                response.artifacts.forEach(artifact => {
                    const date = new Date(artifact.created_at).toLocaleDateString();
                    const fixedGoals = fixTotalGoals(artifact.total_goals);
                    optionsHtml += `<option value="${artifact.id}">${artifact.name} (${fixedGoals} goals, ${date})</option>`;
                });
                
                $('#artifact-selector').html(optionsHtml);
                
                // Auto-load the first artifact
                const firstArtifactId = response.artifacts[0].id;
                $('#artifact-selector').val(firstArtifactId);
                $('#load-artifact-btn').prop('disabled', false);
                $('#delete-artifact-btn').prop('disabled', false);
                
                // Load the first artifact automatically
                loadArtifact(firstArtifactId);
                
            } else {
                $('#loading-section').hide();
                $('#artifact-selector').html('<option value="">No artifacts found</option>');
                $('#no-artifacts').show();
            }
        })
        .fail(function() {
            $('#loading-section').hide();
            $('#artifact-selector').html('<option value="">Error loading artifacts</option>');
            $('#no-artifacts').show();
        });
}

function loadArtifact(artifactId) {
    currentArtifactId = artifactId;
    
    // Clear cache when loading a new artifact
    flattenedCache = {};
    
    // Update loading message
    $('#loading-section h5').text('Loading artifact data...');
    $('#loading-section p').text('Downloading tree structure and goals...');
    
    $.get(`/api/get-artifact/${artifactId}`)
        .done(function(response) {
            if (response.success) {
                currentArtifact = response.artifact;
                
                // Update loading message for tree building
                $('#loading-section h5').text('Building tree display...');
                $('#loading-section p').text('Preparing interactive tree view...');
                
                // Use setTimeout to let the loading message update before heavy work
                setTimeout(() => {
                    try {
                        displayArtifact(currentArtifact);
                        $('#loading-section').hide();
                    } catch (error) {
                        console.error('Error displaying artifact:', error);
                        $('#loading-section').hide();
                        alert('Error loading artifact display. Please try again.');
                    }
                }, 10);
            } else {
                $('#loading-section').hide();
                alert('Failed to load artifact: ' + response.message);
            }
        })
        .fail(function() {
            $('#loading-section').hide();
            alert('Failed to load artifact: Network error');
        });
}

function displayArtifact(artifact) {
    $('#no-artifacts').hide();
    $('#artifact-section').show();
    
    // Clear any previous search state
    $('#tree-search').val('');
    $('#search-clear').hide();
    clearTreeSearch();
    
    // Display stats
    displayStats(artifact);
    
    // Display tree using the updated functions
    displayTree(artifact.tree_structure);
    
    console.log('Artifact loaded:', artifact.name);
}

function displayStats(artifact) {
    // Use the new fixTotalGoals function to handle the extra "0" issue
    const totalGoals = fixTotalGoals(artifact.total_goals, artifact.tree_structure);
    
    console.log('ðŸ” DEBUG - Original artifact.total_goals:', artifact.total_goals, typeof artifact.total_goals);
    console.log('ðŸ” DEBUG - Fixed totalGoals:', totalGoals);
    
    const statsHtml = `
        <span class="artifact-name">Artifact: ${artifact.name}</span>
        <span class="artifact-details">
            <span>Total Goals: ${totalGoals}</span>
            <span>Parameters: ${artifact.parameter_summary}</span>
            <span>Created: ${new Date(artifact.created_at).toLocaleDateString()}</span>
            <span>Modified: ${new Date(artifact.modified_at).toLocaleDateString()}</span>
        </span>
    `;
    $('#artifact-stats').html(statsHtml);
}

function displayTree(treeStructure) {
    // Clear any flattened level selection when showing tree view
    flattenedAtLevel = null;
    
    // For large trees, show progress during tree building
    const totalNodes = countTotalNodes(treeStructure);
    const isLargeTree = totalNodes > 100; // Threshold for showing progress
    
    if (isLargeTree) {
        showProgress('Building Tree...', `Processing ${totalNodes} groups and goals...`);
        
        // Use setTimeout to let progress show before heavy work
        setTimeout(() => {
            try {
                buildAndDisplayTree(treeStructure);
            } catch (error) {
                console.error('Error building tree:', error);
                alert('Error building tree display. Please try again.');
            } finally {
                hideProgress();
            }
        }, 10);
    } else {
        // Small trees can be built immediately
        buildAndDisplayTree(treeStructure);
    }
}

function buildAndDisplayTree(treeStructure) {
    // Generate level buttons
    generateLevelButtons(treeStructure);

    // Build skeleton for root nodes only
    const skeletonHtml = treeStructure.map(node => buildTreeNodeSkeleton(node, 0)).join('');
    $('#tree-content').html(skeletonHtml);

    // Show tree view
    $('#tree-content').show();
    $('#flattened-content').hide();
    $('#show-tree-btn').hide();
    
    // Reapply lock state to newly created elements
    if (window.lockManager) {
        window.lockManager.forceReapplyLockState();
    }
}



function countTotalNodes(nodes) {
    let count = 0;
    
    function countInNode(node) {
        count += 1;
        if (node.children && node.children.length > 0) {
            node.children.forEach(child => countInNode(child));
        }
    }
    
    if (Array.isArray(nodes)) {
        nodes.forEach(node => countInNode(node));
    }
    
    return count;
}

function generateLevelButtons(nodes) {
    const maxDepth = findMaxDepth(nodes);
    let buttonsHtml = '';
    
    for (let level = 0; level <= maxDepth; level++) {
        const levelLabel = String.fromCharCode(65 + level); // A, B, C, etc.
        const groupCount = countGroupsAtLevel(nodes, level);
        const totalGoals = countGoalsAtLevel(nodes, level);
        const avgGoalsPerGroup = groupCount > 0 ? Math.round(totalGoals / groupCount) : 0;
        
        buttonsHtml += `
            <button class="btn btn-outline-secondary level-button" data-level="${level}">
                <strong>${levelLabel}</strong>
                <small>${groupCount} groups</small>
                <small style="font-size: 0.65em; opacity: 0.8;">${avgGoalsPerGroup} avg goals</small>
            </button>
        `;
    }
    
    $('#level-buttons').html(buttonsHtml);
    
    // Add click handlers
    $('.level-button').click(function() {
        const level = parseInt($(this).data('level'));
        flattenAtLevel(level);
    });
}

function countGroupsAtLevel(nodes, targetLevel, currentLevel = 0) {
    let count = 0;
    nodes.forEach(node => {
        if (currentLevel === targetLevel) {
            count += 1; // Count this group
        } else if (node.children && node.children.length > 0 && currentLevel < targetLevel) {
            count += countGroupsAtLevel(node.children, targetLevel, currentLevel + 1);
        }
    });
    return count;
}

function findMaxDepth(nodes, currentDepth = 0) {
    let maxDepth = currentDepth;
    nodes.forEach(node => {
        if (node.children && node.children.length > 0) {
            maxDepth = Math.max(maxDepth, findMaxDepth(node.children, currentDepth + 1));
        }
    });
    return maxDepth;
}

function countGoalsAtLevel(nodes, targetLevel, currentLevel = 0) {
    let count = 0;
    nodes.forEach(node => {
        if (currentLevel === targetLevel) {
            count += countAllGoalsInSubtree(node);
        } else if (node.children && node.children.length > 0 && currentLevel < targetLevel) {
            count += countGoalsAtLevel(node.children, targetLevel, currentLevel + 1);
        }
    });
    return count;
}

function countAllGoalsInSubtree(node) {
    let count = (node.goals || []).length;
    if (node.children) {
        node.children.forEach(child => {
            count += countAllGoalsInSubtree(child);
        });
    }
    return count;
}

function buildTreeNode(node, level = 0) {
    const levelClass = level <= 10 ? `tree-level-${level}` : 'tree-level-deep';
    const hasChildren = node.children && node.children.length > 0;
    const hasGoals = node.goals && node.goals.length > 0;
    
    // Get representative text and determine state
    let representativeText = node.representative_goal || '';
    let textState = node.text_state || 'default';
    let aiPrompt = node.ai_prompt || '';
    
    // Get appropriate icon based on state
    let stateIcon = 'fa-quote-left'; // default
    if (textState === 'manual') {
        stateIcon = 'fa-pencil';
    } else if (textState === 'ai') {
        stateIcon = 'fa-wand-magic-sparkles';
    }
    
    // If no representative text, create one from goals
    if (!representativeText && hasGoals) {
        representativeText = node.goals.reduce((longest, current) => 
            current.length > longest.length ? current : longest
        );
    } else if (!representativeText && hasChildren) {
        representativeText = findRepresentativeGoal(node);
    }
    
    let nodeHtml = `<div class="tree-node ${levelClass}" data-level="${level}" data-node-id="${node.id}">`;
    
    // Check if this node represents no subdivision
    const isNoSubdivision = hasChildren && node.children.length === 1 && 
                           node.children[0].size === node.size;
    const subdivisionClass = isNoSubdivision ? ' no-subdivision' : '';
    
    // NEW LAYOUT: [Large Black Text][Icon][Auto-Gen Button][Small Gray Label][Size]
    nodeHtml += `
        <div class="cluster-header${subdivisionClass}" onclick="toggleCluster('${node.id}')">
            ${hasChildren ? '<i class="bi bi-chevron-right collapse-icon"></i>' : '<i class="bi bi-circle-fill collapse-icon" style="font-size: 0.5em;"></i>'}
            
            <div class="cluster-representative" 
                 contenteditable="true"
                 data-state="${textState}"
                 onclick="event.stopPropagation(); startEditing(this)"
                 onblur="saveRepresentativeText(this, '${node.id}')"
                 onkeydown="handleRepresentativeKeydown(event, this, '${node.id}')">
                <i class="fa ${stateIcon} text-state-icon"></i>
                <span class="representative-text">${representativeText}</span>
            </div>
            
            <button class="auto-generate-btn" onclick="event.stopPropagation(); openAIGenerationModal('${node.id}')" title="Generate with AI">
                <i class="fa fa-wand-magic-sparkles"></i>
            </button>
            
            <span class="cluster-label">${node.label}</span>
            <span class="cluster-size">${node.size || 0}</span>
        </div>
    `;
    
    // Cluster content (goals for leaf nodes, children for branch nodes)
    if ((hasGoals || hasChildren) && (hasGoals || node.size > 0)) {
        nodeHtml += `<div class="cluster-content" id="content-${node.id}" style="display: none;">`;
        
        if (hasGoals) {
            node.goals.forEach(function(goal, index) {
                const source = node.sources ? node.sources[index] : {};
                nodeHtml += `
                    <div class="goal-item" data-goal-index="${index}">
                        <div class="d-flex justify-content-between align-items-start">
                            <div class="flex-grow-1">
                                <div class="goal-text">"${goal}"</div>
                                                        <div class="goal-source">
                            ðŸ“„ <span class="document-link" onclick="openDocumentModal('${source.document_name || 'Unknown'}', '${source.creator || 'Unknown'}')" title="Click to view document">${truncateText(source.document_name || 'Unknown', 25)}</span> | 
                            ðŸ‘¤ ${truncateText(source.creator || 'Unknown', 15)}
                            ${source.course_name ? ` | ðŸ“š ${truncateText(source.course_name, 20)}` : ''}
                            ${source.institution ? ` | ðŸ›ï¸ ${truncateText(source.institution, 20)}` : ''}
                        </div>
                            </div>
                            <div class="goal-actions">
                                <button class="goal-move-btn" onclick="openMoveModal('${node.id}', 'goal', ${index})" title="Move this learning goal">
                                    â†”
                                </button>
                                <button class="goal-delete-btn" onclick="deleteGoal('${node.id}', ${index})" title="Delete this learning goal">
                                    ðŸ—‘
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            });
        }
        
        if (hasChildren) {
            node.children.forEach(child => {
                nodeHtml += buildTreeNode(child, level + 1);
            });
        }
        
        nodeHtml += `</div>`;
    }
    
    nodeHtml += `</div>`;
    return nodeHtml;
}

function findRepresentativeGoal(node) {
    // Recursively find a representative goal from children
    if (node.goals && node.goals.length > 0) {
        return node.goals.reduce((longest, current) => 
            current.length > longest.length ? current : longest
        );
    }
    
    if (node.children) {
        for (let child of node.children) {
            const childRep = findRepresentativeGoal(child);
            if (childRep) return childRep;
        }
    }
    
    return '';
}

function truncateText(text, maxLength) {
    if (!text) return '';
    return text.length <= maxLength ? text : text.substring(0, maxLength - 3) + '...';
}

function startEditing(element) {
    $(element).addClass('editing');
    // Don't interfere with the browser's natural cursor placement
    // The contenteditable element will handle cursor positioning automatically
}

function editRepresentativeText(element) {
    $(element).addClass('editing');
    
    // Don't auto-select all text - let the user click where they want to edit
    // Just ensure the element is focused
    element.focus();
    
    // If the user wants to select all, they can use Ctrl+A
    // For now, just place the cursor at the end if no selection is made
    setTimeout(() => {
        if (window.getSelection().toString() === '') {
            // No text is selected, place cursor at click position
            // The browser will naturally handle this when we don't interfere
        }
    }, 10);
}

function saveRepresentativeText(element, nodeId) {
    $(element).removeClass('editing');
    const textSpan = $(element).find('.representative-text');
    const newText = textSpan.text().trim();
    
    if (!newText) {
        alert('Representative text cannot be empty');
        return;
    }
    
    // Update the state to manual and change icon
    const icon = $(element).find('.text-state-icon');
    icon.removeClass('fa-quote-left fa-wand-magic-sparkles').addClass('fa-pencil');
    
    // Set data-state attribute to manual
    $(element).attr('data-state', 'manual');
    
    // Mark as changed for saving later
    element.setAttribute('data-changed', 'true');
    element.style.backgroundColor = '#fff3cd'; // Light yellow to indicate unsaved changes
}

function handleRepresentativeKeydown(event, element, nodeId) {
    if (event.key === 'Enter') {
        event.preventDefault();
        element.blur();
    } else if (event.key === 'Escape') {
        // Restore original text (would need to be stored)
        element.blur();
    }
}

function openAIGenerationModal(nodeId) {
    currentAINodeId = nodeId;
    
    // Find the node in the current artifact
    const node = findNodeById(currentArtifact.tree_structure, nodeId);
    if (!node) {
        alert('Node not found');
        return;
    }
    
    // Set default prompt or use saved prompt
    const defaultPrompt = "Please provide a brief overarching learning goal (or skill) that encapsulates, specifically all of the learning goals or skills in the list below.";
    const savedPrompt = node.ai_prompt || defaultPrompt;
    $('#ai-prompt').val(savedPrompt);
    
    // Reset recursive checkbox
    $('#recursive-generation').prop('checked', false);
    
    // Collect all goals from this region
    const allGoals = collectAllGoalsFromNode(node);
    
    // Populate goals preview
    let goalsHtml = '';
    allGoals.forEach((goalData, index) => {
        goalsHtml += `
            <div class="goal-preview-item">
                <div class="goal-preview-text">"${goalData.goal}"</div>
                <div class="goal-preview-source">
                    ðŸ“„ ${goalData.source.document_name || 'Unknown'} | 
                    ðŸ‘¤ ${goalData.source.creator || 'Unknown'}
                    ${goalData.source.course_name ? ` | ðŸ“š ${goalData.source.course_name}` : ''}
                </div>
            </div>
        `;
    });
    
    $('#goals-preview').html(goalsHtml);
    $('#goals-count').text(allGoals.length);
    
    // Update recursive preview
    updateRecursivePreview();
    
    // Show the modal
    $('#aiGenerationModal').modal('show');
}

function findNodeById(nodes, targetId) {
    for (let node of nodes) {
        if (node.id === targetId) {
            return node;
        }
        if (node.children) {
            const found = findNodeById(node.children, targetId);
            if (found) return found;
        }
    }
    return null;
}

function collectAllGoalsFromNode(node) {
    let allGoals = [];
    
    // Add goals from this node
    if (node.goals) {
        node.goals.forEach((goal, index) => {
            const source = node.sources ? node.sources[index] : {};
            allGoals.push({
                goal: goal,
                source: source
            });
        });
    }
    
    // Add goals from children recursively
    if (node.children) {
        node.children.forEach(child => {
            allGoals = allGoals.concat(collectAllGoalsFromNode(child));
        });
    }
    
    return allGoals;
}

function generateAIText() {
    const model = $('#ai-model-select').val();
    const prompt = $('#ai-prompt').val().trim();
    const isRecursive = $('#recursive-generation').is(':checked');
    
    if (!prompt) {
        alert('Please enter a prompt');
        return;
    }
    
    if (!currentAINodeId) {
        alert('No node selected');
        return;
    }
    
    // Find the node
    const node = findNodeById(currentArtifact.tree_structure, currentAINodeId);
    if (!node) {
        alert('Node not found');
        return;
    }
    
    if (isRecursive) {
        // Get user confirmation for recursive generation
        const recursiveNodes = collectRecursiveNodes(node);
        const confirmMessage = `This will generate AI text for ${recursiveNodes.length} groups. This may take several minutes and consume significant AI credits. Continue?`;
        
        if (!confirm(confirmMessage)) {
            return;
        }
        
        generateRecursiveAIText(recursiveNodes, model, prompt);
    } else {
        generateSingleAIText(node, model, prompt);
    }
}

function generateSingleAIText(node, model, prompt) {
    const generateBtn = $('#generate-ai-text');
    generateBtn.prop('disabled', true).html('<i class="fa fa-spinner fa-spin"></i> Generating...');
    
    // Collect goals for this node only
    const allGoals = collectAllGoalsFromNode(node);
    const goalsList = allGoals.map(g => `"${g.goal}"`).join('\n');
    const fullPrompt = `${prompt}\n\nLearning goals:\n${goalsList}`;
    
    // Send to API
    $.ajax({
        url: '/api/generate-representative-text',
        method: 'POST',
        contentType: 'application/json',
        data: JSON.stringify({
            artifact_id: currentArtifactId,
            node_id: currentAINodeId,
            prompt: prompt,
            full_prompt: fullPrompt,
            model: model
        })
    })
    .done(function(response) {
        if (response.success) {
            // Update the in-memory artifact data with the saved prompt and generated text
            const node = findNodeById(currentArtifact.tree_structure, currentAINodeId);
            if (node) {
                node.ai_prompt = prompt;
                node.representative_goal = response.generated_text;
                node.text_state = 'ai';
            }
            
            updateNodeUI(currentAINodeId, response.generated_text, 'ai');
            $('#aiGenerationModal').modal('hide');
        } else {
            alert('Failed to generate text: ' + response.message);
        }
    })
    .fail(function() {
        alert('Failed to generate text: Network error');
    })
    .always(function() {
        generateBtn.prop('disabled', false).html('<i class="fa fa-wand-magic-sparkles"></i> Generate');
    });
}

function generateRecursiveAIText(recursiveNodes, model, prompt) {
    const generateBtn = $('#generate-ai-text');
    generateBtn.prop('disabled', true);
    
    let completed = 0;
    let successful = 0;
    let errors = 0;
    const total = recursiveNodes.length;
    
    // Collect all results in memory - NO database saves during generation
    const generatedResults = [];
    const failedNodes = [];
    
    // Add progress indicator to the modal title
    const modalTitle = $('#aiGenerationModalLabel');
    const originalTitle = modalTitle.html();
    
    // Process each node
    recursiveNodes.forEach((nodeData, index) => {
        const goalsList = nodeData.goals.map(g => `"${g.goal}"`).join('\n');
        const fullPrompt = `${prompt}\n\nLearning goals:\n${goalsList}`;
        
        // Update progress in button and modal title
        const progressText = `Generating ${index + 1}/${total}`;
        generateBtn.html(`<i class="fa fa-spinner fa-spin"></i> ${progressText}...`);
        modalTitle.html(`<i class="fa fa-wand-magic-sparkles text-purple"></i> AI Generate - ${progressText}`);
        
        // Small delay between requests to avoid overwhelming the API
        setTimeout(() => {
            $.ajax({
                url: '/api/generate-representative-text',
                method: 'POST',
                contentType: 'application/json',
                data: JSON.stringify({
                    artifact_id: currentArtifactId,
                    node_id: nodeData.id,
                    prompt: prompt,
                    full_prompt: fullPrompt,
                    model: model,
                    skip_save: true  // NEW: Skip individual saves during batch operations
                })
            })
            .done(function(response) {
                if (response.success) {
                    // Store result in memory and update UI immediately
                    generatedResults.push({
                        node_id: nodeData.id,
                        representative_text: response.generated_text,
                        text_state: 'ai',
                        ai_prompt: prompt  // Store the prompt for batch saving
                    });
                    
                    // Update UI immediately for visual feedback
                    updateNodeUI(nodeData.id, response.generated_text, 'ai');
                    successful++;
                } else {
                    failedNodes.push({
                        node_id: nodeData.id,
                        error: response.message
                    });
                    errors++;
                    console.error(`Failed to generate for node ${nodeData.id}:`, response.message);
                }
            })
            .fail(function() {
                failedNodes.push({
                    node_id: nodeData.id,
                    error: 'Network error'
                });
                errors++;
                console.error(`Network error for node ${nodeData.id}`);
            })
            .always(function() {
                completed++;
                
                // Update progress with completion status
                const completedText = `Completed ${completed}/${total} (${successful} successful, ${errors} failed)`;
                generateBtn.html(`<i class="fa fa-spinner fa-spin"></i> ${completedText}`);
                modalTitle.html(`<i class="fa fa-wand-magic-sparkles text-purple"></i> AI Generate - ${completedText}`);
                
                if (completed === total) {
                    // All generations complete - now save everything in one batch
                    if (generatedResults.length > 0) {
                        batchSaveAIResults(generatedResults, originalTitle, modalTitle, generateBtn, successful, errors, total);
                    } else {
                        // No successful results to save
                        setTimeout(() => {
                            modalTitle.html(originalTitle);
                            generateBtn.prop('disabled', false).html('<i class="fa fa-wand-magic-sparkles"></i> Generate');
                            alert(`âŒ All generations failed. No changes to save.`);
                        }, 1000);
                    }
                }
            });
        }, index * 500); // 500ms delay between requests
    });
}

function batchSaveAIResults(generatedResults, originalTitle, modalTitle, generateBtn, successful, errors, total) {
    // For recursive generation, individual saves were skipped, so we need to save everything now
    // including the prompts that were used for generation
    
    // Show finalizing progress
    const finalizingText = `Saving ${generatedResults.length} changes...`;
    generateBtn.html(`<i class="fa fa-spinner fa-spin"></i> ${finalizingText}`);
    modalTitle.html(`<i class="fa fa-check-circle text-purple"></i> AI Generate - ${finalizingText}`);
    
    // Prepare updates for batch save (including prompts)
    const updates = generatedResults.map(result => ({
        node_id: result.node_id,
        representative_text: result.representative_text,
        text_state: result.text_state,
        ai_prompt: result.ai_prompt  // Include the prompt that was used
    }));
    
    // Send batch update to save everything including prompts
    $.ajax({
        url: '/api/batch-update-artifact-representative-texts',
        method: 'POST',
        contentType: 'application/json',
        data: JSON.stringify({
            artifact_id: currentArtifactId,
            updates: updates
        })
    })
    .done(function(response) {
        if (response.success) {
            // Update the in-memory artifact data with the saved prompts
            generatedResults.forEach(result => {
                const node = findNodeById(currentArtifact.tree_structure, result.node_id);
                if (node) {
                    node.ai_prompt = result.ai_prompt;
                    node.representative_goal = result.representative_text;
                    node.text_state = result.text_state;
                }
            });
            
            // Clear all change indicators after successful save
            generatedResults.forEach(result => {
                const nodeElements = $(`[data-changed="true"]`).filter(function() {
                    // Check if this element itself has data-node-id (flattened view)
                    // or find it in the closest parent (tree view)
                    let nodeId = $(this).data('node-id');
                    if (!nodeId) {
                        nodeId = $(this).closest('[data-node-id]').data('node-id');
                    }
                    return nodeId === result.node_id;
                });
                nodeElements.each(function() {
                    $(this).removeAttr('data-changed');
                    $(this).css('backgroundColor', '');
                });
            });
            
            // Show final success
            generateBtn.html(`<i class="fa fa-check text-success"></i> All saved successfully!`);
            modalTitle.html(`<i class="fa fa-check text-success"></i> Generation Complete!`);
            
            setTimeout(() => {
                modalTitle.html(originalTitle);
                generateBtn.prop('disabled', false).html('<i class="fa fa-wand-magic-sparkles"></i> Generate');
                $('#aiGenerationModal').modal('hide');
                
                if (errors === 0) {
                    alert(`ðŸŽ‰ Successfully generated and saved text for all ${total} groups!\n\nðŸ’¾ All results including prompts were saved.`);
                } else {
                    alert(`ðŸ“Š Generation completed!\nâœ… Generated & Saved: ${successful}\nâŒ Failed: ${errors}\nðŸ“ Total: ${total}\n\nðŸ’¾ All successful results including prompts were saved.`);
                }
            }, 1500);
        } else {
            // Save failed
            generateBtn.html(`<i class="fa fa-exclamation-triangle text-warning"></i> Save Failed`);
            modalTitle.html(`<i class="fa fa-exclamation-triangle text-warning"></i> Save Failed`);
            alert('Generated text successfully but failed to save to database: ' + response.message);
            
            setTimeout(() => {
                modalTitle.html(originalTitle);
                generateBtn.prop('disabled', false).html('<i class="fa fa-wand-magic-sparkles"></i> Generate');
            }, 3000);
        }
    })
    .fail(function() {
        // Network error
        generateBtn.html(`<i class="fa fa-times text-danger"></i> Network Error`);
        modalTitle.html(`<i class="fa fa-times text-danger"></i> Network Error`);
        alert('Generated text successfully but failed to save: Network error');
        
        setTimeout(() => {
            modalTitle.html(originalTitle);
            generateBtn.prop('disabled', false).html('<i class="fa fa-wand-magic-sparkles"></i> Generate');
        }, 3000);
    });
}

function updateNodeUI(nodeId, generatedText, state) {
    let nodeElement, textSpan, icon;
    
    if ($('#flattened-content').is(':visible')) {
        // Flattened view is active - find the representative element by node ID
        // We need to find which flattened cluster contains this node ID
        nodeElement = $(`#flattened-content .cluster-representative`).filter(function() {
            // Check if the onblur attribute contains this nodeId
            const onblurAttr = $(this).attr('onblur');
            return onblurAttr && onblurAttr.includes(`'${nodeId}'`);
        });
    } else {
        // Tree view is active - use the existing selector
        nodeElement = $(`.tree-node[data-node-id="${nodeId}"] > .cluster-header > .cluster-representative`);
    }
    
    if (nodeElement.length === 0) {
        console.error(`Could not find node element for ID: ${nodeId}`);
        return;
    }
    
    textSpan = nodeElement.find('.representative-text');
    icon = nodeElement.find('.text-state-icon');
    
    textSpan.text(generatedText);
    icon.removeClass('fa-quote-left fa-pencil').addClass('fa-wand-magic-sparkles');
    
    // Set data-state attribute
    nodeElement.attr('data-state', state);
    
    // Mark as changed for saving
    nodeElement[0].setAttribute('data-changed', 'true');
    nodeElement[0].style.backgroundColor = '#e1f5fe'; // Light blue for AI
}

function collectRecursiveNodes(rootNode) {
    const nodes = [];
    
    function collectNode(node) {
        // Add this node if it has goals or children (any collapsible region)
        const hasChildren = node.children && node.children.length > 0;
        const hasGoals = node.goals && node.goals.length > 0;
        
        if (hasChildren || hasGoals) {
            const allGoals = collectAllGoalsFromNode(node);
            // Only include groups with more than 1 goal (no point generating for single goals)
            if (allGoals.length > 1) {
                nodes.push({
                    id: node.id,
                    label: node.label,
                    goals: allGoals
                });
            }
        }
        
        // Recursively collect from children
        if (hasChildren) {
            node.children.forEach(child => {
                collectNode(child);
            });
        }
    }
    
    collectNode(rootNode);
    return nodes;
}

function updateRecursivePreview() {
    const isRecursive = $('#recursive-generation').is(':checked');
    const warning = $('#recursive-warning');
    const recursiveInfo = $('#recursive-context-info');
    
    if (isRecursive && currentAINodeId) {
        const node = findNodeById(currentArtifact.tree_structure, currentAINodeId);
        if (node) {
            const recursiveNodes = collectRecursiveNodes(node);
            $('#recursive-count').text(recursiveNodes.length);
            warning.show();
            
            // Update context info
            if (recursiveNodes.length > 1) {
                recursiveInfo.text(` (${recursiveNodes.length} total queries)`);
            } else {
                recursiveInfo.text('');
            }
        }
    } else {
        warning.hide();
        recursiveInfo.text('');
    }
}

function flattenAtLevel(level) {
    // Show progress immediately for user feedback
    showProgress('Processing...', `Flattening tree at level ${String.fromCharCode(65 + level)}...`);
    
    // Update button states immediately
    $('.level-button').removeClass('active');
    $(`.level-button[data-level="${level}"]`).addClass('active');
    
    // Use setTimeout to let progress overlay render first
    setTimeout(() => {
        try {
            flattenedAtLevel = level;
            
            // Check cache first
            const cacheKey = `${currentArtifactId}_${level}`;
            if (flattenedCache[cacheKey]) {
                // Use cached version
                $('#flattened-content').html(flattenedCache[cacheKey].html);
                updateDownloadOptions(flattenedCache[cacheKey].flattened);
            } else {
                // Generate flattened view and cache it
                const flattened = flattenTreeAtLevel(currentArtifact.tree_structure, level);
                const html = generateFlattenedHTML(flattened, level);
                
                // Cache the results
                flattenedCache[cacheKey] = { html: html, flattened: flattened };
                
                $('#flattened-content').html(html);
                updateDownloadOptions(flattened);
            }
            
            // Show flattened content, hide tree
            $('#tree-content').hide();
            $('#flattened-content').show();
            $('#show-tree-btn').show();
            
            // Preserve search if active
            const searchTerm = $('#tree-search').val();
            if (searchTerm.trim()) {
                setTimeout(() => {
                    performTreeSearch(searchTerm);
                }, 100); // Small delay to let flattened view render
            }
            
        } catch (error) {
            console.error('Error flattening tree:', error);
            alert('Error processing tree data. Please try again.');
        } finally {
            hideProgress();
        }
    }, 10); // Small delay to let UI update
}

function flattenTreeAtLevel(nodes, targetLevel, currentLevel = 0) {
    let flattened = [];
    
    nodes.forEach(node => {
        if (currentLevel === targetLevel) {
            // Collect all goals from this node and its children, preserving source node info
            const allGoalsWithSource = collectAllGoalsWithSourceFromNode(node);
            if (allGoalsWithSource.length > 0) {
                flattened.push({
                    label: node.label,
                    representative: node.representative_goal || '',
                    goalsWithSource: allGoalsWithSource,
                    size: allGoalsWithSource.length,
                    originalNode: node
                });
            }
        } else if (node.children && node.children.length > 0 && currentLevel < targetLevel) {
            flattened = flattened.concat(flattenTreeAtLevel(node.children, targetLevel, currentLevel + 1));
        }
    });
    
    return flattened;
}

function collectAllGoalsWithSourceFromNode(node) {
    // Collect all goals from this node and its children, preserving which node each goal came from
    let allGoals = [];
    
    // Add goals from this node
    if (node.goals) {
        node.goals.forEach((goal, index) => {
            const source = node.sources ? node.sources[index] : {};
            allGoals.push({
                goal: goal,
                source: source,
                sourceNodeId: node.id,
                originalIndex: index
            });
        });
    }
    
    // Add goals from children recursively
    if (node.children) {
        node.children.forEach(child => {
            allGoals = allGoals.concat(collectAllGoalsWithSourceFromNode(child));
        });
    }
    
    return allGoals;
}

function generateFlattenedHTML(flattened, level) {
    // store globally for lazy loading
    currentFlattenedData = flattened;
    const levelLabel = String.fromCharCode(65 + level);
    const totalGoals = flattened.reduce((sum, cluster) => sum + cluster.size, 0);
    
    let flattenedHtml = `
        <div class="mb-3 d-flex justify-content-between align-items-center">
            <div>
                <h5><i class="bi bi-list-ul"></i> Flattened View - Level ${levelLabel}</h5>
                <small class="text-muted">${flattened.length} clusters, ${totalGoals} total goals</small>
            </div>
            <div class="download-controls">
                <button id="download-csv-btn" class="btn btn-outline-secondary" onclick="downloadFlattenedCSV('${levelLabel}')">
                    <i class="bi bi-download"></i> CSV
                </button>
                <select id="download-column-type" class="form-select">
                    <option value="institution">by Institution</option>
                    <option value="creator">by Creator</option>
                    <option value="course_name">by Course</option>
                </select>
            </div>
        </div>
    `;
    
    flattened.forEach((cluster, index) => {
        const originalNode = cluster.originalNode;
        const representativeText = originalNode.representative_goal || '';
        const textState = originalNode.text_state || 'default';
        let stateIcon = 'fa-quote-left';
        if (textState === 'manual') stateIcon = 'fa-pencil';
        else if (textState === 'ai') stateIcon = 'fa-wand-magic-sparkles';

        flattenedHtml += `
            <div class="flattened-cluster">
                <div class="cluster-header" onclick="toggleFlattenedCluster('flattened-${index}')">
                    <i class="bi bi-chevron-right collapse-icon"></i>
                    <div class="cluster-representative" contenteditable="true" data-state="${textState}" data-node-id="${originalNode.id}" onclick="event.stopPropagation(); startEditing(this)" onblur="saveRepresentativeText(this, '${originalNode.id}')" onkeydown="handleRepresentativeKeydown(event, this, '${originalNode.id}')">
                        <i class="fa ${stateIcon} text-state-icon"></i>
                        <span class="representative-text">${representativeText}</span>
                    </div>
                    <button class="auto-generate-btn" onclick="event.stopPropagation(); openAIGenerationModal('${originalNode.id}')" title="Generate with AI"><i class="fa fa-wand-magic-sparkles"></i></button>
                    <span class="cluster-label">${cluster.label}</span>
                    <span class="cluster-size">${cluster.size}</span>
                </div>
                <!-- Empty content for lazy load -->
                <div class="cluster-content" id="flattened-content-${index}" data-loaded="false" style="display:none;"></div>
            </div>`;
    });

    return flattenedHtml;
}

// Keep the original function as a simple wrapper for backward compatibility
function displayFlattenedView(flattened, level) {
    const html = generateFlattenedHTML(flattened, level);
    $('#flattened-content').html(html);
    updateDownloadOptions(flattened);
    
    // Immediately apply lock state to newly created elements
    if (window.lockManager) {
        window.lockManager.applyLockToNewContent();
        
        // Also apply with multiple quick intervals for large content
        setTimeout(() => {
            window.lockManager.applyLockToNewContent();
        }, 1);
        
        setTimeout(() => {
            window.lockManager.applyLockToNewContent();
        }, 10);
    }
}

function showTreeView() {
    if (currentArtifact && currentArtifact.tree_structure) {
        displayTree(currentArtifact.tree_structure);
        
        // Preserve search if active
        const searchTerm = $('#tree-search').val();
        if (searchTerm.trim()) {
            setTimeout(() => {
                performTreeSearch(searchTerm);
            }, 100); // Small delay to let tree render
        }
    } else {
        // Fallback to simple view switching if no tree data
        flattenedAtLevel = null;
        $('.level-button').removeClass('active');
        $('#tree-content').show();
        $('#flattened-content').hide();
        $('#show-tree-btn').hide();
    }
}

function toggleCluster(nodeId) {
    const content = $(`#content-${nodeId}`);
    const icon = $(`.tree-node[data-node-id="${nodeId}"] > .cluster-header > .collapse-icon`);
    const header = $(`.tree-node[data-node-id="${nodeId}"] > .cluster-header`);

    if (content.is(':visible')) {
        content.slideUp(200);
        icon.removeClass('expanded');
        header.removeClass('expanded');
    } else {
        // Lazy-load content if empty
        if (content.is(':empty')) {
            const node = findNodeById(currentArtifact.tree_structure, nodeId);
            if (node) {
                const parentLevel = parseInt($(header).closest('.tree-node').attr('data-level')) || 0;
                const innerHtml = buildClusterContent(node, parentLevel + 1);
                content.html(innerHtml);
            }
        }
        content.slideDown(200);
        icon.addClass('expanded');
        header.addClass('expanded');
    }
}

function toggleFlattenedCluster(clusterId) {
    const index = parseInt(clusterId.replace('flattened-', ''));
    const content = $(`#flattened-content-${index}`);
    const clusterElement = content.closest('.flattened-cluster');
    const icon = clusterElement.find('.cluster-header .collapse-icon');
    const header = clusterElement.find('.cluster-header');

    if (content.is(':visible')) {
        content.slideUp(200);
        icon.removeClass('expanded');
        header.removeClass('expanded');
    } else {
        // First time expansion â€“ build content lazily
        if (content.attr('data-loaded') === 'false') {
            // Show spinner
            const spinnerHtml = '<div class="text-center p-3"><div class="spinner-border spinner-border-sm"></div> Loading goals...</div>';
            content.html(spinnerHtml);
            content.attr('data-loaded', 'loading');

            // Build goals in chunks to avoid blocking
            const clusterData = currentFlattenedData[index];
            if (!clusterData) {
                content.html('<div class="text-muted p-2">No data available</div>');
                content.attr('data-loaded', 'true');
            } else {
                buildFlattenedGoalsAsync(clusterData, content, () => {
                    content.attr('data-loaded', 'true');
                });
            }
        }
        content.slideDown(200);
        icon.addClass('expanded');
        header.addClass('expanded');
    }
}

// Build goals HTML for a flattened cluster asynchronously
function buildFlattenedGoalsAsync(clusterData, contentElem, doneCallback) {
    const goals = clusterData.goalsWithSource;
    let html = '';
    let i = 0;
    const chunkSize = 100;

    function processChunk() {
        const end = Math.min(i + chunkSize, goals.length);
        for (; i < end; i++) {
            const goalData = goals[i];
            const { goal, source, sourceNodeId, originalIndex } = goalData;
            html += `<div class=\"goal-item\" data-goal-index=\"${i}\"><div class=\"d-flex justify-content-between align-items-start\"><div class=\"flex-grow-1\"><div class=\"goal-text\">\"${goal}\"</div><div class=\"goal-source\">ðŸ“„ <span class=\"document-link\" onclick=\"openDocumentModal('${source.document_name || 'Unknown'}', '${source.creator || 'Unknown'}')\" title=\"Click to view document\">${truncateText(source.document_name || 'Unknown',25)}</span> | ðŸ‘¤ ${truncateText(source.creator || 'Unknown',15)}${source.course_name?` | ðŸ“š ${truncateText(source.course_name,20)}`:''}${source.institution?` | ðŸ›ï¸ ${truncateText(source.institution,20)}`:''}</div></div><div class=\"goal-actions\"><button class=\"goal-move-btn\" onclick=\"openMoveModal('${sourceNodeId}','goal',${originalIndex})\" title=\"Move this learning goal\">â†”</button><button class=\"goal-delete-btn\" onclick=\"deleteGoal('${sourceNodeId}',${originalIndex})\" title=\"Delete this learning goal\">ðŸ—‘</button></div></div></div>`;
        }
        if (i < goals.length) {
            requestAnimationFrame(processChunk);
        } else {
            // Replace spinner with built html
            contentElem.html(html);
            
            // Immediately apply lock state to newly created elements
            if (window.lockManager) {
                window.lockManager.applyLockToNewContent();
                
                // Also apply with a tiny delay for any remaining async content
                setTimeout(() => {
                    window.lockManager.applyLockToNewContent();
                }, 1);
            }
            
            if (doneCallback) doneCallback();
        }
    }

    // Start processing
    requestAnimationFrame(processChunk);
}

function expandAll() {
    if ($('#flattened-content').is(':visible')) {
        // Flattened view is active - use fast show() instead of slideDown for performance
        $('#flattened-content .cluster-content').show();
        $('#flattened-content .collapse-icon').addClass('expanded');
        $('#flattened-content .cluster-header').addClass('expanded');
    } else {
        // Tree view is active - use fast show() instead of slideDown for performance
        $('.cluster-content').show();
        $('.collapse-icon').addClass('expanded');
        $('.cluster-header').addClass('expanded');
    }
}

function collapseAll() {
    if ($('#flattened-content').is(':visible')) {
        // Flattened view is active - use fast hide() instead of slideUp for performance
        $('#flattened-content .cluster-content').hide();
        $('#flattened-content .collapse-icon').removeClass('expanded');
        $('#flattened-content .cluster-header').removeClass('expanded');
    } else {
        // Tree view is active - use fast hide() instead of slideUp for performance
        $('.cluster-content').hide();
        $('.collapse-icon').removeClass('expanded');
        $('.cluster-header').removeClass('expanded');
    }
}

function saveChanges() {
    if (!currentArtifactId) {
        alert('No artifact loaded');
        return;
    }
    
    const saveBtn = $('#save-changes-btn');
    
    // Find all changed representative texts
    const changedTexts = [];
    $('[data-changed="true"]').each(function() {
        // Check if this element itself has data-node-id (flattened view)
        // or find it in the closest parent (tree view)
        let nodeId = $(this).data('node-id');
        if (!nodeId) {
            nodeId = $(this).closest('[data-node-id]').data('node-id');
        }
        
        const newText = $(this).find('.representative-text').text().trim();
        const state = $(this).attr('data-state') || 'manual';
        
        // Only add if we have all required fields
        if (nodeId && newText && state) {
            changedTexts.push({
                node_id: nodeId,
                representative_text: newText,
                text_state: state
            });
        } else {
            console.warn('Skipping element with missing data:', {
                nodeId: nodeId,
                newText: newText,
                state: state,
                element: this
            });
        }
    });
    
    if (changedTexts.length === 0) {
        alert('No changes to save');
        return;
    }
    
    // Show progress overlay for large saves (more than 10 changes)
    if (changedTexts.length > 10) {
        showProgress('Saving Changes...', `Updating ${changedTexts.length} representative texts...`);
    }
    
    // Show progress - start with spinner and count
    saveBtn.prop('disabled', true).html(`<i class="fa fa-spinner fa-spin"></i> Saving ${changedTexts.length} changes...`);
    
    // Use batch update API for much better performance
    $.ajax({
        url: '/api/batch-update-artifact-representative-texts',
        method: 'POST',
        contentType: 'application/json',
        data: JSON.stringify({
            artifact_id: currentArtifactId,
            updates: changedTexts
        })
    })
    .done(function(response) {
        if (response.success) {
            // Show success animation
            saveBtn.html('<i class="fa fa-check text-success"></i> Saved Successfully!');
            
            // All successful - clear change indicators
            $('[data-changed="true"]').each(function() {
                $(this).removeAttr('data-changed');
                $(this).css('backgroundColor', '');
            });
            
            // Clear cache since data changed
            flattenedCache = {};
            
            // Brief success message then return to normal
            setTimeout(() => {
                saveBtn.html('<i class="bi bi-save"></i> Save Changes');
            }, 2500);
        } else {
            saveBtn.html('<i class="fa fa-exclamation-triangle text-warning"></i> Save Failed');
            alert('Failed to save changes: ' + response.message);
            
            setTimeout(() => {
                saveBtn.html('<i class="bi bi-save"></i> Save Changes');
            }, 3000);
        }
    })
    .fail(function() {
        saveBtn.html('<i class="fa fa-times text-danger"></i> Network Error');
        alert('Failed to save changes: Network error');
        
        setTimeout(() => {
            saveBtn.html('<i class="bi bi-save"></i> Save Changes');
        }, 3000);
    })
    .always(function() {
        // Hide progress overlay if it was shown
        if (changedTexts.length > 10) {
            hideProgress();
        }
        
        // Always re-enable the button after the operation completes
        setTimeout(() => {
            saveBtn.prop('disabled', false);
        }, 2500);
    });
}

function deleteArtifact(artifactId) {
    $.post(`/api/delete-artifact/${artifactId}`)
        .done(function(response) {
            if (response.success) {
                // Reset everything
                currentArtifact = null;
                currentArtifactId = null;
                $('#artifact-section').hide();
                
                // Reload artifacts list
                loadAvailableArtifacts();
                
                alert('Artifact deleted successfully');
            } else {
                alert('Failed to delete artifact: ' + response.message);
            }
        })
        .fail(function() {
            alert('Failed to delete artifact: Network error');
        });
}

// =====================================
// MOVE AND DELETE FUNCTIONALITY
// =====================================

function openMoveModal(nodeId, moveType, goalIndex = null) {
    // Validate inputs first
    if (!currentArtifact || !currentArtifact.tree_structure) {
        alert('Error: No artifact loaded. Please load an artifact first.');
        return;
    }
    
    currentMoveNodeId = nodeId;
    currentMoveType = moveType;
    currentMoveGoalIndex = goalIndex;
    
    // Find the source node
    const sourceNode = findNodeById(currentArtifact.tree_structure, nodeId);
    
    if (!sourceNode) {
        console.error('Source node not found:', { nodeId, moveType, goalIndex });
        alert(`Error: Source node not found (ID: ${nodeId}). The tree structure may have changed.`);
        return;
    }
    
    // Update modal title and description (only for goal moves now)
    let description = '';
    if (moveType === 'goal' && goalIndex !== null) {
        if (!sourceNode.goals || goalIndex >= sourceNode.goals.length) {
            console.error('Goal not found:', { nodeId, goalIndex, availableGoals: sourceNode.goals ? sourceNode.goals.length : 0 });
            alert(`Error: Learning goal not found (index: ${goalIndex}). The goal may have been moved or deleted.`);
            return;
        }
        
        const goalText = sourceNode.goals[goalIndex];
        description = `<strong>Moving Learning Goal:</strong><br/><em>"${truncateText(goalText, 100)}"</em><br/><br/>Select where you want to move this learning goal:`;
        $('#moveModalLabel').html('<i class="bi bi-arrow-left-right text-info"></i> Move Learning Goal');
    } else {
        // This should not happen anymore since we only allow goal moves
        alert('Invalid move operation. Only individual learning goals can be moved.');
        return;
    }
    
    $('#move-description').html(description);
    
    // Reset new group panel
    resetNewGroupPanel();
    
    // Build destination tree
    buildMoveDestinationTree();
    
    // Clear search
    $('#move-search').val('');
    
    // Show modal
    $('#moveModal').modal('show');
}

function buildMoveDestinationTree() {
    // Only show leaf nodes (deepest level groups that can contain goals)
    const leafNodes = collectLeafNodes(currentArtifact.tree_structure);
    const treeHtml = buildMoveDestinationLeafNodes(leafNodes);
    $('#move-destination-tree').html(treeHtml);
    
    // Reapply lock state to newly created elements
    if (window.lockManager) {
        window.lockManager.forceReapplyLockState();
    }
}

function collectLeafNodes(nodes, path = []) {
    // Collect all leaf nodes (deepest level groups that can contain goals)
    let leafNodes = [];
    
    if (!nodes || !Array.isArray(nodes)) return leafNodes;
    
    nodes.forEach((node, index) => {
        if (!node || typeof node !== 'object') return;
        
        // Use representative text instead of labels (A2B3C1...) for meaningful paths
        const nodeName = node.representative_goal || `Group ${index + 1}`;
        const nodePath = [...path, nodeName];
        const hasChildren = node.children && node.children.length > 0;
        
        if (!hasChildren) {
            // This is a leaf node - can accept learning goals
            leafNodes.push({
                ...node,
                fullPath: nodePath.join(' > ')
            });
        } else {
            // Recursively collect leaf nodes from children
            leafNodes = leafNodes.concat(collectLeafNodes(node.children, nodePath));
        }
    });
    
    return leafNodes;
}

function buildMoveDestinationLeafNodes(leafNodes) {
    // Build a simple list of leaf nodes as move destinations
    let html = '';
    
    if (!leafNodes || leafNodes.length === 0) {
        return '<div class="text-center p-3 text-muted">No valid destinations found</div>';
    }
    
    leafNodes.forEach((node, index) => {
        const isCurrentLocation = node.id === currentMoveNodeId;
        const nodeTitle = node.representative_goal || `Group ${node.label}`;
        
        const nodeClasses = [
            'destination-node',
            isCurrentLocation ? 'current-location' : ''
        ].filter(Boolean).join(' ');
        
        html += `
            <div class="${nodeClasses}" data-node-id="${node.id}" data-node-name="${nodeTitle.toLowerCase()}">
                <div class="destination-node-content">
                    <div class="destination-node-text" title="${nodeTitle}">
                        ${truncateText(nodeTitle, 70)}
                    </div>
                    <i class="bi bi-info-circle destination-path-info" 
                       title="${node.fullPath}" 
                       onclick="event.stopPropagation(); showPathTooltip(this, '${node.fullPath.replace(/'/g, "&apos;")}')"
                       style="color: #6c757d; cursor: help; margin-left: 8px; font-size: 0.8em;">
                    </i>
                </div>
                ${!isCurrentLocation ? `
                    <button class="move-here-btn" onclick="performMove('${node.id}')">
                        Move Here
                    </button>
                ` : '<small class="text-warning">(Current Location)</small>'}
            </div>
        `;
    });
    
    return html;
}

function filterMoveDestinations(searchTerm) {
    const destinations = $('.destination-node');
    
    if (!searchTerm.trim()) {
        // Clear search - show all destinations
        destinations.removeClass('search-match').show();
        $('#no-matches').remove();
        return;
    }
    
    const lowerSearchTerm = searchTerm.toLowerCase();
    let hasMatches = false;
    
    destinations.each(function() {
        // Only search on the node name (not the full path)
        const nodeName = $(this).data('node-name') || $(this).find('.destination-node-text').text().toLowerCase();
        const isMatch = nodeName.includes(lowerSearchTerm);
        
        if (isMatch) {
            $(this).addClass('search-match').show();
            hasMatches = true;
        } else {
            $(this).removeClass('search-match').hide();
        }
    });
    
    if (!hasMatches) {
        $('#move-destination-tree').prepend('<div class="text-muted text-center p-3" id="no-matches">No matching destinations found</div>');
    } else {
        $('#no-matches').remove();
    }
}

function showPathTooltip(element, fullPath) {
    // Remove any existing tooltips
    $('.path-tooltip').remove();
    
    // Create and show a temporary tooltip
    const tooltip = $(`
        <div class="path-tooltip" style="
            position: absolute;
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.8em;
            z-index: 10000;
            max-width: 300px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            pointer-events: none;
        ">
            <strong>Full Path:</strong><br/>${fullPath}
        </div>
    `);
    
    $('body').append(tooltip);
    
    // Position the tooltip near the icon
    const iconOffset = $(element).offset();
    tooltip.css({
        top: iconOffset.top - tooltip.outerHeight() - 5,
        left: Math.max(10, iconOffset.left - tooltip.outerWidth() / 2)
    });
    
    // Auto-hide after 3 seconds
    setTimeout(() => {
        tooltip.fadeOut(200, () => tooltip.remove());
    }, 3000);
}

// Node-level validation functions removed - no longer needed for goal-only operations

function performMove(destinationNodeId) {
    if (!currentMoveNodeId || !currentMoveType) {
        alert('Invalid move operation');
        return;
    }
    
    // Show progress
    showProgress('Moving...', 'Updating tree structure...');
    
    const moveData = {
        artifact_id: currentArtifactId,
        source_node_id: currentMoveNodeId,
        destination_node_id: destinationNodeId,
        move_type: currentMoveType,
        goal_index: currentMoveGoalIndex
    };
    
    $.ajax({
        url: '/api/move-learning-goal',
        method: 'POST',
        contentType: 'application/json',
        data: JSON.stringify(moveData)
    })
    .done(function(response) {
        hideProgress();
        
        if (response.success) {
            // Update the current artifact with the new structure
            currentArtifact.tree_structure = response.updated_tree_structure;
            
            // Clear cache since tree structure changed
            flattenedCache = {};
            
            // Refresh the display
            if (flattenedAtLevel !== null) {
                flattenAtLevel(flattenedAtLevel);
            } else {
                displayTree(currentArtifact.tree_structure);
            }
            
            // Close modal
            $('#moveModal').modal('hide');
            
            // Show success message
            const moveTypeText = currentMoveType === 'goal' ? 'learning goal' : 'group';
            alert(`âœ… Successfully moved ${moveTypeText}!`);
        } else {
            alert('Failed to move: ' + response.message);
        }
    })
    .fail(function() {
        hideProgress();
        alert('Failed to move: Network error');
    });
}

// deleteNode function removed - we only delete individual learning goals now

function deleteGoal(nodeId, goalIndex) {
    // Validate inputs first
    if (!currentArtifact || !currentArtifact.tree_structure) {
        alert('Error: No artifact loaded. Please load an artifact first.');
        return;
    }
    
    const node = findNodeById(currentArtifact.tree_structure, nodeId);
    
    if (!node || !node.goals || goalIndex >= node.goals.length) {
        console.error('Goal not found for deletion:', { nodeId, goalIndex, availableGoals: node ? (node.goals ? node.goals.length : 0) : 'node not found' });
        alert(`Error: Learning goal not found (index: ${goalIndex}). The goal may have been moved or deleted.`);
        return;
    }
    
    const goalText = node.goals[goalIndex];
    const confirmMessage = `Are you sure you want to delete this learning goal?\n\n"${truncateText(goalText, 100)}"\n\nIt will be moved to the archive.`;
    
    if (!confirm(confirmMessage)) return;
    
    // Show progress
    showProgress('Deleting...', 'Moving to archive...');
    
    $.ajax({
        url: '/api/delete-goal',
        method: 'POST',
        contentType: 'application/json',
        data: JSON.stringify({
            artifact_id: currentArtifactId,
            node_id: nodeId,
            goal_index: goalIndex
        })
    })
    .done(function(response) {
        hideProgress();
        
        if (response.success) {
            // Update the current artifact with the new structure
            currentArtifact.tree_structure = response.updated_tree_structure;
            
            // Clear cache since tree structure changed
            flattenedCache = {};
            
            // Refresh the display
            if (flattenedAtLevel !== null) {
                flattenAtLevel(flattenedAtLevel);
            } else {
                displayTree(currentArtifact.tree_structure);
            }
            
            alert('âœ… Learning goal deleted successfully and moved to archive.');
        } else {
            alert('Failed to delete: ' + response.message);
        }
    })
    .fail(function() {
        hideProgress();
        alert('Failed to delete: Network error');
    });
}

function loadArchivedGoals() {
    $('#archived-goals-container').html('<div class="text-center p-3"><div class="spinner-border spinner-border-sm"></div> Loading archived goals...</div>');
    $('#archiveModal').modal('show');
    
    $.get(`/api/get-archived-goals/${currentArtifactId}`)
        .done(function(response) {
            if (response.success) {
                displayArchivedGoals(response.archived_goals);
            } else {
                $('#archived-goals-container').html('<div class="text-center p-3 text-muted">Failed to load archived goals</div>');
            }
        })
        .fail(function() {
            $('#archived-goals-container').html('<div class="text-center p-3 text-muted">Network error loading archived goals</div>');
        });
}

function displayArchivedGoals(archivedGoals) {
    if (!archivedGoals || archivedGoals.length === 0) {
        $('#archived-goals-container').html('<div class="text-center p-3 text-muted">No archived learning goals found</div>');
        return;
    }
    
    let html = '';
    archivedGoals.forEach((archivedGoal, index) => {
        const archivedDate = new Date(archivedGoal.archived_at).toLocaleDateString();
        html += `
            <div class="archived-goal-item">
                <div class="archived-goal-text">"${archivedGoal.goal_text}"</div>
                <div class="archived-goal-meta">
                    <div>
                        <small>ðŸ“„ ${archivedGoal.document_name || 'Unknown'} | ðŸ‘¤ ${archivedGoal.creator || 'Unknown'}</small><br/>
                        <small>ðŸ—“ï¸ Archived: ${archivedDate} | Original path: ${archivedGoal.original_path || 'Unknown'}</small>
                    </div>
                    <button class="restore-btn" onclick="restoreGoal('${archivedGoal.id}', ${index})" title="Restore this learning goal">
                        â†©ï¸ Restore
                    </button>
                </div>
            </div>
        `;
    });
    
    $('#archived-goals-container').html(html);
}

function restoreGoal(archivedGoalId, index) {
    if (!confirm('Restore this learning goal to its original location?')) return;
    
    $.ajax({
        url: '/api/restore-goal',
        method: 'POST',
        contentType: 'application/json',
        data: JSON.stringify({
            artifact_id: currentArtifactId,
            archived_goal_id: archivedGoalId
        })
    })
    .done(function(response) {
        if (response.success) {
            // Update the current artifact with the new structure
            currentArtifact.tree_structure = response.updated_tree_structure;
            
            // Clear cache since tree structure changed
            flattenedCache = {};
            
            // Refresh the display
            if (flattenedAtLevel !== null) {
                flattenAtLevel(flattenedAtLevel);
            } else {
                displayTree(currentArtifact.tree_structure);
            }
            
            // Remove the restored item from the archive display
            $(`.archived-goal-item:eq(${index})`).fadeOut();
            
            alert('âœ… Learning goal restored successfully!');
        } else {
            alert('Failed to restore: ' + response.message);
        }
    })
    .fail(function() {
        alert('Failed to restore: Network error');
    });
}

function showProgress(title, details) {
    $('#progress-text').text(title);
    $('#progress-details').text(details);
    $('#operation-progress').show();
}

function hideProgress() {
    $('#operation-progress').hide();
}

// =====================================
// NEW GROUP CREATION FUNCTIONALITY
// =====================================

function resetNewGroupPanel() {
    const panel = $('#create-new-group-panel');
    const btn = $('#create-new-group-btn');
    
    // Reset to initial state
    panel.hide();
    btn.html('<i class="bi bi-plus-circle-dotted"></i> Create new group instead');
    selectedNewGroupLocation = null;
    currentNewGroupName = null;
    $('#create-and-move-btn').prop('disabled', true);
    $('#new-group-tree-selector').empty();
    $('.tree-level-item').removeClass('selected');
}

function showCreateGroupInfo() {
    alert(`About Creating New Groups:\n\nâ€¢ Use this option if none of the existing groups above are suitable for your learning goal\nâ€¢ A new group will be created with your learning goal as its name\nâ€¢ You'll choose where in the hierarchy to place this new group\nâ€¢ You can only create new groups at the level that contains other groups (not deeper levels)`);
}

function toggleCreateNewGroup() {
    const panel = $('#create-new-group-panel');
    const btn = $('#create-new-group-btn');
    
    if (panel.is(':visible')) {
        // Hide the panel
        panel.slideUp();
        btn.html('<i class="bi bi-plus-circle-dotted"></i> Create new group instead');
        selectedNewGroupLocation = null;
        $('#create-and-move-btn').prop('disabled', true);
    } else {
        // Show the panel and set up the goal name
        if (currentMoveType === 'goal' && currentMoveGoalIndex !== null) {
            const sourceNode = findNodeById(currentArtifact.tree_structure, currentMoveNodeId);
            if (sourceNode && sourceNode.goals && sourceNode.goals[currentMoveGoalIndex]) {
                currentNewGroupName = sourceNode.goals[currentMoveGoalIndex];
                $('#new-group-name-preview').text(truncateText(currentNewGroupName, 100));
                
                // Build the hierarchical tree selector
                buildNewGroupTreeSelector();
                
                panel.slideDown();
                btn.html('<i class="bi bi-x-circle text-muted"></i> Cancel');
            }
        }
    }
}

function buildNewGroupTreeSelector() {
    // Start with top-level nodes - no "Select Here" buttons at top level
    const topLevelHtml = buildTreeLevel(currentArtifact.tree_structure, [], 'top');
    
    $('#new-group-tree-selector').html(topLevelHtml);
}

function isSecondToLastLevel(node) {
    // A node is at second-to-last level if:
    // 1. It has children (not a leaf group itself)
    // 2. All its children are leaf groups (have no children of their own)
    if (!node.children || node.children.length === 0) {
        return false; // This is a leaf group
    }
    
    // Check if all children are leaf groups
    return node.children.every(child => !child.children || child.children.length === 0);
}

function buildTreeLevel(nodes, path = [], containerId = null) {
    let html = '';
    
    nodes.forEach((node, index) => {
        const hasChildren = node.children && node.children.length > 0;
        const nodeTitle = node.representative_goal || `Group ${node.label}`;
        const currentPath = [...path, { id: node.id, title: nodeTitle }];
        const pathStr = JSON.stringify(currentPath).replace(/"/g, '&quot;');
        
        const itemId = containerId ? `${containerId}-${index}` : `item-${index}`;
        const canSelectHere = isSecondToLastLevel(node);
        
        html += `
            <div class="tree-level-item ${hasChildren ? '' : 'leaf'}" data-node-id="${node.id}" data-item-id="${itemId}">
                ${hasChildren ? 
                    `<i class="bi bi-chevron-right expand-icon" onclick="event.stopPropagation(); toggleTreeLevel('${itemId}', '${node.id}', '${pathStr}')"></i>` :
                    `<i class="bi bi-circle-fill expand-icon"></i>`
                }
                <div class="tree-level-text" title="${nodeTitle}">
                    ${truncateText(nodeTitle, 60)}
                    ${canSelectHere ? ' <small class="text-success">(can add groups here)</small>' : ''}
                </div>
                ${canSelectHere ? `
                    <button class="select-location-btn" onclick="event.stopPropagation(); selectNewGroupLocation('${node.id}', '${pathStr}')">
                        Select Here
                    </button>
                ` : hasChildren ? '<small class="text-muted">Navigate deeper â†“</small>' : '<small class="text-muted">Group</small>'}
            </div>
            ${hasChildren ? `<div class="tree-children" id="children-${itemId}" style="display: none;"></div>` : ''}
        `;
    });
    
    return html;
}

function toggleTreeLevel(itemId, nodeId, pathStr) {
    const item = $(`[data-item-id="${itemId}"]`);
    const childrenContainer = $(`#children-${itemId}`);
    const icon = item.find('.expand-icon');
    
    if (childrenContainer.is(':visible')) {
        // Collapse
        childrenContainer.slideUp();
        icon.removeClass('bi-chevron-down').addClass('bi-chevron-right');
        item.removeClass('expanded');
    } else {
        // Expand - load children if not already loaded
        if (childrenContainer.is(':empty')) {
            const node = findNodeById(currentArtifact.tree_structure, nodeId);
            if (node && node.children) {
                const path = JSON.parse(pathStr.replace(/&quot;/g, '"'));
                const childrenHtml = buildTreeLevel(node.children, path, itemId);
                childrenContainer.html(childrenHtml);
            }
        }
        
        childrenContainer.slideDown();
        icon.removeClass('bi-chevron-right').addClass('bi-chevron-down');
        item.addClass('expanded');
    }
}

function selectNewGroupLocation(locationId, pathStr) {
    // Clear previous selection
    $('.tree-level-item').removeClass('selected');
    
    // Set new selection - only "under" type since we removed top-level creation
    const path = JSON.parse(pathStr.replace(/&quot;/g, '"'));
    selectedNewGroupLocation = { type: 'under', parentId: locationId, path: path };
    $(`[data-node-id="${locationId}"]`).addClass('selected');
    
    // Enable the create button
    $('#create-and-move-btn').prop('disabled', false);
}

function createNewGroupAndMove() {
    if (!selectedNewGroupLocation || !currentNewGroupName) {
        alert('Please select a location for the new group');
        return;
    }
    
    // Show progress
    showProgress('Creating new group...', 'Creating group and moving goal...');
    
    // Prepare the data for the backend
    const createData = {
        artifact_id: currentArtifactId,
        source_node_id: currentMoveNodeId,
        goal_index: currentMoveGoalIndex,
        new_group_name: currentNewGroupName,
        location: selectedNewGroupLocation
    };
    
    $.ajax({
        url: '/api/create-group-and-move-goal',
        method: 'POST',
        contentType: 'application/json',
        data: JSON.stringify(createData)
    })
    .done(function(response) {
        hideProgress();
        
        if (response.success) {
            // Update the current artifact with the new structure
            currentArtifact.tree_structure = response.updated_tree_structure;
            
            // Clear cache since tree structure changed
            flattenedCache = {};
            
            // Refresh the display
            if (flattenedAtLevel !== null) {
                flattenAtLevel(flattenedAtLevel);
            } else {
                displayTree(currentArtifact.tree_structure);
            }
            
            // Close modal
            $('#moveModal').modal('hide');
            
            // Show success message
            alert(`âœ… Successfully created new group "${truncateText(currentNewGroupName, 50)}" and moved the learning goal!`);
        } else {
            alert('Failed to create group and move goal: ' + response.message);
        }
    })
    .fail(function() {
        hideProgress();
        alert('Failed to create group and move goal: Network error');
    });
}

// =====================================
// CSV DOWNLOAD FUNCTIONALITY
// =====================================

function updateDownloadOptions(flattened) {
    // Check what data is available in the flattened clusters
    const availableFields = {
        institution: false,
        creator: false,
        course_name: false
    };
    
    // Check all sources for available fields
    flattened.forEach(cluster => {
        cluster.goalsWithSource.forEach(goalData => {
            const { source } = goalData;
            if (source.institution && source.institution.trim() !== '') {
                availableFields.institution = true;
            }
            if (source.creator && source.creator.trim() !== '') {
                availableFields.creator = true;
            }
            if (source.course_name && source.course_name.trim() !== '') {
                availableFields.course_name = true;
            }
        });
    });
    
    // Update dropdown options
    const dropdown = $('#download-column-type');
    const currentValue = dropdown.val();
    dropdown.empty();
    
    if (availableFields.institution) {
        dropdown.append('<option value="institution">by Institution</option>');
    }
    if (availableFields.creator) {
        dropdown.append('<option value="creator">by Creator</option>');
    }
    if (availableFields.course_name) {
        dropdown.append('<option value="course_name">by Course</option>');
    }
    
    // If no fields are available, show a default option
    if (!availableFields.institution && !availableFields.creator && !availableFields.course_name) {
        dropdown.append('<option value="creator">by Creator (Limited Data)</option>');
    }
    
    // Try to restore previous selection if still available
    if (dropdown.find(`option[value="${currentValue}"]`).length > 0) {
        dropdown.val(currentValue);
    }
}

function downloadFlattenedCSV(levelLabel) {
    if (!currentArtifact || flattenedAtLevel === null) {
        alert('No flattened view available to download');
        return;
    }
    
    const columnType = $('#download-column-type').val();
    
    // Get flattened data for the current level
    const flattened = flattenTreeAtLevel(currentArtifact.tree_structure, flattenedAtLevel);
    
    if (!flattened || flattened.length === 0) {
        alert('No data available to download');
        return;
    }
    
    // Helper function to properly escape CSV values
    function escapeCSVField(field) {
        // Convert to string and handle null/undefined
        const str = String(field || '');
        
        // If the field contains commas, quotes, or newlines, wrap in quotes and escape internal quotes
        if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
            return '"' + str.replace(/"/g, '""') + '"';
        }
        return str;
    }
    
    // Collect all unique values for the selected column type
    const allUniqueValues = new Set();
    const clusterData = {};
    
    // Process each cluster
    flattened.forEach(cluster => {
        const clusterName = cluster.representative || cluster.originalNode.representative_goal || cluster.label;
        clusterData[clusterName] = {};
        
        cluster.goalsWithSource.forEach(goalData => {
            const { source } = goalData;
            let columnValue = source[columnType];
            
            // Handle missing data
            if (!columnValue || columnValue.trim() === '') {
                columnValue = `Unknown ${columnType.replace('_', ' ')}`;
            }
            
            allUniqueValues.add(columnValue);
            
            // Count goals for this column value in this cluster
            if (!clusterData[clusterName][columnValue]) {
                clusterData[clusterName][columnValue] = 0;
            }
            clusterData[clusterName][columnValue]++;
        });
    });
    
    // Convert to sorted array and escape column headers
    const sortedColumnValues = Array.from(allUniqueValues).sort();
    const escapedColumnHeaders = sortedColumnValues.map(escapeCSVField);
    
    // Generate CSV content with proper escaping
    let csvContent = escapeCSVField("Cluster Name") + "," + escapedColumnHeaders.join(',') + "\n";
    
    // Add data rows
    Object.keys(clusterData).forEach(clusterName => {
        const row = [escapeCSVField(clusterName)];
        sortedColumnValues.forEach(columnValue => {
            const count = clusterData[clusterName][columnValue] || 0;
            row.push(count); // Numbers don't need escaping
        });
        csvContent += row.join(',') + "\n";
    });
    
    // Create and download the file
    const columnTypeLabel = columnType.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
    const filename = `LG_Hierarchy_Level_${levelLabel}_by_${columnTypeLabel.replace(' ', '_')}.csv`;
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    if (link.download !== undefined) {
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', filename);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    } else {
        alert('Browser does not support file download');
    }
}

// ===== NEW: Lazy-load skeleton builder =====
function buildTreeNodeSkeleton(node, level = 0) {
    const levelClass = level <= 10 ? `tree-level-${level}` : 'tree-level-deep';
    const hasChildren = node.children && node.children.length > 0;
    const hasGoals = node.goals && node.goals.length > 0;

    // Representative text & state/icon (same as full builder)
    let representativeText = node.representative_goal || '';
    let textState = node.text_state || 'default';
    let stateIcon = 'fa-quote-left';
    if (textState === 'manual') stateIcon = 'fa-pencil';
    else if (textState === 'ai') stateIcon = 'fa-wand-magic-sparkles';

    if (!representativeText && hasGoals) {
        representativeText = node.goals.reduce((longest, current) => current.length > longest.length ? current : longest);
    } else if (!representativeText && hasChildren) {
        representativeText = findRepresentativeGoal(node);
    }

    let html = `<div class="tree-node ${levelClass}" data-level="${level}" data-node-id="${node.id}">`;

    // header (identical)
    html += `
        <div class="cluster-header" onclick="toggleCluster('${node.id}')">
            ${hasChildren ? '<i class="bi bi-chevron-right collapse-icon"></i>' : '<i class="bi bi-circle-fill collapse-icon" style="font-size: 0.5em;"></i>'}
            <div class="cluster-representative" contenteditable="true" data-state="${textState}" onclick="event.stopPropagation(); startEditing(this)" onblur="saveRepresentativeText(this, '${node.id}')" onkeydown="handleRepresentativeKeydown(event, this, '${node.id}')">
                <i class="fa ${stateIcon} text-state-icon"></i>
                <span class="representative-text">${representativeText}</span>
            </div>
            <button class="auto-generate-btn" onclick="event.stopPropagation(); openAIGenerationModal('${node.id}')" title="Generate with AI"><i class="fa fa-wand-magic-sparkles"></i></button>
            <span class="cluster-label">${node.label}</span>
            <span class="cluster-size">${node.size || 0}</span>
        </div>`;

    // Empty content container â€“ populated lazily when expanded
    if (hasGoals || hasChildren) {
        html += `<div class="cluster-content" id="content-${node.id}" style="display:none;"></div>`;
    }

    html += '</div>';
    return html;
}

// ===== NEW: Build content for a node lazily =====
function buildClusterContent(node, level) {
    let innerHtml = '';

    // Goals first (if any)
    if (node.goals && node.goals.length > 0) {
        node.goals.forEach((goal, idx) => {
            const source = node.sources ? node.sources[idx] : {};
            innerHtml += `
                <div class="goal-item" data-goal-index="${idx}">
                    <div class="d-flex justify-content-between align-items-start">
                        <div class="flex-grow-1">
                            <div class="goal-text">"${goal}"</div>
                            <div class="goal-source">ðŸ“„ <span class="document-link" onclick="openDocumentModal('${source.document_name || 'Unknown'}', '${source.creator || 'Unknown'}')" title="Click to view document">${truncateText(source.document_name || 'Unknown',25)}</span> | ðŸ‘¤ ${truncateText(source.creator || 'Unknown',15)}${source.course_name?` | ðŸ“š ${truncateText(source.course_name,20)}`:''}${source.institution?` | ðŸ›ï¸ ${truncateText(source.institution,20)}`:''}</div>
                        </div>
                        <div class="goal-actions">
                            <button class="goal-move-btn" onclick="openMoveModal('${node.id}','goal',${idx})" title="Move this learning goal">â†”</button>
                            <button class="goal-delete-btn" onclick="deleteGoal('${node.id}',${idx})" title="Delete this learning goal">ðŸ—‘</button>
                        </div>
                    </div>
                </div>`;
        });
    }

    // Children skeletons
    if (node.children && node.children.length > 0) {
        node.children.forEach(child => {
            innerHtml += buildTreeNodeSkeleton(child, level + 1);
        });
    }

    return innerHtml;
}

// ===== MODIFY: buildAndDisplayTree uses skeleton =====
// ... existing code ...

// =====================================
// SEARCH FUNCTIONALITY
// =====================================

let searchResults = {
    clusterMatches: 0,
    goalMatches: 0,
    totalVisible: 0
};

function performTreeSearch(searchTerm) {
    const term = searchTerm.trim().toLowerCase();
    
    if (!term) {
        clearTreeSearch();
        return;
    }
    
    // Reset search results
    searchResults = { clusterMatches: 0, goalMatches: 0, totalVisible: 0 };
    
    if ($('#flattened-content').is(':visible')) {
        // Search in flattened view
        searchFlattenedView(term);
    } else {
        // Search in tree view
        searchTreeView(term);
    }
    
    // Update search results info
    updateSearchResultsInfo(term);
}

function searchTreeView(term) {
    // Remove previous search classes
    $('.search-match-cluster, .search-match-goal, .search-hidden').removeClass('search-match-cluster search-match-goal search-hidden');
    $('.search-highlight').contents().unwrap();
    
    // STEP 1: Recursively load ALL content deep for comprehensive search
    recursivelyLoadAllTreeContent();
    
    // STEP 2: Identify all matches (clusters and individual goals)
    const matchingElements = new Set();
    const pathToMatches = new Set(); // Nodes that need to be shown because they're on path to matches
    
    $('.tree-node').each(function() {
        const $node = $(this);
        const nodeId = $node.data('node-id');
        let nodeHasDirectMatch = false;
        
        // Check cluster name match
        const $representative = $node.find('> .cluster-header .representative-text');
        if ($representative.length) {
            const representativeText = $representative.text().toLowerCase();
            if (representativeText.includes(term)) {
                nodeHasDirectMatch = true;
                matchingElements.add(nodeId);
                $node.find('> .cluster-header').addClass('search-match-cluster');
                highlightText($representative, term);
                searchResults.clusterMatches++;
            }
        }
        
        // Check individual goals
        $node.find('> .cluster-content .goal-item').each(function() {
            const $goalItem = $(this);
            const $goalText = $goalItem.find('.goal-text');
            const goalText = $goalText.text().toLowerCase();
            
            if (goalText.includes(term)) {
                $goalItem.addClass('search-match-goal');
                highlightText($goalText, term);
                matchingElements.add(nodeId); // Mark parent node as having matches
                searchResults.goalMatches++;
            }
        });
        
        // If this node has matches, mark all its ancestors as needed
        if (matchingElements.has(nodeId)) {
            $node.parents('.tree-node').each(function() {
                const ancestorId = $(this).data('node-id');
                pathToMatches.add(ancestorId);
            });
        }
    });
    
    // STEP 3: Show/hide based on matches and expand all matching paths
    $('.tree-node').each(function() {
        const $node = $(this);
        const nodeId = $node.data('node-id');
        
        if (matchingElements.has(nodeId) || pathToMatches.has(nodeId)) {
            $node.show();
            searchResults.totalVisible++;
            
            // Force expand all content for search view
            const $content = $node.find('> .cluster-content');
            if ($content.length) {
                $content.show();
                $node.find('> .cluster-header .collapse-icon').addClass('expanded');
                $node.find('> .cluster-header').addClass('expanded');
            }
            
            // ALWAYS hide non-matching goals, regardless of whether cluster name matches
            $node.find('> .cluster-content .goal-item').each(function() {
                if (!$(this).hasClass('search-match-goal')) {
                    $(this).addClass('search-hidden');
                }
            });
        } else {
            $node.addClass('search-hidden');
        }
    });
}

function searchFlattenedView(term) {
    // Remove previous search classes
    $('.search-match-cluster, .search-match-goal, .search-hidden').removeClass('search-match-cluster search-match-goal search-hidden');
    $('.search-highlight').contents().unwrap();
    
    // Force load and expand all clusters first for comprehensive search
    $('.flattened-cluster').each(function() {
        const $cluster = $(this);
        const $content = $cluster.find('.cluster-content');
        
        if ($content.length && $content.attr('data-loaded') === 'false') {
            const clusterId = $content.attr('id').replace('flattened-content-', '');
            const index = parseInt(clusterId);
            if (currentFlattenedData[index]) {
                // Synchronously build content for search
                const clusterData = currentFlattenedData[index];
                let goalsHtml = '';
                clusterData.goalsWithSource.forEach((goalData, goalIndex) => {
                    const { goal, source, sourceNodeId, originalIndex } = goalData;
                    goalsHtml += `<div class="goal-item" data-goal-index="${goalIndex}"><div class="d-flex justify-content-between align-items-start"><div class="flex-grow-1"><div class="goal-text">"${goal}"</div><div class="goal-source">ðŸ“„ <span class="document-link" onclick="openDocumentModal('${source.document_name || 'Unknown'}', '${source.creator || 'Unknown'}')" title="Click to view document">${truncateText(source.document_name || 'Unknown',25)}</span> | ðŸ‘¤ ${truncateText(source.creator || 'Unknown',15)}${source.course_name ? ` | ðŸ“š ${truncateText(source.course_name,20)}` : ''}${source.institution ? ` | ðŸ›ï¸ ${truncateText(source.institution,20)}` : ''}</div></div><div class="goal-actions"><button class="goal-move-btn" onclick="openMoveModal('${sourceNodeId}','goal',${originalIndex})" title="Move this learning goal">â†”</button><button class="goal-delete-btn" onclick="deleteGoal('${sourceNodeId}',${originalIndex})" title="Delete this learning goal">ðŸ—‘</button></div></div></div>`;
                });
                $content.html(goalsHtml);
                $content.attr('data-loaded', 'true');
            }
        }
        
        // Force expand all clusters
        if ($content.length) {
            $content.show();
            $cluster.find('.cluster-header .collapse-icon').addClass('expanded');
            $cluster.find('.cluster-header').addClass('expanded');
        }
    });
    
    // Now search through everything and filter
    $('.flattened-cluster').each(function() {
        const $cluster = $(this);
        let clusterNameMatches = false;
        let hasMatchingGoals = false;
        
        // Check cluster name match
        const $representative = $cluster.find('.cluster-header .representative-text');
        if ($representative.length) {
            const representativeText = $representative.text().toLowerCase();
            if (representativeText.includes(term)) {
                $cluster.find('.cluster-header').addClass('search-match-cluster');
                highlightText($representative, term);
                clusterNameMatches = true;
                searchResults.clusterMatches++;
            }
        }
        
        // Check individual goals and mark/hide them
        const $content = $cluster.find('.cluster-content');
        if ($content.length) {
            $content.find('.goal-item').each(function() {
                const $goalItem = $(this);
                const $goalText = $goalItem.find('.goal-text');
                const goalText = $goalText.text().toLowerCase();
                
                if (goalText.includes(term)) {
                    $goalItem.addClass('search-match-goal');
                    highlightText($goalText, term);
                    hasMatchingGoals = true;
                    searchResults.goalMatches++;
                } else {
                    // ALWAYS hide goals that don't match, regardless of cluster name match
                    $goalItem.addClass('search-hidden');
                }
            });
        }
        
        // Show/hide entire cluster based on matches
        if (clusterNameMatches || hasMatchingGoals) {
            $cluster.show();
            searchResults.totalVisible++;
        } else {
            $cluster.addClass('search-hidden');
        }
    });
}

// =====================================
// DEEP TREE LOADING FOR SEARCH
// =====================================

function recursivelyLoadAllTreeContent() {
    // We need to keep loading until no more empty content containers exist
    let moreToLoad = true;
    let iterations = 0;
    const maxIterations = 20; // Safety limit to prevent infinite loops
    
    while (moreToLoad && iterations < maxIterations) {
        moreToLoad = false;
        iterations++;
        
        $('.tree-node').each(function() {
            const $node = $(this);
            const nodeId = $node.data('node-id');
            const $content = $node.find('> .cluster-content');
            
            // If content is empty, load it with FULL content (not skeletons)
            if ($content.length && $content.is(':empty')) {
                const node = findNodeById(currentArtifact.tree_structure, nodeId);
                if (node) {
                    const parentLevel = parseInt($node.attr('data-level')) || 0;
                    const innerHtml = buildFullClusterContent(node, parentLevel + 1);
                    $content.html(innerHtml);
                    moreToLoad = true; // Continue iterating since we added new content
                }
            }
        });
    }
    
    if (iterations >= maxIterations) {
        console.warn('Tree loading reached maximum iterations. Some deep content might not be loaded.');
    }
}

function buildFullClusterContent(node, level) {
    // This is like buildClusterContent but builds FULL content, not skeletons
    let innerHtml = '';

    // Goals first (if any)
    if (node.goals && node.goals.length > 0) {
        node.goals.forEach((goal, idx) => {
            const source = node.sources ? node.sources[idx] : {};
            innerHtml += `
                <div class="goal-item" data-goal-index="${idx}">
                    <div class="d-flex justify-content-between align-items-start">
                        <div class="flex-grow-1">
                            <div class="goal-text">"${goal}"</div>
                            <div class="goal-source">ðŸ“„ <span class="document-link" onclick="openDocumentModal('${source.document_name || 'Unknown'}', '${source.creator || 'Unknown'}')" title="Click to view document">${truncateText(source.document_name || 'Unknown',25)}</span> | ðŸ‘¤ ${truncateText(source.creator || 'Unknown',15)}${source.course_name?` | ðŸ“š ${truncateText(source.course_name,20)}`:''}${source.institution?` | ðŸ›ï¸ ${truncateText(source.institution,20)}`:''}</div>
                        </div>
                        <div class="goal-actions">
                            <button class="goal-move-btn" onclick="openMoveModal('${node.id}','goal',${idx})" title="Move this learning goal">â†”</button>
                            <button class="goal-delete-btn" onclick="deleteGoal('${node.id}',${idx})" title="Delete this learning goal">ðŸ—‘</button>
                        </div>
                    </div>
                </div>`;
        });
    }

    // FULL children trees (not skeletons) - this is the key difference
    if (node.children && node.children.length > 0) {
        node.children.forEach(child => {
            innerHtml += buildFullTreeNode(child, level + 1);
        });
    }

    return innerHtml;
}

function buildFullTreeNode(node, level = 0) {
    // This builds a complete tree node with all content loaded (not skeleton)
    const levelClass = level <= 10 ? `tree-level-${level}` : 'tree-level-deep';
    const hasChildren = node.children && node.children.length > 0;
    const hasGoals = node.goals && node.goals.length > 0;
    
    // Get representative text and determine state
    let representativeText = node.representative_goal || '';
    let textState = node.text_state || 'default';
    let stateIcon = 'fa-quote-left';
    if (textState === 'manual') stateIcon = 'fa-pencil';
    else if (textState === 'ai') stateIcon = 'fa-wand-magic-sparkles';
    
    if (!representativeText && hasGoals) {
        representativeText = node.goals.reduce((longest, current) => 
            current.length > longest.length ? current : longest
        );
    } else if (!representativeText && hasChildren) {
        representativeText = findRepresentativeGoal(node);
    }
    
    let nodeHtml = `<div class="tree-node ${levelClass}" data-level="${level}" data-node-id="${node.id}">`;
    
    // Node header
    nodeHtml += `
        <div class="cluster-header" onclick="toggleCluster('${node.id}')">
            ${hasChildren ? '<i class="bi bi-chevron-right collapse-icon"></i>' : '<i class="bi bi-circle-fill collapse-icon" style="font-size: 0.5em;"></i>'}
            <div class="cluster-representative" contenteditable="true" data-state="${textState}" onclick="event.stopPropagation(); startEditing(this)" onblur="saveRepresentativeText(this, '${node.id}')" onkeydown="handleRepresentativeKeydown(event, this, '${node.id}')">
                <i class="fa ${stateIcon} text-state-icon"></i>
                <span class="representative-text">${representativeText}</span>
            </div>
            <button class="auto-generate-btn" onclick="event.stopPropagation(); openAIGenerationModal('${node.id}')" title="Generate with AI"><i class="fa fa-wand-magic-sparkles"></i></button>
            <span class="cluster-label">${node.label}</span>
            <span class="cluster-size">${node.size || 0}</span>
        </div>`;
    
    // FULL content (goals and children) - not empty container
    if ((hasGoals || hasChildren) && (hasGoals || node.size > 0)) {
        nodeHtml += `<div class="cluster-content" id="content-${node.id}" style="display: none;">`;
        
        // Add goals if any
        if (hasGoals) {
            node.goals.forEach(function(goal, index) {
                const source = node.sources ? node.sources[index] : {};
                nodeHtml += `
                    <div class="goal-item" data-goal-index="${index}">
                        <div class="d-flex justify-content-between align-items-start">
                            <div class="flex-grow-1">
                                <div class="goal-text">"${goal}"</div>
                                <div class="goal-source">
                                    ðŸ“„ <span class="document-link" onclick="openDocumentModal('${source.document_name || 'Unknown'}', '${source.creator || 'Unknown'}')" title="Click to view document">${truncateText(source.document_name || 'Unknown', 25)}</span> | 
                                    ðŸ‘¤ ${truncateText(source.creator || 'Unknown', 15)}
                                    ${source.course_name ? ` | ðŸ“š ${truncateText(source.course_name, 20)}` : ''}
                                    ${source.institution ? ` | ðŸ›ï¸ ${truncateText(source.institution, 20)}` : ''}
                                </div>
                            </div>
                            <div class="goal-actions">
                                <button class="goal-move-btn" onclick="openMoveModal('${node.id}', 'goal', ${index})" title="Move this learning goal">â†”</button>
                                <button class="goal-delete-btn" onclick="deleteGoal('${node.id}', ${index})" title="Delete this learning goal">ðŸ—‘</button>
                            </div>
                        </div>
                    </div>
                `;
            });
        }
        
        // Add full children (recursively)
        if (hasChildren) {
            node.children.forEach(child => {
                nodeHtml += buildFullTreeNode(child, level + 1);
            });
        }
        
        nodeHtml += `</div>`;
    }
    
    nodeHtml += `</div>`;
    return nodeHtml;
}

function highlightText($element, term) {
    const text = $element.text();
    const regex = new RegExp(`(${escapeRegExp(term)})`, 'gi');
    const highlightedText = text.replace(regex, '<span class="search-highlight">$1</span>');
    $element.html(highlightedText);
}

function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function clearTreeSearch() {
    // Remove all search classes and highlights
    $('.search-match-cluster, .search-match-goal, .search-hidden').removeClass('search-match-cluster search-match-goal search-hidden');
    $('.search-highlight').contents().unwrap();
    
    // Show all nodes/clusters and goals
    $('.tree-node, .flattened-cluster, .goal-item').show();
    
    // Reset tree view to collapsed state
    if ($('#tree-content').is(':visible')) {
        $('.cluster-content').hide();
        $('.collapse-icon').removeClass('expanded');
        $('.cluster-header').removeClass('expanded');
    }
    
    // Reset flattened view to collapsed state
    if ($('#flattened-content').is(':visible')) {
        $('.flattened-cluster .cluster-content').hide();
        $('.flattened-cluster .collapse-icon').removeClass('expanded');
        $('.flattened-cluster .cluster-header').removeClass('expanded');
    }
    
    // Clear search results info
    $('#search-results-info').text('');
    
    // Reset search results
    searchResults = { clusterMatches: 0, goalMatches: 0, totalVisible: 0 };
}

function updateSearchResultsInfo(term) {
    const info = $('#search-results-info');
    const { clusterMatches, goalMatches, totalVisible } = searchResults;
    const totalMatches = clusterMatches + goalMatches;
    
    if (totalMatches === 0) {
        info.html(`<span class="text-muted">No matches found for "${term}"</span>`);
    } else {
        let infoText = `Found ${totalMatches} matches`;
        if (clusterMatches > 0 && goalMatches > 0) {
            infoText += ` (${clusterMatches} clusters, ${goalMatches} goals)`;
        } else if (clusterMatches > 0) {
            infoText += ` in cluster names`;
        } else {
            infoText += ` in learning goals`;
        }
        infoText += ` for "${term}"`;
        
        info.html(`<span class="text-success">${infoText}</span>`);
    }
}

// =====================================
// DENDROGRAM FUNCTIONALITY
// =====================================

// Global dendrogram variables
let dendrogramSvg = null;
let dendrogramData = null;
let dendrogramZoom = null;
let currentLayout = 'vertical';
let focusedNode = null;
let focusPath = [];
let visibleNodes = new Set();
let collapsedNodes = new Set();

function showDendrogram() {
    // Show the modal
    $('#dendrogramModal').modal('show');
    
    // Initialize dendrogram when modal is shown
    $('#dendrogramModal').on('shown.bs.modal', function() {
        initializeDendrogram();
    });
}

function initializeDendrogram() {
    // Show loading
    $('#dendrogram-loading').show();
    
    // Clear any existing SVG
    $('#dendrogram-svg-container').empty();
    
    // Convert tree structure to D3 hierarchy format
    dendrogramData = convertToD3Hierarchy(currentArtifact.tree_structure);
    
    // Create the dendrogram
    setTimeout(() => {
        createDendrogram();
        $('#dendrogram-loading').hide();
    }, 100);
}

function convertToD3Hierarchy(treeStructure) {
    // Convert our tree structure to D3 hierarchy format
    function convertNode(node) {
        const d3Node = {
            id: node.id,
            name: node.label,
            representativeText: node.representative_goal || '',
            size: node.size || 0,
            goals: node.goals || [],
            level: node.level || 0,
            text_state: node.text_state || 'default'
        };
        
        if (node.children && node.children.length > 0) {
            d3Node.children = node.children.map(child => convertNode(child));
        }
        
        return d3Node;
    }
    
    // Create a root node if we have multiple top-level nodes
    if (treeStructure.length === 1) {
        return convertNode(treeStructure[0]);
    } else {
        return {
            id: 'root',
            name: 'Root',
            representativeText: 'Learning Goals Hierarchy',
            size: treeStructure.reduce((sum, node) => sum + (node.size || 0), 0),
            goals: [],
            level: -1,
            children: treeStructure.map(node => convertNode(node))
        };
    }
}

function createDendrogram() {
    const container = document.getElementById('dendrogram-svg-container');
    const containerRect = container.getBoundingClientRect();
    const width = containerRect.width;
    const height = containerRect.height;
    
    // Clear previous SVG
    d3.select(container).selectAll('*').remove();
    
    // Create SVG
    const svg = d3.select(container)
        .append('svg')
        .attr('width', width)
        .attr('height', height);
    
    // Create zoom behavior
    dendrogramZoom = d3.zoom()
        .scaleExtent([0.1, 5])
        .on('zoom', (event) => {
            g.attr('transform', event.transform);
        });
    
    svg.call(dendrogramZoom);
    
    // Create main group for zooming and panning
    const g = svg.append('g')
        .attr('class', 'dendrogram-zoom-container');
    
    // Determine what data to show (focused subtree or full tree)
    let dataToShow = dendrogramData;
    if (focusedNode) {
        dataToShow = focusedNode.data;
    }
    
    // Create hierarchy
    const root = d3.hierarchy(dataToShow);
    
    // Progressive loading: limit depth for performance
    const maxVisibleDepth = calculateMaxVisibleDepth(root);
    const filteredRoot = filterTreeByDepth(root, maxVisibleDepth);
    
    // Create different layouts based on selection
    let treeLayout;
    let nodeTransform;
    let linkPath;
    
    if (currentLayout === 'radial') {
        treeLayout = d3.tree()
            .size([2 * Math.PI, Math.min(width, height) / 2 - 100])
            .separation((a, b) => (a.parent === b.parent ? 1 : 2) / a.depth);
        
        nodeTransform = d => `rotate(${(d.x * 180 / Math.PI - 90)}) translate(${d.y},0)`;
        
        linkPath = d3.linkRadial()
            .angle(d => d.x)
            .radius(d => d.y);
    } else if (currentLayout === 'vertical') {
        treeLayout = d3.tree()
            .size([width - 200, height - 200])
            .separation((a, b) => (a.parent === b.parent ? 1 : 2) / a.depth);
        
        nodeTransform = d => `translate(${d.x},${d.y})`;
        
        linkPath = d3.linkVertical()
            .x(d => d.x)
            .y(d => d.y);
    } else {
        // Horizontal layout (default)
        treeLayout = d3.tree()
            .size([height - 200, width - 200])
            .separation((a, b) => (a.parent === b.parent ? 1 : 2) / a.depth);
        
        nodeTransform = d => `translate(${d.y},${d.x})`;
        
        linkPath = d3.linkHorizontal()
            .x(d => d.y)
            .y(d => d.x);
    }
    
    // Apply layout
    treeLayout(filteredRoot);
    
    // Position the tree in the center
    if (currentLayout === 'radial') {
        g.attr('transform', `translate(${width / 2},${height / 2})`);
    } else {
        g.attr('transform', `translate(100,100)`);
    }
    
    // Add links with visibility filtering
    const visibleLinks = filteredRoot.links().filter(link => 
        !collapsedNodes.has(link.source.data.id) && 
        !collapsedNodes.has(link.target.data.id)
    );
    
    const links = g.selectAll('.dendrogram-link')
        .data(visibleLinks)
        .enter()
        .append('path')
        .attr('class', 'dendrogram-link')
        .attr('d', linkPath)
        .on('mouseover', function(event, d) {
            d3.select(this).style('stroke', '#007bff').style('stroke-width', '2.5px');
        })
        .on('mouseout', function(event, d) {
            d3.select(this).style('stroke', '#6c757d').style('stroke-width', '1.5px');
        });
    
    // Add nodes with click-to-focus functionality
    const visibleNodeData = filteredRoot.descendants().filter(d => 
        !collapsedNodes.has(d.data.id)
    );
    
    const nodes = g.selectAll('.dendrogram-node')
        .data(visibleNodeData)
        .enter()
        .append('g')
        .attr('class', d => {
            let classes = `dendrogram-node ${d.children ? '' : 'leaf'}`;
            if (focusedNode && d.data.id === focusedNode.data.id) {
                classes += ' focused';
            }
            if (collapsedNodes.has(d.data.id)) {
                classes += ' has-hidden-children';
            }
            return classes;
        })
        .attr('transform', nodeTransform)
        .on('click', function(event, d) {
            event.stopPropagation();
            handleNodeFocus(d);
        })
        .on('dblclick', function(event, d) {
            event.stopPropagation();
            toggleNodeCollapse(d);
        })
        .on('mouseover', function(event, d) {
            showDendrogramTooltip(event, d);
        })
        .on('mouseout', function() {
            hideDendrogramTooltip();
        });
    
    // Add circles to nodes with dynamic sizing
    nodes.append('circle')
        .attr('r', d => {
            const baseSize = d.children ? 5 : 4;
            const focusBonus = (focusedNode && d.data.id === focusedNode.data.id) ? 2 : 0;
            return baseSize + focusBonus;
        })
        .style('fill', d => {
            if (focusedNode && d.data.id === focusedNode.data.id) return '#fff5f5';
            return d.children ? '#fff' : '#28a745';
        })
        .style('stroke', d => {
            if (focusedNode && d.data.id === focusedNode.data.id) return '#dc3545';
            return d.children ? '#007bff' : '#1e7e34';
        })
        .style('stroke-width', d => {
            if (focusedNode && d.data.id === focusedNode.data.id) return 4;
            return 2;
        });
    
    // Add labels with smart positioning
    const labelType = document.getElementById('dendrogram-labels').value;
    
    if (labelType !== 'none') {
        addSmartDendrogramLabels(nodes, labelType, filteredRoot);
    }
    
    // Store reference for later use
    dendrogramSvg = svg;
    
    // Update breadcrumb
    updateBreadcrumb();
}

function addSmartDendrogramLabels(nodes, labelType, root) {
    // Calculate label priorities based on node importance
    const labelPriorities = calculateLabelPriorities(root);
    
    if (labelType === 'smart') {
        // Smart adaptive labeling
        nodes.each(function(d) {
            const priority = labelPriorities.get(d.data.id) || 'low';
            const nodeSelection = d3.select(this);
            
            // Only show labels for high and medium priority nodes to avoid clutter
            if (priority === 'high' || priority === 'medium') {
                const textToShow = d.data.representativeText || d.data.name;
                const maxLength = priority === 'high' ? 40 : 25;
                const isRepresentativeText = d.data.representativeText && textToShow === d.data.representativeText;
                
                const textElement = nodeSelection.append('text')
                    .attr('class', () => {
                        let classes = `dendrogram-text smart-positioned priority-${priority} depth-${Math.min(d.depth, 5)}`;
                        if (isRepresentativeText) {
                            const textState = d.data.text_state || 'default';
                            classes += ` representative-text state-${textState}`;
                        }
                        return classes;
                    })
                    .attr('x', d => d.children ? -6 : 10)
                    .attr('y', -5)
                    .attr('transform', d => `rotate(-19, ${d.children ? -6 : 10}, -5)`)
                    .style('text-anchor', 'start'); // Always start from the node
                
                // Add multi-line text
                addMultiLineText(textElement, textToShow, maxLength);
                
                // Hide text for nodes deeper than 5 levels from current focus root
                if (shouldHideTextForDepth(d)) {
                    textElement.classed('depth-hidden', true);
                }
            }
        });
    } else {
        // Traditional labeling modes
        if (labelType === 'cluster' || labelType === 'both') {
            const clusterTexts = nodes.append('text')
                .attr('class', d => `dendrogram-text cluster-label depth-${Math.min(d.depth, 5)}`)
                .attr('x', d => d.children ? -6 : 10)
                .attr('y', d => d.children ? -13 : -5)
                .attr('transform', d => {
                    const x = d.children ? -6 : 10;
                    const y = d.children ? -13 : -5;
                    return `rotate(-19, ${x}, ${y})`;
                })
                .style('text-anchor', 'start'); // Always start from the node
            
            // Add multi-line text to cluster labels
            clusterTexts.each(function(d) {
                addMultiLineText(d3.select(this), d.data.name, 20);
            });
            
            // Hide text for deep nodes
            clusterTexts.classed('depth-hidden', d => shouldHideTextForDepth(d));
        }
        
        if (labelType === 'representative' || labelType === 'both') {
            const repTexts = nodes.append('text')
                .attr('class', d => {
                    const textState = d.data.text_state || 'default';
                    return `dendrogram-text representative-text state-${textState} depth-${Math.min(d.depth, 5)}`;
                })
                .attr('x', d => d.children ? -6 : 10)
                .attr('y', d => {
                    if (labelType === 'both') {
                        return d.children ? 3 : 10;
                    } else {
                        return d.children ? -13 : -5;
                    }
                })
                .attr('transform', d => {
                    const x = d.children ? -6 : 10;
                    const y = labelType === 'both' 
                        ? (d.children ? 3 : 10)
                        : (d.children ? -13 : -5);
                    return `rotate(-19, ${x}, ${y})`;
                })
                .style('text-anchor', 'start'); // Always start from the node
            
            // Add multi-line text to representative labels
            repTexts.each(function(d) {
                addMultiLineText(d3.select(this), d.data.representativeText, 25);
            });
            
            // Hide text for deep nodes
            repTexts.classed('depth-hidden', d => shouldHideTextForDepth(d));
        }
    }
}

function calculateLabelPriorities(root) {
    const priorities = new Map();
    const totalNodes = root.descendants().length;
    
    root.descendants().forEach(d => {
        let priority = 'low';
        
        // High priority: root, focused node, nodes with many children, leaf nodes with interesting content
        if (d === root || 
            (focusedNode && d.data.id === focusedNode.data.id) ||
            (d.children && d.children.length > 5) ||
            (d.depth <= 2 && totalNodes > 50)) {
            priority = 'high';
        }
        // Medium priority: intermediate nodes with some children
        else if (d.children && d.children.length > 2) {
            priority = 'medium';
        }
        // Low priority: small leaf clusters, deep nodes
        else if (d.depth > 4 || (!d.children && d.data.size < 3)) {
            priority = 'low';
        }
        
        priorities.set(d.data.id, priority);
    });
    
    return priorities;
}

function shouldHideTextForDepth(d) {
    // Hide text for nodes deeper than 5 levels from the current view root
    // d.depth is relative to the current focused subtree root
    return d.depth > 5;
}

function addMultiLineText(textElement, fullText, maxCharsPerLine) {
    if (!fullText) return;
    
    // Split text into words
    const words = fullText.split(' ');
    let line1 = '';
    let line2 = '';
    let currentLine = 1;
    
    // Build lines word by word
    for (let i = 0; i < words.length; i++) {
        const word = words[i];
        const testLine = currentLine === 1 
            ? (line1 ? line1 + ' ' + word : word)
            : (line2 ? line2 + ' ' + word : word);
        
        if (testLine.length <= maxCharsPerLine) {
            // Word fits on current line
            if (currentLine === 1) {
                line1 = testLine;
            } else {
                line2 = testLine;
            }
        } else {
            // Word doesn't fit
            if (currentLine === 1 && line1) {
                // Move to second line
                currentLine = 2;
                line2 = word;
            } else {
                // Second line is full, truncate with ellipsis
                if (currentLine === 1) {
                    line1 = truncateText(line1, maxCharsPerLine - 3) + '...';
                } else {
                    line2 = truncateText(line2, maxCharsPerLine - 3) + '...';
                }
                break;
            }
        }
    }
    
    // Determine if we have two lines
    const hasTwoLines = line1 && line2;
    
    // Add the text lines as tspan elements
    if (line1) {
        textElement.append('tspan')
            .attr('x', textElement.attr('x'))
            .attr('dy', hasTwoLines ? '-0.55em' : 0) // Shift up by half line height if two lines
            .text(line1);
    }
    
    if (line2) {
        textElement.append('tspan')
            .attr('x', textElement.attr('x'))
            .attr('dy', '1.1em') // Move to next line
            .text(line2);
    }
}

function calculateMaxVisibleDepth(root) {
    const totalNodes = root.descendants().length;
    
    // Progressive loading based on tree size
    if (totalNodes > 1000) return 4;
    if (totalNodes > 500) return 5;
    if (totalNodes > 100) return 6;
    return 8; // Show full depth for smaller trees
}

function filterTreeByDepth(root, maxDepth) {
    // Clone the tree structure but limit depth
    function cloneWithDepthLimit(node, currentDepth) {
        const cloned = {
            data: node.data,
            depth: currentDepth,
            children: []
        };
        
        if (currentDepth < maxDepth && node.children) {
            cloned.children = node.children.map(child => 
                cloneWithDepthLimit(child, currentDepth + 1)
            );
        }
        
        return cloned;
    }
    
    return d3.hierarchy(cloneWithDepthLimit(root, 0).data);
}

function handleNodeFocus(d) {
    // Set focus to this node
    focusedNode = d;
    
    // Update focus path for breadcrumb
    updateFocusPath(d);
    
    // Recreate the dendrogram focused on this subtree
    createDendrogram();
    
    // Reset zoom to fit the new focused tree
    setTimeout(() => {
        if (dendrogramSvg && dendrogramZoom) {
            dendrogramSvg.transition().duration(500).call(
                dendrogramZoom.transform,
                d3.zoomIdentity.scale(1)
            );
        }
    }, 100);
}

function updateFocusPath(focusNode) {
    // Build the COMPLETE path from original root to focused node
    focusPath = [];
    
    // We need to find the complete path in the original tree structure
    const completePath = findCompletePathToNode(dendrogramData, focusNode.data.id);
    
    if (completePath) {
        focusPath = completePath.map((nodeData, index) => ({
            id: nodeData.id,
            name: nodeData.name || nodeData.label || `Node ${nodeData.id}`,
            nodeData: nodeData,
            isRoot: index === 0
        }));
    } else {
        // Fallback: just add the current focused node
        focusPath = [{
            id: focusNode.data.id,
            name: focusNode.data.name,
            nodeData: focusNode.data,
            isRoot: false
        }];
    }
    
    // Always ensure we start with root
    if (focusPath.length === 0 || focusPath[0].id !== dendrogramData.id) {
        focusPath.unshift({
            id: dendrogramData.id,
            name: 'Root',
            nodeData: dendrogramData,
            isRoot: true
        });
    }
}

function findCompletePathToNode(rootData, targetNodeId, currentPath = []) {
    // Add current node to path
    const newPath = [...currentPath, rootData];
    
    // If this is our target, return the complete path
    if (rootData.id === targetNodeId) {
        return newPath;
    }
    
    // Search in children
    if (rootData.children) {
        for (const child of rootData.children) {
            const result = findCompletePathToNode(child, targetNodeId, newPath);
            if (result) {
                return result;
            }
        }
    }
    
    // Not found in this branch
    return null;
}

function updateBreadcrumb() {
    const breadcrumbContainer = document.getElementById('breadcrumb-path');
    const breadcrumbSection = document.getElementById('dendrogram-breadcrumb');
    
    if (focusPath.length <= 1) {
        breadcrumbSection.style.display = 'none';
        return;
    }
    
    breadcrumbSection.style.display = 'block';
    breadcrumbContainer.innerHTML = '';
    
    focusPath.forEach((item, index) => {
        if (index > 0) {
            const separator = document.createElement('span');
            separator.className = 'breadcrumb-separator';
            separator.textContent = '>';
            breadcrumbContainer.appendChild(separator);
        }
        
        const breadcrumbItem = document.createElement('span');
        breadcrumbItem.className = 'breadcrumb-item';
        breadcrumbItem.textContent = truncateText(item.name, 15);
        breadcrumbItem.title = item.name;
        
        if (index < focusPath.length - 1) {
            breadcrumbItem.addEventListener('click', () => {
                if (item.isRoot) {
                    // Return to root
                    focusedNode = null;
                    focusPath = [];
                    createDendrogram();
                } else {
                    // Focus on this specific node by recreating its hierarchy node
                    focusToNodeById(item.id);
                }
            });
        } else {
            // Current focused item - highlight it
            breadcrumbItem.style.backgroundColor = '#007bff';
            breadcrumbItem.style.color = 'white';
        }
        
        breadcrumbContainer.appendChild(breadcrumbItem);
    });
}

function focusToNodeById(nodeId) {
    // Find the node in the original tree and focus on it
    const nodeData = findNodeInTree(dendrogramData, nodeId);
    if (nodeData) {
        // Create a D3 hierarchy node for this data
        const hierarchyNode = d3.hierarchy(nodeData);
        handleNodeFocus(hierarchyNode);
    }
}

function findNodeInTree(rootData, targetId) {
    if (rootData.id === targetId) {
        return rootData;
    }
    
    if (rootData.children) {
        for (const child of rootData.children) {
            const result = findNodeInTree(child, targetId);
            if (result) {
                return result;
            }
        }
    }
    
    return null;
}

function toggleNodeCollapse(d) {
    const nodeId = d.data.id;
    
    if (collapsedNodes.has(nodeId)) {
        collapsedNodes.delete(nodeId);
    } else {
        collapsedNodes.add(nodeId);
    }
    
    // Recreate dendrogram with updated collapsed state
    createDendrogram();
}

function returnToRoot() {
    focusedNode = null;
    focusPath = [];
    collapsedNodes.clear();
    createDendrogram();
}

function showDendrogramTooltip(event, d) {
    const tooltip = document.getElementById('dendrogram-tooltip');
    const content = document.getElementById('tooltip-content');
    
    let tooltipHtml = `
        <div><strong>${d.data.name}</strong></div>
        <div>Size: ${d.data.size} goals</div>
    `;
    
    if (d.data.representativeText) {
        tooltipHtml += `<div>Representative: ${d.data.representativeText}</div>`;
    }
    
    if (d.data.goals && d.data.goals.length > 0) {
        tooltipHtml += `<div>Direct goals: ${d.data.goals.length}</div>`;
        if (d.data.goals.length <= 3) {
            tooltipHtml += '<div><strong>Goals:</strong></div>';
            d.data.goals.forEach(goal => {
                tooltipHtml += `<div>â€¢ ${truncateText(goal, 60)}</div>`;
            });
        }
    }
    
    // Add interaction hints
    if (d.children) {
        tooltipHtml += '<hr><div><small><strong>Click:</strong> Focus on this subtree</small></div>';
        tooltipHtml += '<div><small><strong>Double-click:</strong> Collapse/expand</small></div>';
    } else {
        tooltipHtml += '<hr><div><small><strong>Click:</strong> Focus on this leaf</small></div>';
    }
    
    content.innerHTML = tooltipHtml;
    
    // Position tooltip
    const rect = document.getElementById('dendrogram-container').getBoundingClientRect();
    tooltip.style.left = (event.clientX - rect.left + 10) + 'px';
    tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
    tooltip.style.display = 'block';
}

function hideDendrogramTooltip() {
    document.getElementById('dendrogram-tooltip').style.display = 'none';
}

// Event handlers for dendrogram controls
$(document).ready(function() {

    
    // Layout change
    $('#dendrogram-layout').on('change', function() {
        currentLayout = $(this).val();
        if (dendrogramData) {
            createDendrogram();
        }
    });
    
    // Labels change
    $('#dendrogram-labels').on('change', function() {
        if (dendrogramData) {
            createDendrogram();
        }
    });
    
    // Focus home
    $('#dendrogram-focus-home').on('click', function() {
        returnToRoot();
    });
    
    // Reset view
    $('#dendrogram-reset').on('click', function() {
        if (dendrogramSvg && dendrogramZoom) {
            dendrogramSvg.transition().duration(500).call(
                dendrogramZoom.transform,
                d3.zoomIdentity
            );
        }
    });
    
    // Export SVG
    $('#dendrogram-export').on('click', function() {
        exportDendrogramSVG();
    });
});

function exportDendrogramSVG() {
    if (!dendrogramSvg) {
        alert('No dendrogram to export');
        return;
    }
    
    // Clone the SVG
    const svgElement = dendrogramSvg.node();
    const svgClone = svgElement.cloneNode(true);
    
    // Add some basic styling to the exported SVG
    const style = document.createElement('style');
    style.textContent = `
        .dendrogram-link { fill: none; stroke: #6c757d; stroke-width: 1.5px; }
        .dendrogram-node circle { fill: #fff; stroke: #007bff; stroke-width: 2px; }
        .dendrogram-node.leaf circle { fill: #28a745; stroke: #1e7e34; }
        .dendrogram-text { font-family: Arial, sans-serif; font-size: 11px; fill: #495057; }
        .dendrogram-text.cluster-label { font-weight: 600; fill: #007bff; }
        .dendrogram-text.representative-text { font-size: 10px; fill: #6c757d; font-style: italic; }
    `;
    svgClone.insertBefore(style, svgClone.firstChild);
    
    // Convert to blob and download
    const svgData = new XMLSerializer().serializeToString(svgClone);
    const blob = new Blob([svgData], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = `dendrogram-${currentArtifact.name || 'tree'}.svg`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    URL.revokeObjectURL(url);
}

// Document Modal Functions
function openDocumentModal(documentName, creator) {
    // Remove quotes and clean up the document name and creator
    const cleanDocumentName = documentName.replace(/['"]/g, '');
    const cleanCreator = creator.replace(/['"]/g, '');
    
    console.log('Opening modal for document:', cleanDocumentName, 'by', cleanCreator);
    
    // Show loading state
    $('#documentModalLabel').text('Loading Document...');
    $('#documentModalBody').html(`
        <div class="text-center p-4">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <p class="mt-2">Loading document details...</p>
        </div>
    `);
    
    // Show the modal
    $('#documentModal').modal('show');
    
    // Make API call to find the document
    $.ajax({
        url: '/api/find-document-by-name',
        method: 'GET',
        data: {
            name: cleanDocumentName,
            creator: cleanCreator
        },
        success: function(document) {
            displayDocumentInModal(document);
        },
        error: function(xhr) {
            let errorMessage = 'Unable to load document';
            if (xhr.responseJSON && xhr.responseJSON.error) {
                errorMessage = xhr.responseJSON.error;
            }
            $('#documentModalBody').html(`
                <div class="alert alert-danger">
                    <i class="bi bi-exclamation-triangle"></i> ${errorMessage}
                </div>
            `);
        }
    });
}

function displayDocumentInModal(document) {
    $('#documentModalLabel').text(`Document: ${document.name}`);
    
    // Build the modal content similar to the view page
    let modalContent = `
        <div class="document-metadata mb-4">
            <div class="row mb-2">
                <div class="col-md-4">
                    <strong>Original Filename:</strong>
                    <p class="mb-1">${document.original_filename || 'N/A'}</p>
                </div>
                <div class="col-md-4">
                    <strong>Creator:</strong>
                    <p class="mb-1">${document.creator || 'N/A'}</p>
                </div>
                <div class="col-md-4">
                    <strong>Course:</strong>
                    <p class="mb-1">${document.course_name || 'N/A'}</p>
                </div>
            </div>
            <div class="row mb-2">
                <div class="col-md-4">
                    <strong>Institution:</strong>
                    <p class="mb-1">${document.institution || 'N/A'}</p>
                </div>
                <div class="col-md-4">
                    <strong>Document Type:</strong>
                    <p class="mb-1">${document.doc_type || 'N/A'}</p>
                </div>
                <div class="col-md-4">
                    <strong>Upload Date:</strong>
                    <p class="mb-1">${document.created_at || 'N/A'}</p>
                </div>
            </div>`;
    
    if (document.notes) {
        modalContent += `
            <div class="row">
                <div class="col-md-12">
                    <strong>Notes:</strong>
                    <div class="notes-box bg-light p-3 border-start border-secondary border-4 rounded">
                        <p class="mb-0">${document.notes}</p>
                    </div>
                </div>
            </div>`;
    }
    
    modalContent += `</div>`;
    
    // Add learning goals section
    modalContent += `
        <h5 class="mb-3">Learning Goals:</h5>
        <div class="learning-goals-container mb-4">`;
    
    if (document.learning_goals && document.learning_goals.length > 0) {
        modalContent += `
            <div class="learning-goals-list" style="max-height: 200px; overflow-y: auto;">
                <ul class="list-group list-group-flush">`;
        
        document.learning_goals.forEach(goal => {
            modalContent += `<li class="list-group-item">${goal}</li>`;
        });
        
        modalContent += `
                </ul>
            </div>`;
    } else {
        modalContent += `<p class="text-muted">No learning goals available for this document.</p>`;
    }
    
    modalContent += `</div>`;
    
    // Add document preview section
    modalContent += `
        <h5 class="mb-3">Document Preview:</h5>
        <div class="pdf-container">
            <div id="modal-pdf-loading" class="text-center p-4">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading document...</span>
                </div>
                <p class="mt-2">Loading document preview...</p>
            </div>
            <iframe id="modal-pdf-iframe" style="width: 100%; height: 400px; border: 1px solid #ddd; border-radius: 4px; display: none;"></iframe>
            <div id="modal-pdf-error" class="alert alert-danger" style="display: none;">
                <i class="bi bi-exclamation-triangle"></i> 
                <span id="modal-error-message">Unable to load document preview.</span>
            </div>
        </div>`;
    
    $('#documentModalBody').html(modalContent);
    
    // Load the document preview
    loadDocumentPreviewInModal(document.id);
}

function loadDocumentPreviewInModal(documentId) {
    $.ajax({
        url: `/document-url/${documentId}`,
        method: 'GET',
        success: function(response) {
            if (response.url) {
                // Hide loading spinner
                $('#modal-pdf-loading').hide();
                
                // Set iframe source and show it
                $('#modal-pdf-iframe').attr('src', response.url).show();
                
                // Show correction message if path was corrected
                if (response.corrected) {
                    console.log('Document storage path was automatically corrected');
                }
            } else {
                showModalPdfError('Invalid response from server');
            }
        },
        error: function(xhr) {
            let errorMessage = 'Unable to load document preview';
            if (xhr.responseJSON && xhr.responseJSON.error) {
                errorMessage = xhr.responseJSON.error;
            }
            showModalPdfError(errorMessage);
        }
    });
}

function showModalPdfError(message) {
    $('#modal-pdf-loading').hide();
    $('#modal-pdf-iframe').hide();
    $('#modal-error-message').text(message);
    $('#modal-pdf-error').show();
}

</script>

<!-- Document Modal -->
<div class="modal fade" id="documentModal" tabindex="-1" aria-labelledby="documentModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="documentModalLabel">Document</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body" id="documentModalBody">
                <!-- Content will be dynamically loaded here -->
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

{% endblock %}