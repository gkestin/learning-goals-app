{% extends "base.html" %}

{% block title %}Learning Goals Clustering - Learning Goals Extractor{% endblock %}

{% block extra_css %}
<style>
    .clustering-controls {
        background-color: #f8f9fa;
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 30px;
    }
    .cluster-section {
        margin-bottom: 25px;
        border-bottom: 1px solid #e0e0e0;
        padding-bottom: 15px;
    }
    .cluster-section:last-child {
        border-bottom: none;
    }
    .cluster-title {
        font-size: 1.1rem;
        font-weight: 600;
        color: #0066cc;
        margin-bottom: 8px;
    }
    .cluster-representative {
        font-size: 0.9em;
        color: #666;
        font-style: italic;
        margin-bottom: 10px;
    }
    .goal-item {
        padding: 6px 10px;
        margin: 3px 0;
        background-color: #f8f9fa;
        border-left: 3px solid #007bff;
        border-radius: 3px;
    }
    .goal-text {
        font-size: 0.9em;
        line-height: 1.3;
        margin-bottom: 2px;
    }
    .goal-source {
        font-size: 0.75em;
        color: #6c757d;
        font-style: italic;
        line-height: 1.2;
    }
    .clustering-stats {
        background-color: #e9f5ff;
        border: 1px solid #c8e1ff;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
    }
    .loading-spinner {
        text-align: center;
        padding: 40px 0;
    }

    .stem-badge {
        background: linear-gradient(45deg, #28a745, #20c997);
        color: white;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 0.7em;
        font-weight: bold;
    }
    
    .btn-group .btn-check:checked + .btn {
        background-color: var(--bs-btn-active-bg);
        border-color: var(--bs-btn-active-border-color);
        color: var(--bs-btn-active-color);
    }
    
    .clustering-controls {
        transition: all 0.3s ease;
    }

    /* Progress Tracker Styles */
    .step-indicator {
        padding: 15px;
        border-radius: 8px;
        background-color: #f8f9fa;
        transition: all 0.3s ease;
    }
    
    .step-indicator.active {
        background-color: #e3f2fd;
        color: #1976d2;
    }
    
    .step-indicator.completed {
        background-color: #e8f5e9;
        color: #2e7d32;
    }
    
    .step-indicator.error {
        background-color: #ffebee;
        color: #c62828;
    }
    
    #progress-tracker {
        margin-bottom: 20px;
    }
    
    /* Pulse animation for Accept Best button */
    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
    }
    
    .pulse {
        animation: pulse 2s infinite;
    }
</style>
<!-- Chart.js CDN -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
{% endblock %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-12">
        <div class="card">
            <div class="card-header bg-primary text-white">
                <h2 class="card-title h4 mb-0">
                    <i class="bi bi-diagram-3"></i> STEM Learning Goals Clustering Sandbox
                    <span class="stem-badge">STEM-Optimized</span>
                </h2>
                <small>Discover patterns and group similar learning objectives using AI semantic analysis</small>
            </div>
            <div class="card-body">
                
                <!-- Learning Goals Overview -->
                <div id="goals-overview" class="alert alert-info mb-4">
                    <h5>‚ÑπÔ∏è Learning Goals Overview</h5>
                    <div id="overview-loading">
                        <div class="spinner-border spinner-border-sm" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <span class="ms-2">Loading learning goals from database...</span>
                    </div>
                    <div id="overview-content" style="display: none;">
                        <!-- Overview content will be populated here -->
                    </div>
                </div>
                
                <!-- Course Filter -->
                <div class="mb-4">
                    <div class="card border-secondary">
                        <div class="card-header bg-light">
                            <h6 class="mb-0"><i class="bi bi-funnel"></i> Course Filter</h6>
                        </div>
                        <div class="card-body">
                            <div class="row align-items-center">
                                <div class="col-md-6">
                                    <label for="course-selector" class="form-label"><strong>Select Course:</strong></label>
                                    <select id="course-selector" class="form-select">
                                        <option value="">All Courses (Default)</option>
                                        <!-- Course options will be populated dynamically -->
                                    </select>
                                    <div class="form-text">
                                        Choose a specific course to cluster only its learning goals, or select "All Courses" to cluster learning goals from all courses together.
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div id="course-stats" class="text-muted">
                                        <small><strong>Selected:</strong> <span id="selected-course-info">All courses</span></small><br>
                                        <small><strong>Learning Goals:</strong> <span id="selected-goals-count">Loading...</span></small><br>
                                        <small><strong>Documents:</strong> <span id="selected-docs-count">Loading...</span></small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Approach Toggle -->
                <div class="mb-3">
                    <div class="btn-group" role="group" aria-label="Clustering approach toggle">
                        <input type="radio" class="btn-check" name="approach-toggle" id="optimize-toggle" autocomplete="off">
                        <label class="btn btn-outline-info" for="optimize-toggle">üéØ Auto-Optimize</label>
                        
                        <input type="radio" class="btn-check" name="approach-toggle" id="manual-toggle" autocomplete="off" checked>
                        <label class="btn btn-outline-primary" for="manual-toggle">üéÆ Manual Config</label>
                    </div>
                    <small class="text-muted ms-3">Choose your clustering approach</small>
                </div>

                <!-- Approach 1: Automatic Optimization -->
                <div id="optimize-approach" class="clustering-controls border border-2 border-info" style="display: none;">
                    <h4 class="text-info mb-3">üéØ Automatic Optimization</h4>
                    <p class="text-muted mb-3">Let the AI find the optimal cluster size using data-driven analysis methods.</p>
                    <div class="row">
                        <div class="col-md-8">
                            <div class="mb-3">
                                <p><strong>How it works:</strong></p>
                                <ul class="mb-0">
                                    <li><strong>Smart Optimization:</strong> Multi-resolution search for large datasets, exhaustive for smaller ones</li>
                                    <li><strong>True Optimization:</strong> Tests multiple sizes to maximize our actual quality metrics</li>
                                    <li><strong>Composite Score:</strong> Weighted combination of separation + cohesion + silhouette</li>
                                    <li><strong>Multiple Options:</strong> Best overall, best separation, best cohesion, best silhouette</li>
                                    <li><strong>Data-Driven:</strong> Finds cluster sizes that actually optimize your specific learning goals</li>
                                    <li><strong>STEM-Optimized:</strong> Quality thresholds adjusted for domain-specific content similarity</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="col-md-4">
                            <div class="d-grid gap-2">
                                <button id="find-optimal-btn" class="btn btn-info btn-lg" disabled>
                                    üéØ Find Optimal Size & Cluster
                                </button>
                                <small class="text-muted">
                                    Recommended for first-time analysis or when unsure about cluster size
                                </small>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Approach 2: Manual Configuration -->
                <div id="manual-approach" class="clustering-controls border border-2 border-primary">
                    <h4 class="text-primary mb-3">üéÆ Manual Configuration</h4>
                    <p class="text-muted mb-3">Specify exact number of clusters for precise control over granularity.</p>
                    <div class="row">
                        <div class="col-md-6">
                            <div class="mb-3">
                                <label for="n-clusters-input" class="form-label"><strong>Number of Clusters:</strong></label>
                                <div class="input-group" style="max-width: 250px;">
                                    <input type="number" class="form-control form-control-lg text-center" id="n-clusters-input" min="2" max="1000" value="50">
                                    <span class="input-group-text">clusters</span>
                                </div>
                                <div class="form-text">
                                    More clusters = smaller, more specific groups<br>
                                    Fewer clusters = broader, more general themes<br>
                                    <strong>Suggested starting point:</strong> ~20% of total goals
                                </div>
                            </div>
                        </div>
                        
                        <div class="col-md-6">
                            <div class="d-grid gap-2">
                                <button id="cluster-btn" class="btn btn-primary btn-lg" disabled>
                                    üß† Analyze with Manual Size
                                </button>
                                <small class="text-muted">
                                    Good for fine-tuning or when you have specific clustering requirements
                                </small>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Loading Spinner -->
                <div id="loading-spinner" class="loading-spinner" style="display: none;">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mt-2">Analyzing learning goals with AI...</p>
                    <small class="text-muted">Generating semantic embeddings and clustering...</small>
                </div>

                <!-- Progress Tracker -->
                <div id="progress-tracker" style="display: none;">
                    <div class="card border-primary">
                        <div class="card-header bg-primary text-white">
                            <h5 class="mb-0"><i class="bi bi-gear-fill"></i> Processing Progress</h5>
                        </div>
                        <div class="card-body">
                            <div id="progress-message" class="mb-3">
                                <strong>Current Step:</strong> <span id="current-step">Initializing...</span>
                            </div>
                            
                            <!-- Step Progress Indicators -->
                            <div class="row mb-3">
                                <div class="col-md-3">
                                    <div class="text-center">
                                        <div id="step-loading" class="step-indicator">
                                            <i class="bi bi-database-fill fs-3"></i>
                                            <div>Loading Data</div>
                                            <small class="text-muted">‚Äî</small>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-3">
                                    <div class="text-center">
                                        <div id="step-embeddings" class="step-indicator">
                                            <i class="bi bi-cpu-fill fs-3"></i>
                                            <div>Embeddings</div>
                                            <small class="text-muted" id="embeddings-status-text">‚Äî</small>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-3">
                                    <div class="text-center">
                                        <div id="step-clustering" class="step-indicator">
                                            <i class="bi bi-diagram-3-fill fs-3"></i>
                                            <div>Clustering</div>
                                            <small class="text-muted">‚Äî</small>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-3">
                                    <div class="text-center">
                                        <div id="step-metrics" class="step-indicator">
                                            <i class="bi bi-graph-up fs-3"></i>
                                            <div>Quality Metrics</div>
                                            <small class="text-muted">‚Äî</small>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Overall Progress Bar -->
                            <div class="progress" style="height: 25px;">
                                <div id="overall-progress" class="progress-bar progress-bar-striped progress-bar-animated" 
                                     role="progressbar" style="width: 0%">
                                    <span id="progress-text">Starting...</span>
                                </div>
                            </div>
                            
                            <!-- Detailed Progress Info -->
                            <div id="progress-details" class="mt-3 text-muted">
                                <small id="progress-detail-text"></small>
                                <div id="optimization-progress" style="display: none;" class="mt-2">
                                    <div class="alert alert-warning mb-2">
                                        <i class="bi bi-clock"></i> <strong>Note:</strong> Each test may take several minutes with large datasets. Start with a few points, then add more resolution as needed.
                                    </div>
                                    
                                    <!-- Real-time Results Plot -->
                                    <div class="card mb-3">
                                        <div class="card-header bg-light">
                                            <h6 class="mb-0"><i class="bi bi-graph-up"></i> Interactive Elbow Curve</h6>
                                        </div>
                                        <div class="card-body p-2">
                                            <div style="position: relative; height: 300px; width: 100%;">
                                                <canvas id="optimization-chart"></canvas>
                                            </div>
                                            <small class="text-muted d-block mt-1">
                                                <i class="bi bi-info-circle"></i> Blue dots show composite quality, teal dots show silhouette scores (higher = better). Red line shows inertia (lower = better). Gray dashed line at 0.2 indicates "fair" silhouette threshold. Look for the "elbow" where improvement plateaus.
                                            </small>
                                        </div>
                                    </div>
                                    
                                    <div class="row">
                                        <div class="col-md-6">
                                            <small><strong>Tests Completed:</strong> <span id="tests-completed">0</span></small><br>
                                            <small><strong>Search Phase:</strong> <span id="search-phase">Initial sampling</span></small>
                                        </div>
                                        <div class="col-md-6 text-end">
                                            <button id="add-more-points-btn" class="btn btn-info btn-sm me-2" onclick="addMorePoints()" disabled>
                                                <i class="bi bi-plus-circle"></i> Add More Points
                                            </button>
                                            <button id="use-selected-btn" class="btn btn-primary btn-sm" onclick="useSelectedPoint()" disabled>
                                                <i class="bi bi-check-circle"></i> Use Selected Point
                                            </button>
                                            <button id="cancel-optimization-btn" class="btn btn-outline-secondary btn-sm ms-2" onclick="cancelOptimization()" style="display: none;">
                                                <i class="bi bi-x-circle"></i> Cancel
                                            </button>
                                            <br><small id="selection-status" class="text-muted">Initial sampling in progress...</small>
                                        </div>
                                    </div>
                                    
                                    <div class="mt-2">
                                        <div id="latest-test-result" class="text-info mb-1"></div>
                                        <div id="best-so-far" class="text-success"></div>
                                    </div>
                                </div>
                                <div id="clustering-time-warning" style="display: none;" class="mt-2">
                                    <div class="alert alert-info">
                                        <i class="bi bi-hourglass-split"></i> <strong>Please wait:</strong> Clustering may take several minutes depending on the number of learning goals.
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Clustering Results -->
                <div id="results-section" style="display: none;">
                    <!-- Stats Section -->
                    <div id="clustering-stats" class="clustering-stats">
                        <!-- Stats will be populated here -->
                    </div>
                    
                    <!-- Clusters Container -->
                    <div id="clusters-container">
                        <!-- Clusters will be populated here -->
                    </div>
                </div>

                <!-- No Results -->
                <div id="no-goals" class="text-center" style="display: none;">
                    <i class="bi bi-emoji-frown" style="font-size: 3rem; color: #6c757d;"></i>
                    <h3 class="mt-3">No Learning Goals Found</h3>
                    <p class="text-muted">Please <a href="{{ url_for('main.index') }}">upload some documents</a> first to analyze learning goals.</p>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
// Global variables to track active processes
let activeEventSource = null;
let activeFetch = null;
let embeddingsSessionId = null; // Store session ID for embeddings download
let optimizationChart = null; // Chart.js instance
let optimizationData = []; // Store optimization results
let selectedPoint = null; // Track selected point for clustering
let bestResult = null; // Track best result found so far (for reference)
let availableCourses = []; // Store available courses
let selectedCourse = null; // Track currently selected course

// Global functions for modal button clicks
function applyOptimalClusters(optimalK) {
    // Close modal first
    $('#optimizationModal').modal('hide');
    
    // Set the optimal cluster size (for display purposes)
    $('#n-clusters-input').val(optimalK);
    
    // Auto-trigger clustering with the optimal size
    window.performClustering(optimalK);
}

// Download embeddings as CSV
function downloadEmbeddings() {
    if (!embeddingsSessionId) {
        alert('No embeddings data available for download');
        return;
    }
    
    // Create a temporary link to download the CSV
    const downloadUrl = `/api/download-embeddings/${embeddingsSessionId}`;
    const link = document.createElement('a');
    link.href = downloadUrl;
    link.download = 'learning_goals_embeddings.csv';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

// Clean up function to stop any running processes
function cleanupActiveProcesses() {
    if (activeEventSource) {
        activeEventSource.close();
        activeEventSource = null;
    }
    if (activeFetch && activeFetch.abort) {
        activeFetch.abort();
        activeFetch = null;
    }
}

// Clean up on page unload
$(window).on('beforeunload', function() {
    cleanupActiveProcesses();
});

$(document).ready(function() {
    // Load overview on page load
    loadGoalsOverview();
    
    // Load available courses
    loadAvailableCourses();
    
    // Course selector change handler
    $('#course-selector').change(function() {
        const selectedCourseValue = $(this).val();
        selectedCourse = selectedCourseValue || null;
        updateCourseStats();
        updateGoalsOverviewForCourse();
    });
    
    // Input validation for number field (on blur to avoid interfering with typing)
    $('#n-clusters-input').on('blur', function() {
        var value = parseInt($(this).val());
        var maxValue = parseInt($(this).attr('max')) || 1000;
        if (isNaN(value) || value < 2) $(this).val(2);
        if (value > maxValue) $(this).val(maxValue);
    });
    
    // Find optimal button
    $('#find-optimal-btn').click(function() {
        findOptimalClusters();
    });
    
    // Clustering button
    $('#cluster-btn').click(function() {
        performClustering();
    });
    
    // Approach toggle functionality
    $('input[name="approach-toggle"]').change(function() {
        if ($('#optimize-toggle').is(':checked')) {
            $('#optimize-approach').show();
            $('#manual-approach').hide();
        } else {
            $('#optimize-approach').hide();
            $('#manual-approach').show();
        }
    });
    
    function loadGoalsOverview() {
        $.ajax({
            url: '{{ url_for("main.api_goals_overview") }}',
            type: 'GET',
            success: function(response) {
                if (response.success) {
                    const overviewHtml = `
                        <div class="row">
                            <div class="col-md-3">
                                <strong>Total Learning Goals:</strong> <span class="badge bg-primary">${response.total_goals}</span>
                            </div>
                            <div class="col-md-3">
                                <strong>From Documents:</strong> <span class="badge bg-secondary">${response.total_documents}</span>
                            </div>
                            <div class="col-md-3">
                                <strong>Unique Goals:</strong> <span class="badge bg-info">${response.unique_goals}</span>
                            </div>
                            <div class="col-md-3">
                                <strong>Avg Goals/Doc:</strong> <span class="badge bg-success">${response.avg_goals_per_doc}</span>
                            </div>
                        </div>
                        <div class="mt-2">
                            <small class="text-muted">
                                üí° Ready to cluster! Choose your parameters below and click "Analyze Learning Goals".
                            </small>
                        </div>
                    `;
                    $('#overview-content').html(overviewHtml);
                    $('#overview-loading').hide();
                    $('#overview-content').show();
                    
                    // Enable clustering if we have enough goals
                    if (response.total_goals >= 2) {
                        $('#cluster-btn').prop('disabled', false);
                        // Enable optimization if we have enough goals
                        if (response.total_goals >= 4) {
                            $('#find-optimal-btn').prop('disabled', false);
                        }
                        // Set max clusters to total number of goals (each goal could be its own cluster)
                        const maxClusters = response.total_goals;
                        $('#n-clusters-input').attr('max', maxClusters);
                        
                        // Set a reasonable default: ~20% of total goals for fine-grained clustering
                        const suggestedClusters = Math.max(2, Math.min(Math.floor(response.total_goals * 0.2), 100));
                        $('#n-clusters-input').val(suggestedClusters);
                        
                        // Update the help text with specific recommendation
                        $('.form-text').html(`
                            More clusters = smaller, more specific groups<br>
                            Fewer clusters = broader, more general themes<br>
                            <strong>Suggested starting point for ${response.total_goals} goals:</strong> ${suggestedClusters} clusters 
                            (Range: 2-${maxClusters})
                        `);
                    } else {
                        $('#goals-overview').removeClass('alert-info').addClass('alert-warning');
                        $('#overview-content').html(`
                            <p class="mb-0">
                                ‚ö†Ô∏è Not enough learning goals for clustering (found ${response.total_goals}, need at least 2).
                                Please <a href="{{ url_for('main.index') }}">upload more documents</a> first.
                            </p>
                        `);
                        $('#overview-loading').hide();
                        $('#overview-content').show();
                    }
                } else {
                    $('#overview-content').html(`
                        <p class="mb-0 text-danger">
                            ‚ùå Error loading learning goals: ${response.message}
                        </p>
                    `);
                    $('#overview-loading').hide();
                    $('#overview-content').show();
                    $('#goals-overview').removeClass('alert-info').addClass('alert-danger');
                }
            },
            error: function(xhr, status, error) {
                console.error('Failed to load overview:', error);
                $('#overview-content').html(`
                    <p class="mb-0 text-danger">
                        ‚ùå Failed to load learning goals overview. Please refresh the page.
                    </p>
                `);
                $('#overview-loading').hide();
                $('#overview-content').show();
                $('#goals-overview').removeClass('alert-info').addClass('alert-danger');
            }
        });
    }
    
    function loadAvailableCourses() {
        $.ajax({
            url: '{{ url_for("main.api_available_courses") }}',
            type: 'GET',
            success: function(response) {
                if (response.success) {
                    availableCourses = response.courses;
                    
                    // Populate course selector
                    const courseSelector = $('#course-selector');
                    courseSelector.empty();
                    courseSelector.append('<option value="">All Courses (Default)</option>');
                    
                    response.courses.forEach(function(course) {
                        courseSelector.append(
                            `<option value="${course.name}">${course.name} (${course.total_goals} goals, ${course.documents} docs)</option>`
                        );
                    });
                    
                    // Update initial course stats
                    updateCourseStats();
                    
                } else {
                    console.error('Failed to load courses:', response.message);
                }
            },
            error: function(xhr, status, error) {
                console.error('Failed to load courses:', error);
            }
        });
    }
    
    function updateCourseStats() {
        if (!selectedCourse) {
            // All courses selected
            $('#selected-course-info').text('All courses');
            $('#selected-goals-count').text('Loading...');
            $('#selected-docs-count').text('Loading...');
            
            // Load total stats (this could be cached from overview)
            loadGoalsOverview();
        } else {
            // Specific course selected
            const courseData = availableCourses.find(c => c.name === selectedCourse);
            if (courseData) {
                $('#selected-course-info').text(`"${courseData.name}"`);
                $('#selected-goals-count').text(courseData.total_goals);
                $('#selected-docs-count').text(courseData.documents);
            }
        }
    }
    
    function updateGoalsOverviewForCourse() {
        // Update the main overview to reflect the selected course
        if (!selectedCourse) {
            // Reload full overview
            loadGoalsOverview();
        } else {
            // Show course-specific overview
            const courseData = availableCourses.find(c => c.name === selectedCourse);
            if (courseData) {
                const overviewHtml = `
                    <div class="row">
                        <div class="col-md-3">
                            <strong>Course Goals:</strong> <span class="badge bg-primary">${courseData.total_goals}</span>
                                    </div>
                        <div class="col-md-3">
                            <strong>Course Documents:</strong> <span class="badge bg-secondary">${courseData.documents}</span>
                                                 </div>
                        <div class="col-md-3">
                            <strong>Course:</strong> <span class="badge bg-info">"${courseData.name}"</span>
                                                 </div>
                        <div class="col-md-3">
                            <strong>Avg Goals/Doc:</strong> <span class="badge bg-success">${Math.round(courseData.total_goals / courseData.documents * 10) / 10}</span>
                                             </div>
                                                 </div>
                    <div class="mt-2">
                        <small class="text-muted">
                            üìö Ready to cluster goals from course "${courseData.name}"!
                        </small>
                        </div>
                    `;
                $('#overview-content').html(overviewHtml);
                
                // Update clustering controls for this course
                if (courseData.total_goals >= 2) {
                    $('#cluster-btn').prop('disabled', false);
                    if (courseData.total_goals >= 4) {
                        $('#find-optimal-btn').prop('disabled', false);
                    }
                    
                    // Set max clusters and suggested default
                    const maxClusters = courseData.total_goals;
                    $('#n-clusters-input').attr('max', maxClusters);
                    const suggestedClusters = Math.max(2, Math.min(Math.floor(courseData.total_goals * 0.2), 100));
                    $('#n-clusters-input').val(suggestedClusters);
                } else {
                    $('#cluster-btn').prop('disabled', true);
                    $('#find-optimal-btn').prop('disabled', true);
                    $('#goals-overview').removeClass('alert-info').addClass('alert-warning');
                    $('#overview-content').html(`
                        <p class="mb-0">
                            ‚ö†Ô∏è Course "${courseData.name}" only has ${courseData.total_goals} learning goals. Need at least 2 for clustering.
                        </p>
                    `);
                }
            }
        }
    }
    
    function performClustering(explicitClusters = null) {
        const nClusters = explicitClusters || $('#n-clusters-input').val();
        
        // Show progress tracker instead of simple loading spinner
        $('#loading-spinner').hide();
        $('#progress-tracker').show();
        $('#results-section').hide();
        $('#no-goals').hide();
        $('#cluster-btn').prop('disabled', true);
        
        // Reset progress indicators
        $('.step-indicator').removeClass('active completed error');
        $('#overall-progress').css('width', '0%');
        $('#current-step').text('Initializing...');
        
        // Reset optimization tracking state
        plannedTests = [];
        completedTests = [];
        currentTestIndex = 0;
        bestComposite = { clusters: 0, score: 0 };
        bestSilhouette = { clusters: 0, score: 0 };
        currentPhase = null;
        phaseProgress = {
            coarse: { planned: [], completed: 0, total: 0 },
            fine: { planned: [], completed: 0, total: 0 }
        };
        embeddingsSessionId = null; // Reset embeddings session
        optimizationData = []; // Reset optimization data
        selectedPoint = null; // Reset selected point
        bestResult = null; // Reset best result
        $('#best-so-far').empty();
        $('#latest-test-result').empty();
        $('#embeddings-download').hide(); // Hide download button
        
        // Clean up any existing processes
        cleanupActiveProcesses();
        
        // Show time warning for clustering
        $('#clustering-time-warning').show();
        
        // Use fetch with streaming and store abort controller
        const abortController = new AbortController();
        activeFetch = abortController;
        
        fetch('/api/cluster-stream', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                n_clusters: parseInt(nClusters),
                course_filter: selectedCourse  // Add course filter parameter
            }),
            signal: abortController.signal
        }).then(response => {
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            
            function processStream() {
                reader.read().then(({ done, value }) => {
                    if (done) {
                        console.log('Stream complete');
                        return;
                    }
                    
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n\n');
                    buffer = lines.pop(); // Keep incomplete line in buffer
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.substring(6));
                                handleClusteringProgress(data);
                            } catch (e) {
                                console.error('Error parsing SSE data:', e);
                            }
                        }
                    }
                    
                    processStream(); // Continue reading
                }).catch(error => {
                    console.error('Stream error:', error);
                    $('#progress-tracker').hide();
                $('#loading-spinner').hide();
                $('#cluster-btn').prop('disabled', false);
                    alert('Clustering failed: ' + error.message);
                });
            }
            
            processStream();
        }).catch(error => {
            console.error('Fetch error:', error);
            $('#progress-tracker').hide();
            $('#loading-spinner').hide();
            $('#cluster-btn').prop('disabled', false);
            alert('Failed to start clustering: ' + error.message);
        });
    }
    
    function handleClusteringProgress(data) {
        $('#current-step').text(data.message);
        
        // Update step indicators based on status
        switch(data.status) {
            case 'loading':
                $('.step-indicator').removeClass('active completed');
                $('#step-loading').addClass('active');
                $('#overall-progress').css('width', '10%');
                $('#progress-text').text('Loading...');
                break;
                
            case 'loaded':
                $('#step-loading').removeClass('active').addClass('completed');
                $('#step-loading small').text(`‚úì ${data.totalGoals} goals`);
                $('#overall-progress').css('width', '20%');
                $('#progress-text').text('Data Loaded');
                break;
                
            case 'embeddings':
                $('#step-embeddings').addClass('active');
                $('#overall-progress').css('width', '30%');
                $('#progress-text').text('Generating...');
                break;
                
            case 'embeddings_complete':
                $('#step-embeddings').removeClass('active').addClass('completed');
                // Inline download button next to complete text
                let downloadBtn = '';
                if (data.embeddings_session_id) {
                    embeddingsSessionId = data.embeddings_session_id;
                    downloadBtn = `<button class=\"btn btn-link p-0 m-0 text-muted\" style=\"font-size:0.9em;opacity:0.5;text-decoration:underline dotted;vertical-align:middle;\" onclick=\"downloadEmbeddings()\" title=\"Download embeddings as CSV\"><i class=\"bi bi-download\"></i><span class=\"visually-hidden\">Download embeddings as CSV</span></button>`;
                }
                $('#embeddings-status-text').html('‚úì Complete ' + downloadBtn);
                $('#overall-progress').css('width', '40%');
                $('#progress-text').text('Embeddings Ready');
                break;
                
            case 'clustering':
                $('#step-clustering').addClass('active');
                $('#overall-progress').css('width', '50%');
                $('#progress-text').text('Clustering...');
                break;
                
            case 'clustering_complete':
                $('#step-clustering').removeClass('active').addClass('completed');
                $('#step-clustering small').text('‚úì Complete');
                $('#overall-progress').css('width', '70%');
                $('#progress-text').text('Clustering Done');
                $('#clustering-time-warning').hide();
                break;
                
            case 'metrics':
                $('#step-metrics').addClass('active');
                if (data.progress) {
                    const overallProgress = 70 + (data.progress * 0.2);
                    $('#overall-progress').css('width', overallProgress + '%');
                    $('#progress-text').text('Calculating...');
                }
                break;
                
            case 'metrics_complete':
                $('#step-metrics').removeClass('active').addClass('completed');
                $('#step-metrics small').text('‚úì Complete');
                $('#overall-progress').css('width', '90%');
                $('#progress-text').text('Metrics Done');
                break;
                
            case 'organizing':
                if (data.progress) {
                    const overallProgress = 90 + (data.progress * 0.1);
                    $('#overall-progress').css('width', overallProgress + '%');
                    // Don't duplicate the message in progress-detail-text
                    $('#progress-text').text('Organizing...');
                }
                break;
                
            case 'complete':
                $('#overall-progress').css('width', '100%');
                $('#progress-text').text('Complete!');
                $('#current-step').text('Processing complete!');
                $('#clustering-time-warning').hide();
                
                // Hide progress tracker and show results
                setTimeout(() => {
                    $('#progress-tracker').hide();
                    displayResults(data.results);
                    $('#cluster-btn').prop('disabled', false);
                }, 1000);
                break;
                
            case 'error':
                $('.step-indicator.active').removeClass('active').addClass('error');
                $('#current-step').text('Error: ' + data.message);
                $('#progress-tracker').hide();
                $('#cluster-btn').prop('disabled', false);
                $('#clustering-time-warning').hide();
                cleanupActiveProcesses();
                
                if (data.message.includes('Need at least')) {
                    $('#no-goals').show();
                } else {
                    alert('Error: ' + data.message);
                }
                break;
        }
    }
    
    function findOptimalClusters() {
        // Show progress tracker
        $('#loading-spinner').hide();
        $('#progress-tracker').show();
        $('#results-section').hide();
        $('#no-goals').hide();
        $('#find-optimal-btn').prop('disabled', true);
        $('#cluster-btn').prop('disabled', true);
        
        // Reset progress indicators
        $('.step-indicator').removeClass('active completed error');
        $('#overall-progress').css('width', '0%');
        $('#current-step').text('Starting optimization...');
        
        // Reset optimization tracking state
        plannedTests = [];
        completedTests = [];
        currentTestIndex = 0;
        bestComposite = { clusters: 0, score: 0 };
        bestSilhouette = { clusters: 0, score: 0 };
        currentPhase = null;
        phaseProgress = {
            coarse: { planned: [], completed: 0, total: 0 },
            fine: { planned: [], completed: 0, total: 0 }
        };
        embeddingsSessionId = null; // Reset embeddings session
        optimizationData = []; // Reset optimization data
        selectedPoint = null; // Reset selected point
        bestResult = null; // Reset best result
        $('#best-so-far').empty();
        $('#latest-test-result').empty();
        $('#embeddings-download').hide(); // Hide download button
        
        // Clean up any existing processes
        cleanupActiveProcesses();
        
        // Adjust step indicators for optimization
        $('#step-clustering').find('div').eq(0).text('Optimization');
        $('#step-metrics').find('div').eq(0).text('Analysis');
        
        // Use fetch with streaming and store abort controller
        const abortController = new AbortController();
        activeFetch = abortController;
        
        fetch('/api/find-optimal-clusters-stream', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                course_filter: selectedCourse  // Add course filter parameter
            }),
            signal: abortController.signal
        }).then(response => {
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            
            function processOptimizationStream() {
                reader.read().then(({ done, value }) => {
                    if (done) return;
                    
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n\n');
                    buffer = lines.pop();
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.substring(6));
                                handleOptimizationProgress(data);
                            } catch (e) {
                                console.error('Error parsing SSE data:', e);
                            }
                        }
                    }
                    
                    processOptimizationStream();
                }).catch(error => {
                    console.error('Stream error:', error);
                    $('#progress-tracker').hide();
                    $('#find-optimal-btn').prop('disabled', false);
                    $('#cluster-btn').prop('disabled', false);
                    $('#cancel-optimization-btn').hide();
                    cleanupActiveProcesses();
                    alert('Optimization failed: ' + error.message);
                });
            }
            
            processOptimizationStream();
        }).catch(error => {
            console.error('Fetch error:', error);
            $('#progress-tracker').hide();
            $('#find-optimal-btn').prop('disabled', false);
            $('#cluster-btn').prop('disabled', false);
            $('#cancel-optimization-btn').hide();
            cleanupActiveProcesses();
            alert('Failed to start optimization: ' + error.message);
        });
    }
    
    // Track optimization state
    let plannedTests = [];
    let completedTests = [];
    let currentTestIndex = 0;
    let bestComposite = { clusters: 0, score: 0 };
    let bestSilhouette = { clusters: 0, score: 0 };
    let currentPhase = null;
    let phaseProgress = {
        coarse: { planned: [], completed: 0, total: 0 },
        fine: { planned: [], completed: 0, total: 0 }
    };
    
    function updateBestSoFar(k, composite, silhouette) {
        let updated = false;
        
        if (composite > bestComposite.score) {
            bestComposite = { clusters: k, score: composite };
            updated = true;
        }
        
        if (silhouette > bestSilhouette.score) {
            bestSilhouette = { clusters: k, score: silhouette };
            updated = true;
        }
        
        if (updated) {
            $('#best-so-far').html(
                `<small><strong>Best result so far:</strong> ` +
                `${bestComposite.clusters} clusters (composite score: ${bestComposite.score.toFixed(3)})</small>`
            );
        }
    }
    
    function parseOptimizationMessage(message) {
        // Parse structured messages
        if (message.includes('planned_tests:')) {
            const phase = message.includes('phase:') ? message.split('phase:')[1].split(',')[0] : 
                         message.includes('binary_search:') ? message.split('binary_search:')[1].split(',')[0] :
                         message.includes('elbow_search:') ? message.split('elbow_search:')[1].split(',')[0] : null;
            const testsStr = message.split('planned_tests:')[1];
            return {
                type: 'planned',
                phase: phase,
                tests: testsStr.split(',').map(k => parseInt(k))
            };
        } else if (message.includes('completed:')) {
            const parts = message.split(',');
            const k = parseInt(parts.find(p => p.includes('k=')).split('=')[1]);
            const silhouette = parseFloat(parts.find(p => p.includes('silhouette=')).split('=')[1]);
            const composite = parseFloat(parts.find(p => p.includes('composite=')).split('=')[1]);
            const inertia = parseFloat(parts.find(p => p.includes('inertia=')).split('=')[1]);
            const phase = message.includes('phase:') ? message.split('phase:')[1].split(',')[0] : 
                         message.includes('binary_search:') ? message.split('binary_search:')[1].split(',')[0] :
                         message.includes('elbow_search:') ? message.split('elbow_search:')[1].split(',')[0] : null;
            return {
                type: 'completed',
                phase: phase,
                k: k,
                silhouette: silhouette,
                composite: composite,
                inertia: inertia
            };
        } else if (message.includes('phase:') || message.includes('binary_search:') || message.includes('elbow_search:')) {
            const phase = message.includes('phase:') ? message.split('phase:')[1].split(',')[0] : 
                         message.includes('binary_search:') ? message.split('binary_search:')[1].split(',')[0] :
                         message.split('elbow_search:')[1].split(',')[0];
            return {
                type: 'phase',
                phase: phase
            };
        }
        return { type: 'other', message: message };
    }
    
    function handleOptimizationProgress(data) {
        $('#current-step').text(data.message);
        
        switch(data.status) {
            case 'loading':
                $('.step-indicator').removeClass('active completed');
                $('#step-loading').addClass('active');
                $('#overall-progress').css('width', '10%');
                $('#progress-text').text('Loading...');
                break;
                
            case 'loaded':
                $('#step-loading').removeClass('active').addClass('completed');
                $('#step-loading small').text(`‚úì ${data.totalGoals} goals`);
                $('#overall-progress').css('width', '20%');
                $('#progress-text').text('Data Loaded');
                break;
                
            case 'embeddings':
                $('#step-embeddings').addClass('active');
                $('#overall-progress').css('width', '30%');
                $('#progress-text').text('Generating...');
                break;
                
            case 'embeddings_complete':
                $('#step-embeddings').removeClass('active').addClass('completed');
                // Inline download button next to complete text
                let downloadBtn = '';
                if (data.embeddings_session_id) {
                    embeddingsSessionId = data.embeddings_session_id;
                    downloadBtn = `<button class=\"btn btn-link p-0 m-0 text-muted\" style=\"font-size:0.9em;opacity:0.5;text-decoration:underline dotted;vertical-align:middle;\" onclick=\"downloadEmbeddings()\" title=\"Download embeddings as CSV\"><i class=\"bi bi-download\"></i><span class=\"visually-hidden\">Download embeddings as CSV</span></button>`;
                }
                $('#embeddings-status-text').html('‚úì Complete ' + downloadBtn);
                $('#overall-progress').css('width', '40%');
                $('#progress-text').text('Embeddings Ready');
                break;
                
            case 'optimization_start':
                $('#step-clustering').addClass('active');
                $('#overall-progress').css('width', '45%');
                $('#progress-text').text('Starting...');
                $('#optimization-progress').show();
                
                // Initialize the optimization chart
                initializeOptimizationChart();
                optimizationData = [];
                selectedPoint = null;
                bestResult = null;
                $('#use-selected-btn').prop('disabled', true).removeClass('btn-success').addClass('btn-primary');
                $('#add-more-points-btn').prop('disabled', true);
                $('#cancel-optimization-btn').hide(); // Hide cancel button during initial phase
                $('#selection-status').text('Initial sampling in progress...');
                $('#search-phase').text('Initial sampling');
                break;
                
            case 'optimizing':
                $('#step-clustering').addClass('active'); // Keep it active, not completed
                
                // Parse the structured message
                const parsed = parseOptimizationMessage(data.message);
                
                if (parsed.type === 'planned') {
                    // Store planned tests for the phase
                    const phase = parsed.phase || 'initial';
                    currentPhase = phase;
                    plannedTests = parsed.tests;
                    completedTests = [];
                    
                    if (phase === 'initial') {
                        $('#search-phase').text('Initial sampling');
                        $('#selection-status').text(`Testing ${parsed.tests.length} initial points...`);
                    } else if (phase === 'refine') {
                        $('#search-phase').text('Adding detail');
                        $('#selection-status').text(`Adding ${parsed.tests.length} refinement points...`);
                    }
                } else if (parsed.type === 'completed') {
                    // Add to completed tests and update displays
                    completedTests.push(parsed);
                    
                    // Store result for chart and tracking
                    const result = {
                        k: parsed.k,
                        composite: parsed.composite,
                        silhouette: parsed.silhouette,
                        inertia: parsed.inertia
                    };
                    optimizationData.push(result);
                    
                    // Track best for reference (but don't auto-select)
                    if (!bestResult || parsed.composite > bestResult.composite) {
                        bestResult = result;
                    }
                    
                    // Add point to chart
                    addOptimizationPoint(parsed.k, parsed.composite, parsed.inertia, parsed.silhouette);
                    
                    // Update best so far for reference
                    updateBestSoFar(parsed.k, parsed.composite, parsed.silhouette);
                    
                    // Latest completed test
                    $('#latest-test-result').html(
                        `<small><strong>Latest completed:</strong> ${parsed.k} clusters - ` +
                        `composite=${parsed.composite.toFixed(3)}, inertia=${parsed.inertia.toFixed(0)}</small>`
                    );
                    
                    // Update current step
                    $('#current-step').text(`Analyzed ${parsed.k} clusters...`);
                    
                    // Update simple test count
                    $('#tests-completed').text(completedTests.length);
                    
                    // Update overall progress based on number of tests
                    const progressPercent = Math.min(90, 45 + (completedTests.length * 5)); // Gradually increase
                    $('#overall-progress').css('width', progressPercent + '%');
                    $('#progress-text').text(`Elbow Detection...`);
                    
                    // After initial sampling is complete, enable interactions
                    if (currentPhase === 'initial' && completedTests.length >= plannedTests.length) {
                        enableInteractiveMode();
                    }
                }
                break;
                
            case 'optimization_complete':
                $('#step-clustering').removeClass('active').addClass('completed');
                $('#step-clustering small').text('‚úì Complete');
                $('#step-metrics').addClass('completed');
                $('#step-metrics small').text('‚úì Complete');
                $('#overall-progress').css('width', '100%');
                $('#progress-text').text('Ready for Selection!');
                
                // Enable final selection mode
                enableInteractiveMode();
                $('#selection-status').html('<strong style="color: #28a745;">‚úì Ready!</strong> Click any point to select, or add more points for detail');
                break;
                
            case 'results':
                // In interactive elbow detection mode, don't immediately cleanup
                // Keep the session alive for user interaction
                const response = data.results;
                if (response.success) {
                    // Enable final interactive mode but don't cleanup yet
                    enableInteractiveMode();
                    $('#selection-status').html('<strong style="color: #28a745;">‚úì Initial analysis complete!</strong> Click any point to select, or add more points for detail');
                    $('#current-step').text('Interactive mode ready - select a point to proceed');
                    $('#progress-text').text('Ready for Selection!');
                    
                    // Update UI to show completion but keep interactive
                    $('#step-clustering').removeClass('active').addClass('completed');
                    $('#step-clustering small').text('‚úì Complete');
                    $('#step-metrics').addClass('completed');
                    $('#step-metrics small').text('‚úì Complete');
                    $('#overall-progress').css('width', '100%');
                } else {
                    // Only cleanup on actual errors
                    $('#progress-tracker').hide();
                    $('#find-optimal-btn').prop('disabled', false);
                    $('#cluster-btn').prop('disabled', false);
                    cleanupActiveProcesses();
                    alert('Error: ' + response.message);
                }
                break;
                
            case 'error':
                // Handle optimization errors with proper cleanup
                $('.step-indicator.active').removeClass('active').addClass('error');
                $('#current-step').text('Error: ' + data.message);
                $('#progress-tracker').hide();
                $('#find-optimal-btn').prop('disabled', false);
                $('#cluster-btn').prop('disabled', false);
                $('#cancel-optimization-btn').hide();
                cleanupActiveProcesses();
                
                // Reset optimization state
                optimizationData = [];
                selectedPoint = null;
                bestResult = null;
                
                if (data.message.includes('Need at least')) {
                        $('#no-goals').show();
                    } else {
                    alert('Optimization error: ' + data.message);
                }
                break;
        }
    }
    
    function enableInteractiveMode() {
        // Enable the "Add More Points" button
        $('#add-more-points-btn').prop('disabled', false);
        
        // Show the cancel button for user to abort if needed
        $('#cancel-optimization-btn').show();
        
        // Update selection status
        if (optimizationData.length > 0) {
            $('#selection-status').text('Click any blue dot to select, or add more points for detail');
        }
        
        // If we have data, user can select points
        if (optimizationChart && optimizationChart.data.datasets[0].data.length > 0) {
            $('#use-selected-btn').prop('disabled', false);
        }
    }
    
    // Cancel the optimization session
    function cancelOptimization() {
        // Clean up the optimization stream
        cleanupActiveProcesses();
        
        // Hide progress tracker and re-enable buttons
        $('#progress-tracker').hide();
        $('#find-optimal-btn').prop('disabled', false);
                $('#cluster-btn').prop('disabled', false);
        
        // Reset optimization state
        optimizationData = [];
        selectedPoint = null;
        bestResult = null;
        
        // Hide cancel button
        $('#cancel-optimization-btn').hide();
        
        console.log('Optimization session cancelled by user');
    }

    // Add more points around areas of interest
    function addMorePoints() {
        if (optimizationData.length === 0) {
            alert('No initial data available. Please run initial optimization first.');
            return;
        }
        
        // Prompt user for target region
        const currentPoints = optimizationData.map(d => d.k).sort((a, b) => a - b);
        const minK = Math.min(...currentPoints);
        const maxK = Math.max(...currentPoints);
        
        let targetK;
        if (selectedPoint) {
            // Default to area around selected point
            targetK = selectedPoint.k;
        } else if (bestResult) {
            // Default to area around best result
            targetK = bestResult.k;
        } else {
            // Default to middle of range
            targetK = Math.round((minK + maxK) / 2);
        }
        
        // Ask user where to add more points
        const userInput = prompt(
            `Add more points around which cluster size?\n\n` +
            `Current range: ${minK} to ${maxK} clusters\n` +
            `Suggestion: ${targetK} (around ${selectedPoint ? 'selected' : bestResult ? 'best' : 'middle'} point)`,
            targetK
        );
        
        if (!userInput) return;
        
        const targetRegionCenter = parseInt(userInput);
        if (isNaN(targetRegionCenter) || targetRegionCenter < 2) {
            alert('Please enter a valid cluster size (minimum 2)');
            return;
        }
        
        // Disable the button during refinement
        $('#add-more-points-btn').prop('disabled', true).text('Adding Points...');
        $('#selection-status').text(`Adding refinement points around ${targetRegionCenter} clusters...`);
        
        // Clean up any existing processes
        cleanupActiveProcesses();
        
        // Start refinement request
        const abortController = new AbortController();
        activeFetch = abortController;
        
        fetch('/api/add-elbow-refinement', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                target_region_center: targetRegionCenter,
                existing_results: optimizationData,
                region_radius: null,  // Let backend decide
                course_filter: selectedCourse  // Add course filter parameter
            }),
            signal: abortController.signal
        }).then(response => {
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            
            function processRefinementStream() {
                reader.read().then(({ done, value }) => {
                    if (done) return;
                    
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n\n');
                    buffer = lines.pop();
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.substring(6));
                                handleRefinementProgress(data);
                            } catch (e) {
                                console.error('Error parsing refinement SSE data:', e);
                            }
                        }
                    }
                    
                    processRefinementStream();
                }).catch(error => {
                    console.error('Refinement stream error:', error);
                    $('#add-more-points-btn').prop('disabled', false).text('Add More Points');
                    $('#selection-status').text('Error adding points. Try again.');
                });
            }
            
            processRefinementStream();
        }).catch(error => {
            console.error('Refinement fetch error:', error);
            $('#add-more-points-btn').prop('disabled', false).text('Add More Points');
            $('#selection-status').text('Error adding points. Try again.');
        });
    }
    
    function handleRefinementProgress(data) {
        switch(data.status) {
            case 'starting':
            case 'loading':
            case 'loaded':
            case 'embeddings':
            case 'embeddings_complete':
                // These are quick, just update status
                $('#selection-status').text(data.message);
                break;
                
            case 'refining':
                // Parse refinement progress like optimization progress
                const parsed = parseOptimizationMessage(data.message);
                
                if (parsed.type === 'planned') {
                    $('#selection-status').text(`Adding ${parsed.tests.length} new points...`);
                } else if (parsed.type === 'completed') {
                    // Add new point to chart and data
                    const result = {
                        k: parsed.k,
                        composite: parsed.composite,
                        silhouette: parsed.silhouette,
                        inertia: parsed.inertia
                    };
                    
                    // Check if this is truly a new point
                    const existingPoint = optimizationData.find(d => d.k === parsed.k);
                    if (!existingPoint) {
                        optimizationData.push(result);
                        addOptimizationPoint(parsed.k, parsed.composite, parsed.inertia, parsed.silhouette);
                        
                        // Update latest test
                        $('#latest-test-result').html(
                            `<small><strong>New point added:</strong> ${parsed.k} clusters - ` +
                            `composite=${parsed.composite.toFixed(3)}, inertia=${parsed.inertia.toFixed(0)}</small>`
                        );
                        
                        // Update total count
                        $('#tests-completed').text(optimizationData.length);
                    }
                }
                break;
                
            case 'refinement_complete':
                $('#add-more-points-btn').prop('disabled', false).html('<i class="bi bi-plus-circle"></i> Add More Points');
                $('#selection-status').text('Refinement complete! Click any point to select, or add more points.');
                break;
                
            case 'results':
                const results = data.results;
                if (results.success) {
                    $('#latest-test-result').html(
                        `<small><strong>Success:</strong> Added ${results.new_points_added} new points ` +
                        `(${results.total_points} total)</small>`
                    );
                } else {
                    $('#latest-test-result').html(
                        `<small class="text-warning"><strong>Note:</strong> ${data.message}</small>`
                    );
                }
                $('#add-more-points-btn').prop('disabled', false).html('<i class="bi bi-plus-circle"></i> Add More Points');
                $('#selection-status').text('Click any point to select, or add more points for detail.');
                break;
                
            case 'error':
                $('#add-more-points-btn').prop('disabled', false).html('<i class="bi bi-plus-circle"></i> Add More Points');
                $('#selection-status').html(`<span class="text-danger">Error: ${data.message}</span>`);
                break;
        }
    }
    
    function displayResults(data) {
        // Display stats
        const qualityLabel = getQualityLabel(data.silhouette_score);
        const separationLabel = getSeparationLabel(data.inter_cluster_separation);
        const cohesionLabel = getCohesionLabel(data.intra_cluster_cohesion);
        const statsHtml = `
            <h5><i class="bi bi-graph-up"></i> Clustering Results</h5>
            <div class="row mb-2">
                <div class="col-md-4">
                    <strong>Total Goals:</strong> ${data.total_goals} | <strong>Clusters:</strong> ${data.n_clusters}
                </div>
                <div class="col-md-3">
                    <strong>Silhouette Score:</strong> ${data.silhouette_score} 
                    <span class="badge ${qualityLabel.class}">${qualityLabel.text}</span>
                </div>
                <div class="col-md-2.5">
                    <strong>Cluster Separation:</strong> ${data.inter_cluster_separation} 
                    <span class="badge ${separationLabel.class}">${separationLabel.text}</span>
                </div>
                <div class="col-md-2.5">
                    <strong>Cluster Cohesion:</strong> ${data.intra_cluster_cohesion} 
                    <span class="badge ${cohesionLabel.class}">${cohesionLabel.text}</span>
                </div>
            </div>
            <div class="row">
                <div class="col-12">
                    <small class="text-muted">
                        <strong>Silhouette:</strong> Overall clustering quality (STEM-optimized: 0.25+ is good) | 
                        <strong>Separation:</strong> How distinct clusters are from each other (STEM-optimized: 0.2+ is good) | 
                        <strong>Cohesion:</strong> How similar goals within clusters are (higher = better)
                    </small>
                </div>
            </div>
        `;
        $('#clustering-stats').html(statsHtml);
        
        // Sort clusters by ID to ensure chronological order (outliers at the end)
        const sortedClusters = data.clusters.slice().sort(function(a, b) {
            const aIsOutlier = String(a.id).startsWith('outlier');
            const bIsOutlier = String(b.id).startsWith('outlier');
            
            // Put outliers at the end
            if (aIsOutlier && !bIsOutlier) return 1;
            if (!aIsOutlier && bIsOutlier) return -1;
            if (aIsOutlier && bIsOutlier) return 0;
            
            // Sort regular clusters by ID
            return parseInt(a.id) - parseInt(b.id);
        });
        
        // Display clusters
        let clustersHtml = '';
        sortedClusters.forEach(function(cluster, index) {
            const clusterColor = getClusterColor(parseInt(cluster.id) || index);
            const isOutlier = String(cluster.id).startsWith('outlier');
            // Display 1-based indexing for UI (cluster.id is 0-based from backend)
            const displayClusterId = isOutlier ? cluster.id : (parseInt(cluster.id) + 1);
            const clusterTitle = isOutlier ? `Outlier ${cluster.id}` : `Cluster ${displayClusterId}`;
            
            clustersHtml += `
                <div class="cluster-section">
                    <div class="cluster-title">
                        ${clusterTitle} 
                        <span class="badge bg-primary text-white ms-2">${cluster.size}</span>
                        ${isOutlier ? ' ‚ö†Ô∏è' : ''}
                    </div>
                    <div class="cluster-representative">
                        Representative: "${truncateText(cluster.representative_goal, 100)}"
                    </div>
                    <div class="row">
            `;
            
            cluster.goals.forEach(function(goal, goalIndex) {
                const source = cluster.sources[goalIndex];
                clustersHtml += `
                    <div class="col-md-6 mb-2">
                        <div class="goal-item">
                            <div class="goal-text">"${goal}"</div>
                            <div class="goal-source">
                                üìÑ ${truncateText(source.document_name, 25)} | 
                                üë§ ${truncateText(source.creator, 15)}
                                ${source.course_name ? ` | üìö ${truncateText(source.course_name, 20)}` : ''}
                            </div>
                        </div>
                    </div>
                `;
            });
            
            clustersHtml += `
                    </div>
                </div>
            `;
        });
        
        $('#clusters-container').html(clustersHtml);
        $('#results-section').show();
    }
    
    function getClusterColor(index) {
        const colors = [
            'linear-gradient(45deg, #007bff, #0056b3)',
            'linear-gradient(45deg, #28a745, #1e7e34)',
            'linear-gradient(45deg, #dc3545, #bd2130)',
            'linear-gradient(45deg, #ffc107, #d39e00)',
            'linear-gradient(45deg, #17a2b8, #117a8b)',
            'linear-gradient(45deg, #6f42c1, #5a32a3)',
            'linear-gradient(45deg, #fd7e14, #d35400)',
            'linear-gradient(45deg, #20c997, #16a085)',
            'linear-gradient(45deg, #e83e8c, #d91a72)',
            'linear-gradient(45deg, #6c757d, #5a6268)'
        ];
        return colors[index % colors.length];
    }
    
    function getQualityLabel(score) {
        // STEM-optimized thresholds: Domain-specific content has naturally higher semantic similarity
        // Adjusted for educational content where 0.2-0.4 silhouette is actually good performance
        if (score >= 0.4) return {class: 'bg-success', text: 'Excellent'};
        if (score >= 0.25) return {class: 'bg-info', text: 'Good'};
        if (score >= 0.15) return {class: 'bg-warning', text: 'Fair'};
        if (score >= 0.05) return {class: 'bg-warning', text: 'Poor'};
        return {class: 'bg-secondary', text: 'N/A'};
    }
    
    function getSeparationLabel(score) {
        // STEM-optimized thresholds: STEM topics are naturally more similar
        // Adjusted for domain-specific content where 0.2-0.4 separation is actually good
        if (score >= 0.3) return {class: 'bg-success', text: 'Excellent'};
        if (score >= 0.2) return {class: 'bg-info', text: 'Good'};
        if (score >= 0.15) return {class: 'bg-warning', text: 'Fair'};
        return {class: 'bg-danger', text: 'Poor'};
    }
    
    function getCohesionLabel(score) {
        // Higher similarity = better cohesion within clusters
        if (score >= 0.7) return {class: 'bg-success', text: 'Tight'};
        if (score >= 0.5) return {class: 'bg-info', text: 'Good'};
        if (score >= 0.3) return {class: 'bg-warning', text: 'Loose'};
        return {class: 'bg-danger', text: 'Scattered'};
    }
    
    function truncateText(text, maxLength) {
        if (text.length <= maxLength) return text;
        return text.substring(0, maxLength) + '...';
    }
    
    // Initialize optimization chart
    function initializeOptimizationChart() {
        const ctx = document.getElementById('optimization-chart').getContext('2d');
        
        if (optimizationChart) {
            optimizationChart.destroy();
        }
        
        optimizationChart = new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Composite Quality',
                    data: [],
                    backgroundColor: 'rgba(54, 162, 235, 0.7)',
                    borderColor: 'rgba(54, 162, 235, 1)',
                    pointRadius: 6,
                    pointHoverRadius: 8,
                    yAxisID: 'y'
                }, {
                    label: 'Silhouette Score',
                    data: [],
                    backgroundColor: 'rgba(75, 192, 192, 0.7)',
                    borderColor: 'rgba(75, 192, 192, 1)',
                    pointRadius: 5,
                    pointHoverRadius: 7,
                    yAxisID: 'y'
                }, {
                    label: 'Inertia (WCSS)',
                    data: [],
                    type: 'line',
                    borderColor: 'rgba(255, 99, 132, 1)',
                    backgroundColor: 'rgba(255, 99, 132, 0.1)',
                    borderWidth: 2,
                    pointRadius: 4,
                    pointHoverRadius: 6,
                    fill: false,
                    tension: 0.1,
                    yAxisID: 'y1'
                }, {
                    label: 'Fair Silhouette (0.2)',
                    data: [],
                    type: 'line',
                    borderColor: 'rgba(128, 128, 128, 0.5)',
                    backgroundColor: 'rgba(128, 128, 128, 0.1)',
                    borderWidth: 1,
                    borderDash: [5, 5],
                    pointRadius: 0,
                    pointHoverRadius: 0,
                    fill: false,
                    yAxisID: 'y'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'linear',
                        title: {
                            display: true,
                            text: 'Number of Clusters'
                        },
                        min: undefined, // Auto-scale
                        max: undefined  // Auto-scale
                    },
                    y: {
                        type: 'linear',
                        position: 'left',
                        title: {
                            display: true,
                            text: 'Quality Scores (Composite & Silhouette)',
                            color: 'rgba(54, 162, 235, 1)'
                        },
                        min: 0,
                        max: 1,
                        grid: {
                            drawOnChartArea: true,
                        },
                        ticks: {
                            color: 'rgba(54, 162, 235, 1)'
                        }
                    },
                    y1: {
                        type: 'linear',
                        position: 'right',
                        title: {
                            display: true,
                            text: 'Inertia (Within-Cluster Sum of Squares)',
                            color: 'rgba(255, 99, 132, 1)'
                        },
                        min: undefined, // Auto-scale
                        max: undefined, // Auto-scale
                        grid: {
                            drawOnChartArea: false,
                        },
                        ticks: {
                            color: 'rgba(255, 99, 132, 1)'
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'bottom'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const value = context.parsed.y;
                                const datasetIndex = context.datasetIndex;
                                
                                if (datasetIndex === 0) {
                                    return `Composite Quality: ${value.toFixed(3)} (${context.parsed.x} clusters)`;
                                } else if (datasetIndex === 1) {
                                    return `Silhouette Score: ${value.toFixed(3)} (${context.parsed.x} clusters)`;
                                } else if (datasetIndex === 2) {
                                    return `Inertia: ${value.toFixed(0)} (${context.parsed.x} clusters)`;
                                } else if (datasetIndex === 3) {
                                    return `Fair Silhouette Threshold: 0.2`;
                                }
                                return `${context.dataset.label}: ${value.toFixed(3)}`;
                            }
                        }
                    }
                },
                interaction: {
                    intersect: false,
                    mode: 'index'
                },
                onClick: function(event, elements) {
                    if (elements.length > 0) {
                        const elementIndex = elements[0].index;
                        const datasetIndex = elements[0].datasetIndex;
                        
                        // Allow selection of composite quality points (dataset 0) or silhouette points (dataset 1)
                        if (datasetIndex === 0 || datasetIndex === 1) {
                            const point = optimizationChart.data.datasets[datasetIndex].data[elementIndex];
                            const clusters = point.x;
                            
                            // Find the full result data for this cluster count
                            const resultData = optimizationData.find(r => r.k === clusters);
                            if (resultData) {
                                selectPoint(resultData);
                            }
                        }
                    }
                }
            }
        });
    }

    // Add point to optimization chart
    function addOptimizationPoint(clusters, quality, inertia, silhouette) {
        if (!optimizationChart) return;
        
        // Add composite quality point (dataset 0)
        optimizationChart.data.datasets[0].data.push({
            x: clusters,
            y: quality
        });
        
        // Add silhouette score point (dataset 1)
        optimizationChart.data.datasets[1].data.push({
            x: clusters,
            y: silhouette
        });
        
        // Add inertia point (dataset 2 - line chart)
        optimizationChart.data.datasets[2].data.push({
            x: clusters,
            y: inertia
        });
        
        // Sort inertia data by x-axis for proper line connection
        optimizationChart.data.datasets[2].data.sort((a, b) => a.x - b.x);
        
        // Update reference line to span the current x-axis range
        const allXValues = optimizationChart.data.datasets[0].data.map(point => point.x);
        if (allXValues.length > 0) {
            const minX = Math.min(...allXValues);
            const maxX = Math.max(...allXValues);
            
            // Update reference line (dataset 3) to span full range
            optimizationChart.data.datasets[3].data = [
                { x: minX, y: 0.2 },
                { x: maxX, y: 0.2 }
            ];
            
            // Auto-scale x-axis
            const xPadding = (maxX - minX) * 0.1; // 10% padding
            optimizationChart.options.scales.x.min = Math.max(0, minX - xPadding);
            optimizationChart.options.scales.x.max = maxX + xPadding;
        }
        
        // Auto-scale inertia axis
        const allInertiaValues = optimizationChart.data.datasets[2].data.map(point => point.y);
        if (allInertiaValues.length > 0) {
            const minInertia = Math.min(...allInertiaValues);
            const maxInertia = Math.max(...allInertiaValues);
            const inertiaPadding = (maxInertia - minInertia) * 0.1; // 10% padding
            
            optimizationChart.options.scales.y1.min = Math.max(0, minInertia - inertiaPadding);
            optimizationChart.options.scales.y1.max = maxInertia + inertiaPadding;
        }
        
        optimizationChart.update('none'); // Fast update without animation
    }

    // Select a point on the chart for clustering
    function selectPoint(resultData) {
        selectedPoint = resultData;
        
        // Update UI to show selection
        $('#use-selected-btn').prop('disabled', false).removeClass('btn-primary').addClass('btn-success');
        $('#selection-status').html(`<strong>Selected:</strong> ${resultData.k} clusters (composite: ${resultData.composite.toFixed(3)}, silhouette: ${resultData.silhouette.toFixed(3)}, inertia: ${resultData.inertia.toFixed(0)})`);
        
        // Highlight selected point on chart
        updateChartSelection(resultData.k);
        
        console.log('Selected point:', resultData);
    }

    // Update chart to highlight selected point
    function updateChartSelection(selectedK) {
        if (!optimizationChart) return;
        
        // Reset all point styles for composite quality points (dataset 0)
        optimizationChart.data.datasets[0].pointBackgroundColor = optimizationChart.data.datasets[0].data.map(() => 'rgba(54, 162, 235, 0.7)');
        optimizationChart.data.datasets[0].pointBorderColor = optimizationChart.data.datasets[0].data.map(() => 'rgba(54, 162, 235, 1)');
        optimizationChart.data.datasets[0].pointRadius = optimizationChart.data.datasets[0].data.map(() => 6);
        
        // Reset all point styles for silhouette score points (dataset 1)
        optimizationChart.data.datasets[1].pointBackgroundColor = optimizationChart.data.datasets[1].data.map(() => 'rgba(75, 192, 192, 0.7)');
        optimizationChart.data.datasets[1].pointBorderColor = optimizationChart.data.datasets[1].data.map(() => 'rgba(75, 192, 192, 1)');
        optimizationChart.data.datasets[1].pointRadius = optimizationChart.data.datasets[1].data.map(() => 5);
        
        // Highlight selected points for both datasets
        const selectedCompositeIndex = optimizationChart.data.datasets[0].data.findIndex(point => point.x === selectedK);
        const selectedSilhouetteIndex = optimizationChart.data.datasets[1].data.findIndex(point => point.x === selectedK);
        
        if (selectedCompositeIndex !== -1) {
            optimizationChart.data.datasets[0].pointBackgroundColor[selectedCompositeIndex] = 'rgba(40, 167, 69, 0.9)';
            optimizationChart.data.datasets[0].pointBorderColor[selectedCompositeIndex] = 'rgba(40, 167, 69, 1)';
            optimizationChart.data.datasets[0].pointRadius[selectedCompositeIndex] = 10;
        }
        
        if (selectedSilhouetteIndex !== -1) {
            optimizationChart.data.datasets[1].pointBackgroundColor[selectedSilhouetteIndex] = 'rgba(40, 167, 69, 0.9)';
            optimizationChart.data.datasets[1].pointBorderColor[selectedSilhouetteIndex] = 'rgba(40, 167, 69, 1)';
            optimizationChart.data.datasets[1].pointRadius[selectedSilhouetteIndex] = 8;
        }
        
        optimizationChart.update('none');
    }

    // Use selected point for clustering
    function useSelectedPoint() {
        if (!selectedPoint) {
            alert('No point selected. Click on a point in the chart first.');
            return;
        }
        
        // Clean up the optimization stream now that user has made selection
        cleanupActiveProcesses();
        
        // Hide progress tracker and re-enable buttons
        $('#progress-tracker').hide();
        $('#find-optimal-btn').prop('disabled', false);
        $('#cluster-btn').prop('disabled', false);
        
        // Hide cancel button since user is proceeding
        $('#cancel-optimization-btn').hide();
        
        // Apply the selected cluster size
        $('#optimizationModal').modal('hide');
        $('#n-clusters-input').val(selectedPoint.k);
        window.performClustering(selectedPoint.k);
    }
    
    // Make functions globally accessible for modal buttons
    window.applyOptimalClusters = applyOptimalClusters;
    window.performClustering = performClustering;
    window.useSelectedPoint = useSelectedPoint;
    window.addMorePoints = addMorePoints;
    window.cancelOptimization = cancelOptimization;
});
</script>
{% endblock %} 